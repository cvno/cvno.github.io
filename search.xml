<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[hexo: ERROR Process failed: _posts/*]]></title>
      <url>/hexo-ERROR-Process-failed-posts/</url>
      <content type="html"><![CDATA[<p>文章的格式出现错误了</p>
<a id="more"></a>
<ul>
<li>错误提示</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ hexo s</div><div class="line">ERROR Process failed: _posts/*</div><div class="line">Error at </div><div class="line">.....</div></pre></td></tr></table></figure>
<ul>
<li>原因</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">title: Hexo</div><div class="line">date: 2017-12-13 12:21:33</div><div class="line">tags:Hexo #tags冒号后面应当有个空格,其他地方也应当注意</div></pre></td></tr></table></figure>
<ul>
<li>正确格式(加上那个空格就好了)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">title: Hexo</div><div class="line">date: 2017-12-13 12:21:33</div><div class="line">tags: Hexo</div></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://shitaibin.github.io/2015/12/13/hexo-errors/" target="_blank" rel="external">http://shitaibin.github.io/2015/12/13/hexo-errors/</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python:消息队列Rabbitmq基本使用]]></title>
      <url>/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97Rabbitmq%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>为什么用Rabbitmq instead of python queue ?</p>
<a id="more"></a>
<blockquote>
<p>是因为python queue 不能跨进程 </p>
</blockquote>
<p><strong>队列的作用:</strong>    </p>
<pre><code>1. 存储消息、数据
2. 保证消息顺序 
3. 保证数据的交付
</code></pre><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 斐波那契数列</span></div><div class="line">1 1 2 3 5 8 13 ...</div><div class="line"><span class="comment"># 启动rabbitmq，并验证启动情况 </span></div><div class="line">rabbitmq-server --detached &amp;ps aux |grep rabbitmq</div><div class="line"><span class="comment"># 以服务的方式启动</span></div><div class="line">service rabbitmq-server start</div><div class="line"><span class="comment"># 启用维护插件</span></div><div class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management </div><div class="line"><span class="comment"># 重启</span></div><div class="line">service rabbitmq-server restart</div><div class="line"></div><div class="line"><span class="comment"># erroe</span></div><div class="line">pika.exceptions.ProbableAuthenticationError</div><div class="line"><span class="comment"># 解决方法</span></div><div class="line"><span class="comment"># 写入信息 并保存/关闭防火墙 'systemctl stop filewallf'</span></div><div class="line">vim /etc/rabbitmq/rabbitmq.config</div><div class="line">[&#123;rabbit, [&#123;loopback_users, []&#125;]&#125;].</div><div class="line"><span class="comment"># 查看当前队列</span></div><div class="line">rabbitmqctl list_queues</div></pre></td></tr></table></figure>
<h2 id="基本使用实现"><a href="#基本使用实现" class="headerlink" title="基本使用实现"></a>基本使用实现</h2><h3 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line"><span class="comment"># 创建连接</span></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 声明消息队列</span></div><div class="line">channel.queue_declare(queue=<span class="string">'hello'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 发送消息到上面声明的hello队列，</span></div><div class="line"><span class="comment"># 其中exchange表示交换器，能精确指定消息应该发送到哪个队列，</span></div><div class="line"><span class="comment"># routing_key设置为队列的名称，</span></div><div class="line"><span class="comment"># body就是发送的内容，</span></div><div class="line">channel.basic_publish(exchange=<span class="string">''</span>,routing_key=<span class="string">'hello'</span>,body=<span class="string">'Hello World!'</span>)</div><div class="line"></div><div class="line">print(<span class="string">'[x] Sent "Hello World!"'</span>)</div><div class="line"></div><div class="line"><span class="comment"># sh命令</span></div><div class="line"><span class="comment"># 用 rabbitmqctl list_queues 查看队列</span></div><div class="line"><span class="string">'''</span></div><div class="line">Listing queues</div><div class="line">hello	1</div><div class="line">'''</div></pre></td></tr></table></figure>
<p><img src="http://onk83djzp.bkt.clouddn.com/15021926446211.png" alt=""></p>
<h3 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line"><span class="comment"># 创建连接</span></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 声明消息队列</span></div><div class="line">channel.queue_declare(queue=<span class="string">'hello'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 接收消息 回调函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callbcak</span><span class="params">(ch,method,properties,body)</span>:</span></div><div class="line">    print(<span class="string">"Received %r"</span>%(body))</div><div class="line"></div><div class="line"><span class="comment"># 告诉rabbitmq使用callback来接收信息</span></div><div class="line">channel.basic_consume(callbcak,queue=<span class="string">'hello'</span>,no_ack=<span class="keyword">True</span>)</div><div class="line"></div><div class="line"><span class="comment">#开始接收信息，并进入阻塞状态，队列里有信息才会调用callback进行处理。按ctrl+c退出。</span></div><div class="line">channel.start_consuming()</div><div class="line"></div><div class="line"><span class="comment"># 终端会阻塞住</span></div><div class="line"><span class="string">'''</span></div><div class="line">Received b'Hello World!'</div><div class="line">'''</div></pre></td></tr></table></figure>
<h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><h3 id="消息不丢失"><a href="#消息不丢失" class="headerlink" title="消息不丢失"></a>消息不丢失</h3><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">    msg = <span class="string">' '</span>.join(sys.argv[<span class="number">1</span>:])<span class="keyword">or</span> <span class="string">'Hello World! %s'</span> % time.time()</div><div class="line">    channel.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">                          routing_key=<span class="string">'hello'</span>,</div><div class="line">                          body=bytes(msg,encoding=<span class="string">'utf8'</span>),)</div></pre></td></tr></table></figure>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><ul>
<li><code>no_ack=False</code> 消费者退出不消息不丢失</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 修改回调函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callbcak</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">"Received %r"</span> % (body))</div><div class="line">    time.sleep(<span class="number">5</span>)</div><div class="line">    print(<span class="string">"[x] Done"</span>)</div></pre></td></tr></table></figure>
<h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><ul>
<li>消息持久化存储,</li>
</ul>
<blockquote>
<p>虽然消息反馈机制，但是如果rabbitmq自身挂掉的话，那么任务还是会丢失。所以需要将任务持久化存储起来。声明持久化存储：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 原队列</span></div><div class="line">channel.queue_declare(queue=<span class="string">'hello'</span>, durable=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<p>但是这个程序会执行错误，因为hello这个队列已经存在，并且是非持久化的，rabbitmq不允许使用不同的参数来重新定义存在的队列。重新定义一个队列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 重新定义一个队列</span></div><div class="line">channel.queue_declare(queue=<span class="string">'task_queue'</span>, durable=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<p>在发送任务的时候，用delivery_mode=2来标记任务为持久化存储：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">channel.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">       routing_key=<span class="string">"task_queue"</span>,</div><div class="line">       body=message,</div><div class="line">       properties=pika.BasicProperties(</div><div class="line">          delivery_mode = <span class="number">2</span>, <span class="comment"># make message persistent</span></div><div class="line">       ))</div></pre></td></tr></table></figure>
<h3 id="公平调度"><a href="#公平调度" class="headerlink" title="公平调度"></a>公平调度</h3><p><code>prefetch_count = 1</code></p>
<p>虽然每个工作者是依次分配到任务，但是每个任务不一定一样。可能有的任务比较重，执行时间比较久；有的任务比较轻，执行时间比较短。如果能公平调度就最好了，使用basic_qos设置prefetch_count=1，使得rabbitmq不会在同一时间给工作者分配多个任务，即只有工作者完成任务之后，才会再次接收到任务。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">channel.basic_qos(prefetch_count=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<ul>
<li>new_task.py完整代码</li>
</ul>
<blockquote>
<p>发送者/生产者</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    host=<span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line">channel.queue_declare(queue=<span class="string">'task_queue'</span>, durable=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">message = <span class="string">' '</span>.join(sys.argv[<span class="number">1</span>:]) <span class="keyword">or</span> <span class="string">"Hello World!"</span></div><div class="line">channel.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">                      routing_key=<span class="string">'task_queue'</span>,</div><div class="line">                      body=message,</div><div class="line">                      properties=pika.BasicProperties(</div><div class="line">                          delivery_mode=<span class="number">2</span>,  <span class="comment"># make message persistent</span></div><div class="line">                      ))</div><div class="line">print(<span class="string">" [x] Sent %r"</span> % (message,))</div><div class="line">connection.close()</div></pre></td></tr></table></figure>
<ul>
<li>worker.py完整代码</li>
</ul>
<blockquote>
<p>接受者/消费者</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line">channel.queue_declare(queue=<span class="string">'task_queue'</span>, durable=<span class="keyword">True</span>)</div><div class="line">print(<span class="string">' [*] Waiting for messages. To exit press CTRL+C'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">" [x] Received %r"</span> % (body,))</div><div class="line">    time.sleep(<span class="number">6</span>)</div><div class="line">    print(<span class="string">" [x] Done"</span>,ch.basic_ack(delivery_tag=method.delivery_tag))</div><div class="line"></div><div class="line"></div><div class="line">channel.basic_qos(prefetch_count=<span class="number">1</span>)</div><div class="line">channel.basic_consume(callback,</div><div class="line">                      queue=<span class="string">'task_queue'</span>)</div><div class="line"></div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure>
<h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>广播交换机的工作原理：消息发送端先将消息发送给交换机，交换机再将消息发送到绑定的消息队列，而后每个接收端都能从各自的消息队列里接收到信息。</p>
<p><img src="http://onk83djzp.bkt.clouddn.com/15022009754020.png" alt=""></p>
<h3 id="消费者-接收端receive-py代码分析"><a href="#消费者-接收端receive-py代码分析" class="headerlink" title="消费者/接收端receive.py代码分析"></a>消费者/接收端receive.py代码分析</h3><p>和最早的receive.py相比，主要是做了两个改动：</p>
<ul>
<li>定义交换机</li>
<li>不使用hello队列了，随机生成一个临时队列，并绑定到交换机上</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    <span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 定义交换机</span></div><div class="line">channel.exchange_declare(exchange=<span class="string">'messages'</span>, type=<span class="string">'fanout'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 随机生成队列，并绑定到交换机上</span></div><div class="line"><span class="comment"># 参数'exclusive=True'表示当接收端退出时，销毁临时产生的队列，这样就不会占用资源。</span></div><div class="line">result = channel.queue_declare(exclusive=<span class="keyword">True</span>)</div><div class="line">queue_name = result.method.queue</div><div class="line">channel.queue_bind(exchange=<span class="string">'messages'</span>, queue=queue_name)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">" [x] Received %r"</span> % (body,))</div><div class="line"></div><div class="line"></div><div class="line">channel.basic_consume(callback, queue=queue_name, no_ack=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">print(<span class="string">' [*] Waiting for messages. To exit press CTRL+C'</span>)</div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure>
<p>执行<code>rabbitmqctl list_queues</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">task_queue	0</div><div class="line">hello	5</div><div class="line"><span class="comment"># 定义了交换机</span></div><div class="line">amq.gen-K0M17k_3LVYO0b7m0s-K1g	0</div></pre></td></tr></table></figure>
<p><img src="http://onk83djzp.bkt.clouddn.com/15022012187733.jpg" alt=""></p>
<h3 id="生产者-发送端send-py代码分析"><a href="#生产者-发送端send-py代码分析" class="headerlink" title="生产者/发送端send.py代码分析"></a>生产者/发送端send.py代码分析</h3><p>和最早的send.py相比，也只做了两个改动：</p>
<ul>
<li>定义交换机</li>
<li>不是将消息发送到hello队列，而是发送到交换机</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    <span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 定义交换机</span></div><div class="line"><span class="comment"># type='fanout' 表示广播的意思</span></div><div class="line">channel.exchange_declare(exchange=<span class="string">'messages'</span>, type=<span class="string">'fanout'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 将消息发送到交换机</span></div><div class="line"><span class="comment"># basic_publish方法的参数exchange被设定为相应交换机，</span></div><div class="line"><span class="comment"># 因为是要广播出去，发送到所有队列，所以routing_key就不需要设定了。</span></div><div class="line">channel.basic_publish(exchange=<span class="string">'messages'</span>, routing_key=<span class="string">''</span>, body=<span class="string">'Hello World!'</span>)</div><div class="line">print(<span class="string">" [x] Sent 'Hello World!'"</span>)</div><div class="line">connection.close()</div></pre></td></tr></table></figure>
<p>exchange如果为空，表示是使用匿名的交换机，在上面交换机信息的图片中可以看到有amq.*这样的交换机，就是系统默认的交换机了。routing_key在使用匿名交换机的时候才需要指定，表示发送到哪个队列的意思。第一篇的例子演示了这个功能。</p>
<p>打开另外一个终端，执行send.py，可以观察到receive.py接收到了消息。如果有多个终端执行receive.py，那么每个receive.py都会接收到消息。</p>
<h2 id="组播-路由"><a href="#组播-路由" class="headerlink" title="组播/路由"></a>组播/路由</h2><h3 id="生产者-send-py代码分析"><a href="#生产者-send-py代码分析" class="headerlink" title="生产者/send.py代码分析"></a>生产者/send.py代码分析</h3><p>和广播相比，改动点主要在两个方面：</p>
<ul>
<li>设定交换机的类型（type）为direct。上一篇是设置为fanout，表示广播的意思，会将消息发送到所有接收端，这里设置为direct表示要根据设定的路由键来发送消息。</li>
<li>发送信息时设置发送的路由键。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    <span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 定义交换机，设置类型为direct</span></div><div class="line">channel.exchange_declare(exchange=<span class="string">'messages'</span>, type=<span class="string">'direct'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 定义三个路由键</span></div><div class="line">routings = [<span class="string">'warning'</span>, <span class="string">'error'</span>]</div><div class="line"></div><div class="line"><span class="comment"># 将消息依次发送到交换机，并设置路由键</span></div><div class="line"><span class="keyword">for</span> routing <span class="keyword">in</span> routings:</div><div class="line">    message = <span class="string">'%s message.'</span> % routing</div><div class="line">    channel.basic_publish(exchange=<span class="string">'messages'</span>,</div><div class="line">                          routing_key=routing,</div><div class="line">                          body=message)</div><div class="line">    print(message)</div><div class="line"></div><div class="line">connection.close()</div></pre></td></tr></table></figure>
<h3 id="消费者-receive-py代码分析"><a href="#消费者-receive-py代码分析" class="headerlink" title="消费者/receive.py代码分析"></a>消费者/receive.py代码分析</h3><p>和广播相比，改动点主要在三个方面：</p>
<ul>
<li>设定交换机的类型（type）为direct。</li>
<li>增加命令行获取参数功能，参数即为路由键。</li>
<li>将队列绑定到交换机上时，设定路由键。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika, sys</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    <span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 定义交换机，设置类型为direct</span></div><div class="line">channel.exchange_declare(exchange=<span class="string">'messages'</span>, type=<span class="string">'direct'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 从命令行获取路由键参数，如果没有，则设置为info</span></div><div class="line">routings = sys.argv[<span class="number">1</span>:]</div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> routings:</div><div class="line">    routings = [<span class="string">'info'</span>]</div><div class="line"></div><div class="line"><span class="comment"># 生成临时队列，并绑定到交换机上，设置路由键</span></div><div class="line">result = channel.queue_declare(exclusive=<span class="keyword">True</span>)</div><div class="line">queue_name = result.method.queue</div><div class="line"><span class="keyword">for</span> routing <span class="keyword">in</span> routings:</div><div class="line">    channel.queue_bind(exchange=<span class="string">'messages'</span>,</div><div class="line">                       queue=queue_name,</div><div class="line">                       routing_key=routing)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">" [x] Received %r"</span> % (body,))</div><div class="line"></div><div class="line"></div><div class="line">channel.basic_consume(callback, queue=queue_name, no_ack=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">print(<span class="string">' [*] Waiting for messages. To exit press CTRL+C'</span>)</div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure>
<p>打开两个终端，一个运行代码python receive.py info warning，表示只接收info和warning的消息。另外一个终端运行send.py，可以观察到接收终端只接收到了info和warning的消息。如果打开多个终端运行receive.py，并传入不同的路由键参数，可以看到更明显的效果。</p>
<p>当接收端正在运行时，可以使用rabbitmqctl list_bindings来查看绑定情况。</p>
<h2 id="按规则发送-正则"><a href="#按规则发送-正则" class="headerlink" title="按规则发送/正则"></a>按规则发送/正则</h2><p>上面路由键/组播的功能，通过设置路由键，可以将消息发送到相应的队列，这里的路由键是要完全匹配，比如info消息的只能发到路由键为info的消息队列。</p>
<p>路由键模糊匹配，就是可以使用正则表达式，和常用的正则表示式不同，这里的话“#”表示所有、全部的意思；“*”只匹配到一个词。看完示例就能明白了。</p>
<h3 id="send-py代码分析"><a href="#send-py代码分析" class="headerlink" title="send.py代码分析"></a>send.py代码分析</h3><p>因为要进行路由键模糊匹配，所以交换机的类型要设置为topic，设置为topic，就可以使用#，*的匹配符号了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    <span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 定义交换机，设置类型为topic</span></div><div class="line">channel.exchange_declare(exchange=<span class="string">'messages'</span>, type=<span class="string">'topic'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 定义路由键</span></div><div class="line"><span class="comment"># 四种类型的消息</span></div><div class="line">routings = [<span class="string">'happy.work'</span>, <span class="string">'happy.life'</span>, <span class="string">'sad.work'</span>, <span class="string">'sad.life'</span>]</div><div class="line"></div><div class="line"><span class="comment"># 将消息依次发送到交换机，并设定路由键</span></div><div class="line"><span class="keyword">for</span> routing <span class="keyword">in</span> routings:</div><div class="line">    message = <span class="string">'%s message.'</span> % routing</div><div class="line">    channel.basic_publish(exchange=<span class="string">'messages'</span>,</div><div class="line">                          routing_key=routing,</div><div class="line">                          body=message)</div><div class="line">    print(message)</div><div class="line"></div><div class="line">connection.close()</div></pre></td></tr></table></figure>
<h3 id="receive-py代码分析"><a href="#receive-py代码分析" class="headerlink" title="receive.py代码分析"></a>receive.py代码分析</h3><p>类型要设定为topic就可以了。从命令行接收参数的功能稍微调整了一下，没有参数时报错退出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika, sys</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    <span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 定义交换机，设置类型为topic</span></div><div class="line">channel.exchange_declare(exchange=<span class="string">'messages'</span>, type=<span class="string">'topic'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 从命令行获取路由参数，如果没有，则报错退出</span></div><div class="line">routings = sys.argv[<span class="number">1</span>:]</div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> routings:</div><div class="line">    <span class="comment"># print(&gt;&gt; sys.stderr, "Usage: %s [routing_key]..." % (sys.argv[0],))</span></div><div class="line">    print(sys.stderr, <span class="string">"Usage: %s [routing_key]..."</span> % (sys.argv[<span class="number">0</span>],))</div><div class="line">    exit()</div><div class="line"></div><div class="line"><span class="comment"># 生成临时队列，并绑定到交换机上，设置路由键</span></div><div class="line">result = channel.queue_declare(exclusive=<span class="keyword">True</span>)</div><div class="line">queue_name = result.method.queue</div><div class="line"><span class="keyword">for</span> routing <span class="keyword">in</span> routings:</div><div class="line">    channel.queue_bind(exchange=<span class="string">'messages'</span>,</div><div class="line">                       queue=queue_name,</div><div class="line">                       routing_key=routing)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">" [x] Received %r"</span> % (body,))</div><div class="line"></div><div class="line"></div><div class="line">channel.basic_consume(callback, queue=queue_name, no_ack=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">print(<span class="string">' [*] Waiting for messages. To exit press CTRL+C'</span>)</div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure>
<h3 id="实验运行"><a href="#实验运行" class="headerlink" title="实验运行"></a>实验运行</h3><p>打开多个终端,分别传入不同的规则,观察结果<br>如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">python3 receive_topic.py <span class="string">"#"</span></div><div class="line">python3 receive_topic.py <span class="string">"happy.*"</span></div><div class="line">python3 receive_topic.py <span class="string">"*.work"</span></div></pre></td></tr></table></figure>
<h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p>1、发送信息时，如果不设置路由键，那么路由键设置为”*”的接收端是否能接收到消息？</p>
<blockquote>
<p>发送信息时，如果不设置路由键，默认是表示广播出去，理论上所有接收端都可以收到消息，但是笔者试了下，路由键设置为”*”的接收端收不到任何消息。</p>
<p>只有发送消息时，设置路由键为一个词，路由键设置为”*”的接收端才能收到消息。在这里，每个词使用”.”符号分开的。</p>
</blockquote>
<p>2、发送消息时，如果路由键设置为”..”，那么路由键设置为”#.*”的接收端是否能接收到消息？如果发送消息时，路由键设置为一个词呢？</p>
<blockquote>
<p>两种情况，笔者都测试过了，可以的。</p>
</blockquote>
<p>3、”a.*.#” 和”a.#”的区别</p>
<blockquote>
<ul>
<li><p>“a.#”只要字符串开头的一个词是a就可以了，比如a、a.haha、a.haha.haha。而这样的词是不行的，如abs、abc、abc.haha。</p>
</li>
<li><p>“a.<em>.#”必须要满足a.</em>的字符串才可以，比如a.、a.haha、a.haha.haha。而这样的词是不行的，如a。</p>
</li>
</ul>
</blockquote>
<h2 id="远程结果返回RPC"><a href="#远程结果返回RPC" class="headerlink" title="远程结果返回RPC"></a>远程结果返回RPC</h2><p>Remote Producre Call<br>处理方法描述：</p>
<blockquote>
<p>发送端在发送信息前，产生一个接收消息的临时队列，该队列用来接收返回的结果。其实在这里接收端、发送端的概念已经比较模糊了，因为发送端也同样要接收消息，接收端同样也要发送消息，所以这里笔者使用另外的示例来演示这一过程。</p>
</blockquote>
<h3 id="compute-py代码分析"><a href="#compute-py代码分析" class="headerlink" title="compute.py代码分析"></a>compute.py代码分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line"><span class="comment"># 连接rabbitmq服务器</span></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    host=<span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 定义队列</span></div><div class="line">channel.queue_declare(queue=<span class="string">'compute_queue'</span>)</div><div class="line">print(<span class="string">' [*] Waiting for n'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 将n值加1</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">increase</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">return</span> n + <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 定义接收到消息的处理方法</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">" [.] increase(%s)"</span> % (body,))</div><div class="line"></div><div class="line">    response = increase(int(body))</div><div class="line"></div><div class="line">    <span class="comment"># 将计算结果发送回控制中心</span></div><div class="line">    ch.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">                     routing_key=properties.reply_to,</div><div class="line">                     body=str(response))</div><div class="line">    ch.basic_ack(delivery_tag=method.delivery_tag)</div><div class="line"></div><div class="line"></div><div class="line">channel.basic_qos(prefetch_count=<span class="number">1</span>)</div><div class="line">channel.basic_consume(request, queue=<span class="string">'compute_queue'</span>)</div><div class="line"></div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure>
<h3 id="center-py代码分析"><a href="#center-py代码分析" class="headerlink" title="center.py代码分析"></a>center.py代码分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Center</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">            host=<span class="string">'10.211.55.10'</span>))</div><div class="line"></div><div class="line">        self.channel = self.connection.channel()</div><div class="line"></div><div class="line">        <span class="comment"># 定义接收返回消息的队列</span></div><div class="line">        result = self.channel.queue_declare(exclusive=<span class="keyword">True</span>)</div><div class="line">        self.callback_queue = result.method.queue</div><div class="line"></div><div class="line">        self.channel.basic_consume(self.on_response,</div><div class="line">                                   no_ack=<span class="keyword">True</span>,</div><div class="line">                                   queue=self.callback_queue)</div><div class="line"></div><div class="line">    <span class="comment"># 定义接收到返回消息的处理方法</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_response</span><span class="params">(self, ch, method, props, body)</span>:</span></div><div class="line">        self.response = body</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(self, n)</span>:</span></div><div class="line">        self.response = <span class="keyword">None</span></div><div class="line">        <span class="comment"># 发送计算请求，并声明返回队列</span></div><div class="line">        self.channel.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">                                   routing_key=<span class="string">'compute_queue'</span>,</div><div class="line">                                   properties=pika.BasicProperties(</div><div class="line">                                       reply_to=self.callback_queue,</div><div class="line">                                   ),</div><div class="line">                                   body=str(n))</div><div class="line">        <span class="comment"># 接收返回的数据</span></div><div class="line">        <span class="keyword">while</span> self.response <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            self.connection.process_data_events()</div><div class="line">        <span class="keyword">return</span> int(self.response)</div><div class="line"></div><div class="line"></div><div class="line">center = Center()</div><div class="line"></div><div class="line">print(<span class="string">" [x] Requesting increase(30)"</span>)</div><div class="line">response = center.request(<span class="number">30</span>)</div><div class="line">print(<span class="string">" [.] Got %r"</span> % (response,))</div></pre></td></tr></table></figure>
<p>上面代码定义了接收返回数据的队列和处理方法，并且在发送请求的时候将该队列赋值给<code>reply_to</code>，在计算节点代码中就是通过这个参数来获取返回队列的。</p>
<h2 id="相互关联编号correlation-id"><a href="#相互关联编号correlation-id" class="headerlink" title="相互关联编号correlation id"></a>相互关联编号correlation id</h2><p><code>correlation id</code>运行原理：</p>
<blockquote>
<p>控制中心发送计算请求时设置correlation id，而后计算节点将计算结果，连同接收到的correlation id一起返回，这样控制中心就能通过correlation id来标识请求。其实correlation id也可以理解为请求的唯一标识码。</p>
</blockquote>
<p>示例内容：</p>
<blockquote>
<p>控制中心开启多个线程，每个线程都发起一次计算请求，通过correlation id，每个线程都能准确收到相应的计算结果。</p>
</blockquote>
<h3 id="compute-py代码分析-1"><a href="#compute-py代码分析-1" class="headerlink" title="compute.py代码分析"></a>compute.py代码分析</h3><p>和上面相比，只需修改一个地方：</p>
<blockquote>
<p>将计算结果发送回控制中心时，增加参数correlation_id的设定，该参数的值其实是从控制中心发送过来的，这里只是再次发送回去。代码如下：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line"><span class="comment"># 连接rabbitmq服务器</span></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    host=<span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 定义队列</span></div><div class="line">channel.queue_declare(queue=<span class="string">'compute_queue'</span>)</div><div class="line">print(<span class="string">' [*] Waiting for n'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 将n值加1</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">increase</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">return</span> n + <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 定义接收到消息的处理方法</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(ch, method, props, body)</span>:</span></div><div class="line">    print(<span class="string">" [.] increase(%s)"</span> % (body,))</div><div class="line"></div><div class="line">    response = increase(int(body))</div><div class="line"></div><div class="line">    <span class="comment"># 将计算结果发送回控制中心，增加correlation_id的设定</span></div><div class="line">    ch.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">                     routing_key=props.reply_to,</div><div class="line">                     properties=pika.BasicProperties(correlation_id= \</div><div class="line">                                                         props.correlation_id),</div><div class="line">                     body=str(response))</div><div class="line">    ch.basic_ack(delivery_tag=method.delivery_tag)</div><div class="line"></div><div class="line"></div><div class="line">channel.basic_qos(prefetch_count=<span class="number">1</span>)</div><div class="line">channel.basic_consume(request, queue=<span class="string">'compute_queue'</span>)</div><div class="line"></div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure>
<h3 id="center-py代码分析-1"><a href="#center-py代码分析-1" class="headerlink" title="center.py代码分析"></a>center.py代码分析</h3><p>控制中心代码稍微复杂些，其中比较关键的有三个地方：</p>
<ul>
<li>使用python的uuid来产生唯一的correlation_id。</li>
<li>发送计算请求时，设定参数correlation_id。</li>
<li>定义一个字典来保存返回的数据，并且键值为相应线程产生的correlation_id。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika, threading, uuid</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 自定义线程类，继承threading.Thread</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, num)</span>:</span></div><div class="line">        super(MyThread, self).__init__()</div><div class="line">        self.func = func</div><div class="line">        self.num = num</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">" [x] Requesting increase(%d)"</span> % self.num)</div><div class="line">        response = self.func(self.num)</div><div class="line">        print(<span class="string">" [.] increase(%d)=%d"</span> % (self.num, response))</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 控制中心类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Center</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">            host=<span class="string">'10.211.55.10'</span>))</div><div class="line"></div><div class="line">        self.channel = self.connection.channel()</div><div class="line"></div><div class="line">        <span class="comment"># 定义接收返回消息的队列</span></div><div class="line">        result = self.channel.queue_declare(exclusive=<span class="keyword">True</span>)</div><div class="line">        self.callback_queue = result.method.queue</div><div class="line"></div><div class="line">        self.channel.basic_consume(self.on_response,</div><div class="line">                                   no_ack=<span class="keyword">True</span>,</div><div class="line">                                   queue=self.callback_queue)</div><div class="line"></div><div class="line">        <span class="comment"># 返回的结果都会存储在该字典里</span></div><div class="line">        self.response = &#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment"># 定义接收到返回消息的处理方法</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_response</span><span class="params">(self, ch, method, props, body)</span>:</span></div><div class="line">        self.response[props.correlation_id] = body</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(self, n)</span>:</span></div><div class="line">        corr_id = str(uuid.uuid4())     <span class="comment">#  产生 id</span></div><div class="line">        self.response[corr_id] = <span class="keyword">None</span></div><div class="line"></div><div class="line">        <span class="comment"># 发送计算请求，并设定返回队列和correlation_id</span></div><div class="line">        self.channel.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">                                   routing_key=<span class="string">'compute_queue'</span>,</div><div class="line">                                   properties=pika.BasicProperties(</div><div class="line">                                       reply_to=self.callback_queue,</div><div class="line">                                       correlation_id=corr_id,</div><div class="line">                                   ),</div><div class="line">                                   body=str(n))</div><div class="line">        <span class="comment"># 接收返回的数据</span></div><div class="line">        <span class="keyword">while</span> self.response[corr_id] <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            self.connection.process_data_events()</div><div class="line">        <span class="keyword">return</span> int(self.response[corr_id])</div><div class="line"></div><div class="line"></div><div class="line">center = Center()</div><div class="line"><span class="comment"># 发起5次计算请求</span></div><div class="line">nums = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]</div><div class="line">threads = []</div><div class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</div><div class="line">    threads.append(MyThread(center.request, num))</div><div class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</div><div class="line">    thread.start()</div><div class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</div><div class="line">    thread.join()</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.csdn.net/chenjiebin/article/details/8253433" target="_blank" rel="external">http://blog.csdn.net/chenjiebin/article/details/8253433</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Rabbitmq </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[密码学基础]]></title>
      <url>/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>平常用的登录密码不叫密码，是登录口令</p>
<a id="more"></a>
<p>密码有一个加密和解密的过程</p>
<p><strong>video:</strong> <a href="https://youtu.be/loJ62rvH8aE" target="_blank" rel="external">https://youtu.be/loJ62rvH8aE</a></p>
<h2 id="古典密码"><a href="#古典密码" class="headerlink" title="古典密码"></a>古典密码</h2><h3 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ABC</div><div class="line">CDE</div><div class="line">// 往后移动3位或者多位</div></pre></td></tr></table></figure>
<p>非常容易破解</p>
<h3 id="维吉尼亚密码"><a href="#维吉尼亚密码" class="headerlink" title="维吉尼亚密码"></a>维吉尼亚密码</h3><blockquote>
<p>不知道密钥是非常非常难破解的</p>
</blockquote>
<p><img src="http://onk83djzp.bkt.clouddn.com/2017-12-14-15132363172963.jpg" alt=""></p>
<ul>
<li>RSA<ul>
<li>公钥</li>
<li>私钥 </li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">明文--&gt; 公钥 --&gt; 密文</div><div class="line">密文--&gt; 私钥 --&gt; 明文</div></pre></td></tr></table></figure>
<p>基于<code>大数难分解</code><br>两个质数相乘</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">p1 = <span class="number">53</span></div><div class="line">p2 = <span class="number">59</span></div><div class="line">n = <span class="number">3127</span>  <span class="comment"># 53 * 59 = 3127</span></div><div class="line"><span class="comment"># 欧拉函数</span></div><div class="line">Φ(n)(p1<span class="number">-1</span>)*(p2<span class="number">-1</span>)= <span class="number">3016</span> <span class="comment"># fai 小写 φ</span></div><div class="line">e = <span class="number">3</span>   <span class="comment"># e 和欧拉函数互质 只要互质随便取</span></div><div class="line"><span class="comment"># 公钥是 n，e</span></div><div class="line">d = (k*φ(n)+<span class="number">1</span>)/e = <span class="number">2011</span> <span class="comment"># 私钥 (2**3016+1)/3 = 2011</span></div><div class="line"></div><div class="line"><span class="comment"># 验证</span></div><div class="line">m = <span class="number">89</span> <span class="comment"># 加密信息 </span></div><div class="line">c = (m**e)%n = <span class="number">1394</span>   <span class="comment"># 密文 (89**3)%3127 = 1394</span></div><div class="line">明文 = (x**d)%n = <span class="number">89</span> <span class="comment"># 明文 (1394**2011)%3127 = 89</span></div></pre></td></tr></table></figure>
<p>扩展:</p>
<p><strong>费马小定理</strong>来验证.</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Charles: Response 出现乱码]]></title>
      <url>/Charles-Response-%E4%B9%B1%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>使用 Charles 抓 https 包的时候, Reponse 出现乱码<br><a id="more"></a></p>
<p>系统环境: MAC<br>软件版本: 4.2.1<br>浏览器: Google Chrome</p>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>没有信任 Charles 的证书,信任 Charles 的证书就好了</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><h2 id="安装-Charles-证书"><a href="#安装-Charles-证书" class="headerlink" title="安装 Charles 证书"></a>安装 Charles 证书</h2><p><code>Help</code> &gt; <code>SSL Proxying</code> &gt; <code>Install Charles Root Certificate</code></p>
<p><img src="http://onk83djzp.bkt.clouddn.com/2017-12-18-15136035793600.jpg" alt="安装 Charles 证书"></p>
<h2 id="信任-Charles-证书"><a href="#信任-Charles-证书" class="headerlink" title="信任 Charles 证书"></a>信任 Charles 证书</h2><p>安装完成后会自动弹出钥匙串,找到 Charles 的证书信任即可</p>
<p><img src="http://onk83djzp.bkt.clouddn.com/2017-12-18-15136036377739.jpg" alt="信任 Charles 证书1"></p>
<p><img src="http://onk83djzp.bkt.clouddn.com/2017-12-18-15136049282237.jpg" alt="信任 Charles 证书2"></p>
<h2 id="Charles-设置"><a href="#Charles-设置" class="headerlink" title="Charles 设置"></a>Charles 设置</h2><p><code>Proxy</code> &gt; <code>SSL Proxying Settings</code></p>
<p><img src="http://onk83djzp.bkt.clouddn.com/2017-12-18-15136042401360.jpg" alt="Charles 设置"></p>
<h2 id="ok"><a href="#ok" class="headerlink" title="ok"></a>ok</h2><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>发布这篇文章的时候问题已经被解决,但是没有问题截图,有时间的话再补上.</p>
]]></content>
      
        
        <tags>
            
            <tag> Charles </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
