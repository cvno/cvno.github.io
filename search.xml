<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[数据结构基础]]></title>
      <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>数据结构是设计数据以何种方式组织并存储在计算机中。</p>
<p>比如：<code>列表</code>、<code>集合</code>与<code>字典</code>等都是一种数据结构。</p>
<p>详细的说：</p>
<ul>
<li>物理层面：就是以什么样的物理存储方式</li>
<li>逻辑方式：列表，字典，集合，树</li>
</ul>
<p><strong>线性数据结构，树形数据结构，图形数据结构，</strong> 基本是线性数据结构</p>
<p>N.Wirth: “程序=数据结构+算法”</p>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>列表：在其他编程语言中称为“数组”，是一种基本的数据结构类型。如果更学术一点的说法是“线性表”。</p>
<p><strong>数组与列表的不同之处：</strong><br>数组是定长的数组，如果开的内存空间长度为7，就不能再追加，只能存7个，并且这7个元素类型还必须是一样的</p>
<p><strong>数组：定长，元素类型统一。</strong></p>
<p>Python中的给一个列表，开一块连续内存空间，开的内存空间的长度不会刚好是列表的长度，一定会多，而内存中：变量指向的列表的元素存的是一个个内存地址（地址的格子才是真正存元素值的地方），每个元素占用的空间都是一样的，大部分编译型的语言直接存的值，而python存的不是值，而是值的内存地址。</p>
<p>Python中一直<code>append</code>值的原理：如果之前的空间不够，就再开时原来一倍的内存空间，然后把旧的删掉</p>
<blockquote>
<p>列表<code>li[2]</code>寻址的时候是<code>li+2*内存地址的字节</code></p>
</blockquote>
<p>32位机器一个地址4个子节<br>64位机器一个地址8个字节</p>
<p><strong>关于列表的问题：</strong></p>
<ul>
<li>列表中元素使如何存储的？(上述)</li>
<li>列表提供了哪些基本的操作？(下标查找，插入，删除)</li>
<li>这些操作的时间复杂度是多少？<ul>
<li>O(1)</li>
<li>O(n)(插入的时候，插入位置之后的值都需要往后挪)</li>
</ul>
</li>
</ul>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表中每一个元素都是一个对象，每个对象称为一个节点，包含有数据域key和指向下一个节点的指针next。通过各个节点之间的相互连接，最终串联成一个链表。</p>
<p>为什么用链表？<br>链表的插入和删除特别快</p>
<p><strong>节点定义:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,item)</span>:</span></div><div class="line">        self.item = item</div><div class="line">        self.next = <span class="keyword">None</span></div><div class="line"></div><div class="line">n1 = Node(<span class="number">1</span>)</div><div class="line">n2 = Node(<span class="number">2</span>)</div><div class="line">n3 = Node(<span class="number">3</span>)</div><div class="line"></div><div class="line">n1.next = n2</div><div class="line">n2.next = n3</div><div class="line"></div><div class="line">print(n1.next.item) <span class="comment"># 2</span></div><div class="line">print(n1.next.next.item) <span class="comment"># 3</span></div></pre></td></tr></table></figure>
<ul>
<li>头节点</li>
</ul>
<p><img src="https://i.imgur.com/P1WJgQ8.jpg" alt="单向链表"></p>
<h2 id="链表的遍历"><a href="#链表的遍历" class="headerlink" title="链表的遍历"></a>链表的遍历</h2><p><img src="https://i.imgur.com/xvc5L8B.jpg" alt="链表遍历"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">traversal</span><span class="params">(head)</span>:</span></div><div class="line">    curNode = head  <span class="comment"># 临时用指针</span></div><div class="line">    <span class="keyword">while</span> curNode <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">        print(curNode.data)</div><div class="line">        curNode = curNode.next</div></pre></td></tr></table></figure>
<h2 id="链表节点的插入和删除"><a href="#链表节点的插入和删除" class="headerlink" title="链表节点的插入和删除"></a>链表节点的插入和删除</h2><p>O1的时间复杂度</p>
<ul>
<li>插入</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p.next = curNode.next</div><div class="line">curNode.next = p</div></pre></td></tr></table></figure>
<ul>
<li>删除</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">p = curNode.next</div><div class="line">curNode.next = curNode.next.next</div><div class="line"><span class="comment"># 也可以 &gt;&gt; curNode.next = p.next</span></div><div class="line"><span class="keyword">del</span> p</div></pre></td></tr></table></figure>
<h2 id="建立链表"><a href="#建立链表" class="headerlink" title="建立链表"></a>建立链表</h2><ul>
<li>头插法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">createLinkList</span><span class="params">(li)</span>:</span></div><div class="line">    l = Node()</div><div class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> li:</div><div class="line">        s = Node(Num)</div><div class="line">        s.next = l.next</div><div class="line">        l.next = s</div><div class="line">    <span class="keyword">return</span> l</div></pre></td></tr></table></figure>
<ul>
<li>尾插法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">createLinkList</span><span class="params">(li)</span>:</span></div><div class="line">    l = Node()</div><div class="line">    r = l   <span class="comment"># r 指向尾节点</span></div><div class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> li :</div><div class="line">        s = Node(num)</div><div class="line">        r.next = s</div><div class="line">        r = s</div></pre></td></tr></table></figure>
<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p>双链表中每个节点有两个指针：一个指向后面节点、一个指向前面节点。</p>
<p><strong>节点定义：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,item = None)</span>:</span></div><div class="line">        self.item = item</div><div class="line">        self.next = <span class="keyword">None</span></div><div class="line">        self.prior = <span class="keyword">None</span></div></pre></td></tr></table></figure>
<h3 id="双链表节点的插入和删除"><a href="#双链表节点的插入和删除" class="headerlink" title="双链表节点的插入和删除"></a>双链表节点的插入和删除</h3><ul>
<li>插入</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">p.next = curNode.next</div><div class="line">curNode.next.prior = p</div><div class="line">p.prior = curNode</div><div class="line">curNode.next = p</div></pre></td></tr></table></figure>
<ul>
<li>删除</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">p = curNode.next</div><div class="line">curNode.next = p.next</div><div class="line">p.next.prior = curNode</div><div class="line"><span class="keyword">del</span> p</div></pre></td></tr></table></figure>
<h2 id="链表分析"><a href="#链表分析" class="headerlink" title="链表分析"></a>链表分析</h2><h3 id="列表与链表"><a href="#列表与链表" class="headerlink" title="列表与链表"></a>列表与链表</h3><ul>
<li>按元素值查找（链表二分是On的复杂度）</li>
<li>按下标查找（链表没有法用下表查找，李列表：O1，链表On）</li>
<li>在某元素后插入（列表：On，链表：O1）</li>
<li>删除某元素（列表：On，链表：O1）</li>
</ul>
<p>树也是以链表的形式存</p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈(Stack)是一个数据集合，可以理解为只能在一端进行插入或删除操作的列表。</p>
<p><strong>特点：</strong> 后进先出（last-in, first-out）LIFO</p>
<p><strong>概念：</strong></p>
<ul>
<li>栈顶</li>
<li>栈底</li>
</ul>
<p><strong>基本操作：</strong></p>
<ul>
<li>进栈（压栈）：push</li>
<li>出栈：pop</li>
<li>取栈顶：gettop</li>
</ul>
<p><strong>应用实例：</strong></p>
<ul>
<li>Word 的撤销操作（撤销的时候后边的操作）</li>
<li>重做</li>
</ul>
<blockquote>
<p>两个栈,撤销栈出栈，重做栈压栈；重做操作是记录撤销操作的。</p>
</blockquote>
<h2 id="栈的简单实现-Python"><a href="#栈的简单实现-Python" class="headerlink" title="栈的简单实现(Python)"></a>栈的简单实现(Python)</h2><p>不需要自己定义，使用列表结构即可。</p>
<ul>
<li>进栈函数：append</li>
<li>出栈函数：pop</li>
<li>查看栈顶函数：li[-1]</li>
</ul>
<h2 id="栈的应用-括号匹配问题"><a href="#栈的应用-括号匹配问题" class="headerlink" title="栈的应用 - 括号匹配问题"></a>栈的应用 - 括号匹配问题</h2><p>给一个字符串，其中包含小括号、中括号、大括号，求该字符串中的括号是否匹配。</p>
<ul>
<li><code>()()[]{}</code>        匹配</li>
<li><code>([{()}])</code>        匹配</li>
<li><code>[](</code>        不匹配</li>
<li><code>[(])</code>        不匹配</li>
</ul>
<p>代码补全，当栈是空的，栈才是合法的</p>
<ul>
<li><a href="https://github.com/cvno/Note/blob/master/1/code1.py" target="_blank" rel="external">代码实现括号匹配</a></li>
</ul>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列(Queue)是一个数据集合，仅允许在列表的一端进行插入，另一端进行删除。</p>
<ul>
<li>进行插入的一端称为队尾(rear)，插入动作称为进队或入队</li>
<li>进行删除的一端称为队头(front)，删除动作称为出队</li>
<li>队列的性质：先进先出(First-in, First-out)</li>
<li>双向队列：队列的两端都允许进行进队和出队操作。</li>
</ul>
<p><img src="https://i.imgur.com/cct8beO.jpg" alt="队列"></p>
<p><img src="https://i.imgur.com/ruUddhR.jpg" alt="队列模型"></p>
<h2 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h2><p><strong>用Python的列表来实现出队复杂度太高</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">使用方法：from collections import deque</div><div class="line">- 创建队列：queue = deque(li)</div><div class="line">- 进队：append</div><div class="line">- 出队：popleft</div><div class="line">- 双向队列队首进队：appendleft</div><div class="line">- 双向队列队尾进队：pop</div></pre></td></tr></table></figure>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><ul>
<li>初步设想：列表+两个下标指针</li>
<li>创建一个列表和两个变量，front变量指向队首，rear变量指向队尾。初始时，front和rear都为0。</li>
<li>进队操作：元素写到li[rear]的位置，rear自增1。</li>
<li>出队操作：返回li[front]的元素，front自减1。</li>
</ul>
<p><img src="https://i.imgur.com/VsKQCZb.jpg" alt="队列"></p>
<h2 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h2><p>环形队列：当队尾指针front == Maxsize + 1时，再前进一个位置就自动到0。<br><strong>实现方式：求余数运算</strong></p>
<ul>
<li>队首指针前进1：front = (front + 1) % MaxSize</li>
<li>队尾指针前进1：rear = (rear + 1) % MaxSize</li>
<li>队空条件：rear == front</li>
<li>队满条件：(rear + 1) % MaxSize == front</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul>
<li>通过Python自带库</li>
<li><a href="https://gist.github.com/cvno/eeb1073a4fc23e42885a6112671f0545" target="_blank" rel="external">手写循环队列</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> queue    <span class="comment"># 线程同步</span></div><div class="line"><span class="comment">########  分割  ########</span></div><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</div><div class="line">queue = deque()</div><div class="line">queue.append(<span class="number">1</span>)</div><div class="line">queue.append(<span class="number">2</span>)</div><div class="line">queue.append(<span class="number">3</span>)</div><div class="line">print( ())</div><div class="line">print(queue.popleft())</div><div class="line"><span class="comment">########  分割  ########</span></div><div class="line">queue.appendleft(<span class="number">2</span>)</div><div class="line">queue.pop()</div></pre></td></tr></table></figure>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="Python中的集合与字典"><a href="#Python中的集合与字典" class="headerlink" title="Python中的集合与字典"></a>Python中的集合与字典</h2><p>哈希表查找</p>
<blockquote>
<p>哈希表（Hash Table，又称为散列表），是一种线性表的存储结构。通过把每个对象的关键字k作为自变量，通过一个哈希函数h(k)，将k映射到下标h(k)处，并将该对象存储在这个位置。</p>
</blockquote>
<p><strong>例如：</strong>数据集合{1,6,7,9}，假设存在哈希函数h(x)使得h(1) = 0, h(6) = 2, h(7) = 4, h(9) = 5，那么这个哈希表被存储为[1,None, 6, None, 7, 9]。</p>
<p>当我们查找元素6所在的位置时，通过哈希函数h(x)获得该元素所在的下标（h(6) = 2），因此在2位置即可找到该元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">li = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</div><div class="line">s = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; <span class="comment"># 集合的效率更高</span></div><div class="line"><span class="comment"># 哈希函数设计的再好也避免不了碰撞</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#</span></div></pre></td></tr></table></figure>
<h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>哈希冲突：由于哈希表的下标范围是有限的，而元素关键字的值是接近无限的，因此可能会出现h(102) = 56， h(2003) = 56这种情况。此时，两个元素映射到同一个下标处，造成哈希冲突。</p>
<p><strong>解决哈希冲突</strong></p>
<ul>
<li>拉链法（将所有冲突的元素用链表连接）</li>
<li>开放寻址法（通过哈希冲突函数得到新的地址）</li>
</ul>
<p><img src="http://onk83djzp.bkt.clouddn.com/2017-12-13-15131769752694.jpg" alt="拉链法"></p>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p><strong>在Python中的字典：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = &#123;&apos;name&apos;: &apos;Alex&apos;, &apos;age&apos;: 18, &apos;gender&apos;: &apos;Man&apos;&#125;</div></pre></td></tr></table></figure>
<p>使用哈希表存储字典，通过哈希函数将字典的键映射为下标。假设h(‘name’) = 3, h(‘age’) = 1, h(‘gender’) = 4，则哈希表存储为[None, 18, None, ’Alex’, ‘Man’]</p>
<p>在字典键值对数量不多的情况下，几乎不会发生哈希冲突，此时查找一个元素的时间复杂度为O(1)。</p>
<h1 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h1><p>给一个二维列表，表示迷宫（0表示通道，1表示围墙）。给出算法，求一条走出迷宫的路径。</p>
<h2 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h2><ul>
<li><a href="https://github.com/cvno/Note/blob/master/1/maze.py" target="_blank" rel="external">栈-方案</a></li>
</ul>
<p>深度优先 <strong>DFS（Depth[栈]-First-Search）</strong></p>
<h2 id="队列-1"><a href="#队列-1" class="headerlink" title="队列"></a>队列</h2><ul>
<li><a href="https://github.com/cvno/Note/blob/master/1/code2.py" target="_blank" rel="external">队列-方案</a></li>
</ul>
<p>使用二维列表存储多条路径<br><strong>如何是打印出路径是难点</strong></p>
<p><img src="http://onk83djzp.bkt.clouddn.com/15114913815577.jpg" alt="迷宫"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">maze = [</div><div class="line">    [1,1,1,1,1,1,1,1,1,1],</div><div class="line">    [1,0,0,1,0,0,0,1,0,1],</div><div class="line">    [1,0,0,1,0,0,0,1,0,1],</div><div class="line">    [1,0,0,0,0,1,1,0,0,1],</div><div class="line">    [1,0,1,1,1,0,0,0,0,1],</div><div class="line">    [1,0,0,0,1,0,0,0,0,1],</div><div class="line">    [1,0,1,0,0,0,1,0,0,1],</div><div class="line">    [1,0,1,1,1,0,1,1,0,1],</div><div class="line">    [1,1,0,0,0,0,0,0,0,1],</div><div class="line">    [1,1,1,1,1,1,1,1,1,1]</div><div class="line">]</div></pre></td></tr></table></figure>
<p>本文代码及 md 文件 <a href="https://github.com/cvno/Note/tree/master/1" target="_blank" rel="external">Github</a></p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 迷宫 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TOP 榜单算法（nlargest）]]></title>
      <url>/TOP-%E6%A6%9C%E5%8D%95%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>现在有n个数（n&gt;10000），设计算法，按大小顺序得到前<del>10</del>m大的数。</p>
<a id="more"></a>
<ul>
<li>应用场景：榜单TOP 10</li>
</ul>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><ol>
<li>先排序，取前 10 个数 O(nlogn)</li>
<li>只留前 10 个数，开一个长度为 10 的列表，用插入排序取出 10 个数，来一个数和列表最后一个数比较，如果比它更小就扔掉 O(nm)不适用与 m 特别大的时候</li>
<li>堆 O(nlogm)</li>
</ol>
<p>用堆解决思路：</p>
<ol>
<li>取列表前m个元素建立一个小根堆。堆顶就是目前第m大的数。</li>
<li>依次向后遍历原列表，对于列表中的元素，如果小于堆顶，则忽略该元素；如果大于堆顶，则将堆顶更换为该元素，并且对堆进行一次调整；</li>
<li>遍历列表所有元素后，倒序弹出堆顶。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift</span><span class="params">(data, low, high)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    调整函数</div><div class="line">    data: 列表</div><div class="line">    low：待调整的子树的根位置</div><div class="line">    high：待调整的子树的最后一个节点的位置</div><div class="line">    """</div><div class="line">    i = low</div><div class="line">    j = <span class="number">2</span> * i + <span class="number">1</span></div><div class="line">    tmp = data[i]</div><div class="line">    <span class="comment"># i指向空位置</span></div><div class="line">    <span class="keyword">while</span> j&lt;=high:      <span class="comment">#领导已经撸到底了</span></div><div class="line">        <span class="keyword">if</span> j != high <span class="keyword">and</span> data[j] &lt; data[j+<span class="number">1</span>]:</div><div class="line">            j += <span class="number">1</span></div><div class="line">        <span class="comment">#j指向数值大的孩子</span></div><div class="line">        <span class="keyword">if</span> tmp &lt; data[j]:   <span class="comment">#如果小领导比撸下来的大领导能力值大</span></div><div class="line">            data[i] = data[j]</div><div class="line">            i = j</div><div class="line">            j = <span class="number">2</span>*i+<span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">break</span>       <span class="comment">#撸下来的领导比候选的领导能力值大</span></div><div class="line">    data[i] = tmp</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">topn</span><span class="params">(li, n)</span>:</span></div><div class="line">    heap = li[<span class="number">0</span>:n]</div><div class="line">    <span class="comment"># 建堆</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n // <span class="number">2</span> - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">        sift(heap, i, n - <span class="number">1</span>)</div><div class="line">        <span class="comment"># 遍历</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n, len(li)):</div><div class="line">        <span class="keyword">if</span> li[i] &gt; heap[<span class="number">0</span>]:</div><div class="line">            heap[<span class="number">0</span>] = li[i]</div><div class="line">            sift(heap, <span class="number">0</span>, n - <span class="number">1</span>)</div><div class="line">    <span class="comment"># 出数</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">        heap[<span class="number">0</span>], heap[i] = heap[i], heap[<span class="number">0</span>]</div><div class="line">        sift(heap, <span class="number">0</span>, i - <span class="number">1</span>)</div></pre></td></tr></table></figure>
<ul>
<li>Python内置模块——heapq</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> heapq</div><div class="line"><span class="comment"># 利用heapq模块实现堆排序</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapsort</span><span class="params">(li)</span>:</span></div><div class="line">    h = []</div><div class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> li:</div><div class="line">        heapq.heappush(h, value)<span class="comment"># 建堆, 并自动排序</span></div><div class="line">    <span class="keyword">return</span> [heappop(h) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(h))]</div><div class="line"></div><div class="line">heapsort([<span class="number">6</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>]) <span class="comment"># [0,2,1,3,5,6,7,9,4,8]</span></div><div class="line"></div><div class="line"><span class="comment"># ============== 分割线 ==============</span></div><div class="line"><span class="comment"># 利用heapq模块实现取top-k</span></div><div class="line">heapq.nlargest(<span class="number">100</span>, li)</div></pre></td></tr></table></figure>
<p>优先队列：一些元素的集合，POP操作每次执行都会从优先队列中弹出最大（或最小）的元素。</p>
<blockquote>
<p>堆——优先队列</p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://python.usyiyi.cn/translate/python_352/library/heapq.html" target="_blank" rel="external">http://python.usyiyi.cn/translate/python_352/library/heapq.html</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 位运算</span></div><div class="line"><span class="comment"># &gt;&gt; 除以2</span></div><div class="line"><span class="number">2</span> &gt;&gt; <span class="number">1</span> <span class="comment"># 1 </span></div><div class="line"><span class="number">4</span> &gt;&gt; <span class="number">1</span> <span class="comment"># 2</span></div><div class="line"><span class="number">8</span> &gt;&gt; <span class="number">1</span> <span class="comment"># 4</span></div><div class="line"><span class="comment"># &lt;&lt; 乘以 2</span></div><div class="line"><span class="number">2</span> &lt;&lt; <span class="number">1</span>  <span class="comment"># 4</span></div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> heapq </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据结构：树]]></title>
      <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91/</url>
      <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p><img src="https://i.imgur.com/JH2f8TO.jpg" alt="树（数据结构）"></p>
<ul>
<li>是一种数据结构（如：目录结构） </li>
<li>是一种可以递归定义的数据结构</li>
<li>是由 n 个节点组成的集合<ul>
<li>如果 n=0 ，那么是一颗空树</li>
<li>如果 n&gt;0 ，那么存在 1 个节点作为树的根节点，其他节点可以分为 m 个集合，每个集合本身又是一棵树。</li>
</ul>
</li>
</ul>
<p><strong>概念：</strong></p>
<ul>
<li>根节点（最顶端的节点）、叶子节点（没有孩子的节点，结构的最末端）</li>
<li>树的深度／高度（也就是树的层数）</li>
<li>节点度（也就是这个节点分了多少叉）</li>
<li>树的度（所有节点度的最大值）</li>
<li>孩子节点/父节点（看字面理解）</li>
<li>子树（根节点的字节点都是独立的树）</li>
</ul>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>度不超过 2 的树（节点最多有两个叉），它的孩子是有顺序的：左孩子，右孩子。<br><img src="https://i.imgur.com/Fq7IcbA.jpg" alt="二叉树的多种形态"></p>
<p>重点：满二叉树，完全二叉树</p>
<h2 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h2><ol>
<li>链式存储方式</li>
<li>顺序存储方式（列表）</li>
</ol>
<p><img src="https://i.imgur.com/X5OMYC1.jpg" alt=""></p>
<p>父节点和左孩子节点的编号下标有什么关系？</p>
<blockquote>
<p>0-1 1-3 2-5 3-7 4-9<br>规律：i = 2i+1</p>
</blockquote>
<p>父节点和右孩子节点的编号下标有什么关系？</p>
<blockquote>
<p>0-2 1-4 2-6 3-8 4-10<br>规律：i = 2i+2</p>
</blockquote>
<p>比如，我们要找根节点左孩子的左孩子：</p>
<h2 id="二叉树小结"><a href="#二叉树小结" class="headerlink" title="二叉树小结"></a>二叉树小结</h2><ul>
<li>二叉树是度不超过 2 的树</li>
<li>满二叉树与完全二叉树</li>
<li>（完全）二叉树可以用列表来存储，通过规律可以从父亲找到孩子或者孩子找到父亲</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[递归]]></title>
      <url>/%E9%80%92%E5%BD%92/</url>
      <content type="html"><![CDATA[<p>在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。</p>
<p><strong>特点：</strong></p>
<ul>
<li>调用自身</li>
<li>结束条件</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(x)</span>:</span></div><div class="line">    print(x)</div><div class="line">    func1(x<span class="number">-1</span>)</div><div class="line"></div><div class="line"><span class="comment"># func1(3)  # 死递归 没有结束条件</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span>:</div><div class="line">        print(x)</div><div class="line">        func2(x+<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="comment"># func2(3)    # 3,4,5,6...  有结束条件，如果是正数还是会陷入死递归</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func3</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span>:</div><div class="line">        print(x)</div><div class="line">        func3(x<span class="number">-1</span>)</div><div class="line"></div><div class="line"><span class="comment"># func3(3)  # 3,2,1   有结束条件</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func4</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span>:</div><div class="line">        func4(x<span class="number">-1</span>)</div><div class="line">        print(x)</div><div class="line"></div><div class="line"><span class="comment"># func4(3)    # 1,2,3 有结束条件</span></div></pre></td></tr></table></figure>
<p>递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出）</p>
<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><img src="https://i.imgur.com/Z1qnoKw.jpg" alt="dog递归"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(depth)</span>:</span></div><div class="line">    <span class="keyword">if</span> depth == <span class="number">0</span>:</div><div class="line">        print(<span class="string">'我的小鲤鱼'</span>,end=<span class="string">''</span>)   <span class="comment"># 取消换行</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        print(<span class="string">'抱着'</span>,end=<span class="string">''</span>)</div><div class="line">        func(depth<span class="number">-1</span>)</div><div class="line">        print(<span class="string">'的我'</span>,end=<span class="string">''</span>)</div><div class="line"></div><div class="line">func(<span class="number">3</span>) <span class="comment"># 抱着抱着抱着我的小鲤鱼的我的我的我</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 利用递归函数计算阶乘</span></div><div class="line"><span class="comment"># N! = 1 * 2 * 3 * ... * N</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> n * fact(n<span class="number">-1</span>)</div><div class="line"></div><div class="line">print(<span class="string">'fact(1) ='</span>, fact(<span class="number">1</span>))</div><div class="line">print(<span class="string">'fact(5) ='</span>, fact(<span class="number">5</span>))</div><div class="line">print(<span class="string">'fact(10) ='</span>, fact(<span class="number">10</span>))</div><div class="line"></div><div class="line"><span class="comment"># 利用递归函数移动汉诺塔:</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(n, a, b, c)</span>:</span></div><div class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</div><div class="line">        print(<span class="string">'move'</span>, a, <span class="string">'--&gt;'</span>, c)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        move(n<span class="number">-1</span>, a, c, b)</div><div class="line">        move(<span class="number">1</span>, a, b, c)</div><div class="line">        move(n<span class="number">-1</span>, b, a, c)</div><div class="line"></div><div class="line">move(<span class="number">4</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>)</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[列表排序]]></title>
      <url>/%E5%88%97%E8%A1%A8%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p><strong>重点:</strong></p>
<ul>
<li>有序区</li>
<li>无序区</li>
</ul>
<h1 id="冒泡排序（BUB）"><a href="#冒泡排序（BUB）" class="headerlink" title="冒泡排序（BUB）"></a>冒泡排序（BUB）</h1><blockquote>
<p>列表每两个相邻的数, 如果前边的比后边的大, 那么交换这两个数</p>
</blockquote>
<p><strong>冒泡排序算法的流程如下：</strong></p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<p><img src="https://i.imgur.com/T0nk855.gif" alt="冒泡排序"></p>
<p><strong>关键点:</strong>  趟, 无序区</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># O(n²) 时间复杂度</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(li)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(li) &lt;= <span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> li</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(li)<span class="number">-1</span>): <span class="comment"># i 是趟</span></div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(li)-i - <span class="number">1</span>): <span class="comment"># j 是指针</span></div><div class="line">            <span class="keyword">if</span> li[j] &gt; li[j+<span class="number">1</span>]:</div><div class="line">                li[j], li[j+<span class="number">1</span>] = li[j+<span class="number">1</span>] , li[j]</div><div class="line">    <span class="keyword">return</span> li</div><div class="line">li = list(range(<span class="number">10000</span>))</div><div class="line"><span class="keyword">import</span> random <span class="keyword">as</span> rd</div><div class="line">rd.shuffle(li) <span class="comment"># 打乱顺序</span></div><div class="line">print(li)</div><div class="line">print(bubble_sort(li))</div></pre></td></tr></table></figure>
<h2 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(li)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(li) &lt;= <span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> li</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(li) - <span class="number">1</span>):  <span class="comment"># i 是趟</span></div><div class="line">        exchange = Flase</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(li) - i - <span class="number">1</span>):  <span class="comment"># j 是指针</span></div><div class="line">            <span class="keyword">if</span> li[j] &gt; li[j + <span class="number">1</span>]:</div><div class="line">                li[j], li[j + <span class="number">1</span>] = li[j + <span class="number">1</span>], li[j]</div><div class="line">                exchange = <span class="keyword">True</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exchange:</div><div class="line">            <span class="keyword">break</span></div><div class="line">    <span class="keyword">return</span> li</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>空间时间复杂度</th>
<th>O(1)</th>
</tr>
</thead>
<tbody>
<tr>
<td>最坏时间复杂度</td>
<td>O(n²)</td>
</tr>
<tr>
<td>最优时间复杂度</td>
<td>O(n)</td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td>O(n²)</td>
</tr>
</tbody>
</table>
<h1 id="选择排序（SEL）"><a href="#选择排序（SEL）" class="headerlink" title="选择排序（SEL）"></a>选择排序（SEL）</h1><p>每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。<br><img src="https://i.imgur.com/Y7JK85g.gif" alt="选择排序"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(li)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(li) - <span class="number">1</span>):  <span class="comment"># i 是趟</span></div><div class="line">        min_doc = i</div><div class="line">        <span class="comment"># 找i位置到最后位置范围内最小的数</span></div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(li)):  <span class="comment"># i可以换成i+1,省去和自己比</span></div><div class="line">            <span class="keyword">if</span> li[j] &lt; li[min_doc]:</div><div class="line">                min_doc = j</div><div class="line">        <span class="comment"># 和无序区第一个数作交换</span></div><div class="line">        <span class="comment"># 可以加上 i==min_loc 的判断,省去和自己换</span></div><div class="line">        <span class="keyword">if</span> min_doc != i:</div><div class="line">            li[min_doc], li[i] = li[i], li[min_doc]</div><div class="line">        <span class="string">'''</span></div><div class="line">        i, j, min_doc 都是下标</div><div class="line">        '''</div><div class="line">    <span class="keyword">return</span> li</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>空间时间复杂度</th>
<th>O(1)</th>
</tr>
</thead>
<tbody>
<tr>
<td>最坏时间复杂度</td>
<td>O(n²)</td>
</tr>
<tr>
<td>最优时间复杂度</td>
<td>O(n²)</td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td>O(n²)</td>
</tr>
</tbody>
</table>
<h1 id="插入排序（INS）"><a href="#插入排序（INS）" class="headerlink" title="插入排序（INS）"></a>插入排序（INS）</h1><p>插入排序每次取出数组后半部分的第一个元素，在排好序的前半部分中，为其找到最合适的位置并进行插入(扑克牌)<br><img src="https://i.imgur.com/UzdoF4Z.gif" alt="插入排序"></p>
<ul>
<li>列表被分为有序区和无序区两个部分。最初有序区只有一个元素。</li>
<li>每次从无序区选择一个元素，插入到有序区的位置，直到无序区变空。</li>
</ul>
<p><strong>插入排序算法的流程如下：</strong></p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤 2~5</li>
</ol>
<p><strong>关键点：</strong></p>
<ul>
<li>摸到的牌</li>
<li>手里的牌 (有序)</li>
</ul>
<h2 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(li)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(li) == <span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> li</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(li)):  <span class="comment"># i代表每次摸到的牌的下标</span></div><div class="line">        tmp = li[i]</div><div class="line">        j = i - <span class="number">1</span>  <span class="comment"># j代表手里最后一张牌的下标</span></div><div class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> tmp &lt; li[j]: <span class="comment"># 摸到的牌比手牌最后的牌小</span></div><div class="line">            li[j + <span class="number">1</span>] = li[j] <span class="comment"># 把最大的手牌往后挪动</span></div><div class="line">            j -= <span class="number">1</span></div><div class="line">        li[j + <span class="number">1</span>] = tmp <span class="comment"># 摸到的牌比手牌最后的牌大</span></div><div class="line">    <span class="keyword">return</span> li</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>空间时间复杂度</th>
<th>O(1)</th>
</tr>
</thead>
<tbody>
<tr>
<td>最坏时间复杂度</td>
<td>O(n²)</td>
</tr>
<tr>
<td>最优时间复杂度</td>
<td>O(n²)</td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td>O(n²)</td>
</tr>
</tbody>
</table>
<h1 id="快速排序（QUI）"><a href="#快速排序（QUI）" class="headerlink" title="快速排序（QUI）"></a>快速排序（QUI）</h1><p>博主看动图不是很理解, 建议看 <a href="http://bbs.ahalei.com/thread-4419-1-1.html" target="_blank" rel="external">这里</a><br><img src="https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" alt="快速排序"><br><img src="https://i.imgur.com/mEG5lt2.gif" alt="快速排序"></p>
<p><strong>快速排序算法的流程如下：</strong></p>
<ul>
<li>取一个元素p（第一个元素），使元素p归位；</li>
<li>列表被p分成两部分，左边都比p小，右边都比p大；</li>
<li>递归完成排序。</li>
</ul>
<p><strong>关键点：</strong></p>
<ul>
<li>整理(让元素归位)</li>
<li>递归</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(data, left, right)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    partition:归位函数</div><div class="line">    右手左手一个慢动作</div><div class="line">    右手左手慢动作重播</div><div class="line">    '''</div><div class="line">    tmp = data[left] <span class="comment"># 取基准数</span></div><div class="line">    <span class="keyword">while</span> left &lt; right:</div><div class="line">        <span class="comment"># 如果需要降序排序的话, 就把 data[right] &gt;= tmp 中的小于等于改为大于等于</span></div><div class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> data[right] &gt;= tmp:</div><div class="line">            right -= <span class="number">1</span> <span class="comment"># 左移</span></div><div class="line">        <span class="keyword">if</span> left &lt; right: <span class="comment"># 如果上面的循环是因为找到了 right 小于 tmp 的数而跳出循环</span></div><div class="line">            data[left] = data[right] <span class="comment"># 把小于 tmp 的这个元素放到 tmp 的位置上</span></div><div class="line">        <span class="comment"># 如果需要降序排序的话, 就把 data[right] &gt;= tmp 中的大于等于改为小于等于</span></div><div class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> data[left] &lt;= tmp:</div><div class="line">            left += <span class="number">1</span> <span class="comment"># 右移</span></div><div class="line">        data[right] = data[left] <span class="comment"># 把大于 tmp 的这个元素放到 tmp 的位置上</span></div><div class="line">    data[left] = tmp <span class="comment"># 那个 mid 回来</span></div><div class="line">    <span class="keyword">return</span> left</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_quick_sort</span><span class="params">(data, left, right)</span>:</span></div><div class="line">    <span class="keyword">if</span> left &lt; right:</div><div class="line">        mid = partition(data, left, right)</div><div class="line">        _quick_sort(data, left, mid - <span class="number">1</span>)</div><div class="line">        _quick_sort(data, mid + <span class="number">1</span>, right)</div><div class="line"></div><div class="line"><span class="meta">@cal_time</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(data)</span>:</span></div><div class="line">    <span class="keyword">return</span> _quick_sort(data,<span class="number">0</span>,len(data)<span class="number">-1</span>)</div></pre></td></tr></table></figure>
<h2 id="优化版-1"><a href="#优化版-1" class="headerlink" title="优化版"></a>优化版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 来自知乎 @风满楼</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(lists, left, right)</span>:</span></div><div class="line">    <span class="keyword">if</span> left &gt; right:</div><div class="line">        <span class="keyword">return</span> lists</div><div class="line">    low, high = left, right</div><div class="line">    key = lists[left]  <span class="comment"># key即是基准数</span></div><div class="line">    <span class="keyword">while</span> left &lt; right:</div><div class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> lists[right] &gt;= key:</div><div class="line">            right -= <span class="number">1</span> <span class="comment"># 左移</span></div><div class="line">        lists[left] = lists[right] </div><div class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> lists[left] &lt;= key:</div><div class="line">            left += <span class="number">1</span> <span class="comment"># 右移</span></div><div class="line">        lists[right] = lists[left]</div><div class="line">    lists[right] = key</div><div class="line">    quick_sort(lists, low, left - <span class="number">1</span>)</div><div class="line">    quick_sort(lists, right + <span class="number">1</span>, high)</div><div class="line">    <span class="keyword">return</span> lists</div><div class="line"></div><div class="line">quick(data,<span class="number">0</span>,len(data)<span class="number">-1</span>)</div></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>某些极端的情况下复杂度非常高, 如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">9 8 7 6 5 4 3 2 1</div></pre></td></tr></table></figure>
<p>出现的概率不多, 属于极端情况, 解决方法: 选基准的时候随机选一个数与第一个数交换。</p>
<table>
<thead>
<tr>
<th>空间时间复杂度</th>
<th>根据实现的方式不同而不同</th>
</tr>
</thead>
<tbody>
<tr>
<td>最坏时间复杂度</td>
<td>O(n²)</td>
</tr>
<tr>
<td>最优时间复杂度</td>
<td>O(nlogn)</td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td>O(nlogn)</td>
</tr>
</tbody>
</table>
<p>PS: 看到一个最狠的快排</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># https://github.com/qiwsir/algorithm/blob/master/quick_sort.md</span></div><div class="line">qs = <span class="keyword">lambda</span> xs : ( (len(xs) &lt;= <span class="number">1</span> <span class="keyword">and</span> [xs]) <span class="keyword">or</span> [ qs( [x <span class="keyword">for</span> x <span class="keyword">in</span> xs[<span class="number">1</span>:] <span class="keyword">if</span> x &lt; xs[<span class="number">0</span>]] ) + [xs[<span class="number">0</span>]] + qs( [x <span class="keyword">for</span> x <span class="keyword">in</span> xs[<span class="number">1</span>:] <span class="keyword">if</span> x &gt;= xs[<span class="number">0</span>]] ) ] )[<span class="number">0</span>]</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://ictar.github.io/2015/12/08/%E4%B9%9D%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6Python%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" target="_blank" rel="external">Ele - A面</a></li>
<li><a href="http://bbs.ahalei.com/thread-4419-1-1.html" target="_blank" rel="external">http://bbs.ahalei.com/thread-4419-1-1.html</a></li>
<li><a href="http://blog.csdn.net/v_july_v/article/details/6116297" target="_blank" rel="external">http://blog.csdn.net/v_july_v/article/details/6116297</a></li>
<li><a href="https://www.zhihu.com/question/26786398" target="_blank" rel="external">https://www.zhihu.com/question/26786398</a></li>
<li><a href="https://hellolynn.hpd.io/2017/08/03/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-quick-sort/" target="_blank" rel="external">https://hellolynn.hpd.io/2017/08/03/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-quick-sort/</a></li>
<li><a href="https://github.com/qiwsir/algorithm/blob/master/quick_sort.md" target="_blank" rel="external">https://github.com/qiwsir/algorithm/blob/master/quick_sort.md</a></li>
</ul>
<h1 id="堆排序（HEAP）"><a href="#堆排序（HEAP）" class="headerlink" title="堆排序（HEAP）"></a>堆排序（HEAP）</h1><p>堆排序用的是<a href="/数据结构：树/">树</a>的结构<br><img src="https://i.imgur.com/JH2f8TO.jpg" alt="树（数据结构）"></p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ul>
<li>大根堆：一棵完全二叉树，满足任一节点都比其孩子节点大</li>
<li>小根堆：一棵完全二叉树，满足任一节点都比其孩子节点小</li>
</ul>
<p><img src="https://i.imgur.com/ShbrOiR.jpg" alt="大小根堆"></p>
<p><strong>假设：节点的左右子树都是堆，但自身不是堆</strong></p>
<blockquote>
<p>当根节点的左右子树都是堆时，可以通过一次向下的调整来将其变换成一个堆。</p>
</blockquote>
<p><img src="https://i.imgur.com/Vyt45u6.gif" alt="调整"></p>
<p><strong>堆排序过程:</strong></p>
<ol>
<li>建立堆</li>
<li>得到堆顶元素，为最大元素</li>
<li>去掉堆顶，将堆最后一个元素放到堆顶，此时可通过一次调整重新使堆有序。</li>
<li>堆顶元素为第二大元素。</li>
<li>重复步骤3，直到堆变空。</li>
</ol>
<ul>
<li><p>构建堆<br>先从最小的子树开始看, 最后一步看整个的堆; 从最后一个非叶子节点为根的子树开始做调整<br><img src="https://i.imgur.com/VF7ia3X.gif" alt="构建堆"></p>
</li>
<li><p>挨个出数</p>
</li>
</ul>
<p><img src="https://i.imgur.com/4fYb7L4.gif" alt="挨个出数"></p>
<h2 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift</span><span class="params">(data, low, high)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    调整函数</div><div class="line">    data: 列表</div><div class="line">    low：待调整的子树的根位置</div><div class="line">    high：待调整的子树的最后一个节点的位置</div><div class="line">    """</div><div class="line">    i = low</div><div class="line">    j = <span class="number">2</span> * i + <span class="number">1</span></div><div class="line">    tmp = data[i]</div><div class="line">    <span class="comment"># i指向空位置</span></div><div class="line">    <span class="keyword">while</span> j&lt;=high:      <span class="comment">#领导已经撸到底了</span></div><div class="line">        <span class="keyword">if</span> j != high <span class="keyword">and</span> data[j] &lt; data[j+<span class="number">1</span>]:</div><div class="line">            j += <span class="number">1</span></div><div class="line">        <span class="comment">#j指向数值大的孩子</span></div><div class="line">        <span class="keyword">if</span> tmp &lt; data[j]:   <span class="comment">#如果小领导比撸下来的大领导能力值大</span></div><div class="line">            data[i] = data[j]</div><div class="line">            i = j</div><div class="line">            j = <span class="number">2</span>*i+<span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">break</span>       <span class="comment">#撸下来的领导比候选的领导能力值大</span></div><div class="line">    data[i] = tmp</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(data)</span>:</span></div><div class="line">    n = len(data)</div><div class="line">    <span class="comment"># 建堆 从最后一个非叶子节点所以是 -1(2) 列表倒序</span></div><div class="line">    <span class="comment"># n//2-1 找最后一个非叶子节点</span></div><div class="line">    <span class="comment"># -1(1) 顾前不顾后</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n//<span class="number">2</span><span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">        sift(data, i,  n - <span class="number">1</span>) <span class="comment"># 这里的 n-1 是把所有子树的 high 都设置成整个堆的 high</span></div><div class="line">    <span class="comment"># 挨个出数</span></div><div class="line">    <span class="keyword">for</span> high <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">        data[<span class="number">0</span>], data[high] = data[high], data[<span class="number">0</span>]</div><div class="line">        sift(data, <span class="number">0</span>, high - <span class="number">1</span>)</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>空间时间复杂度</th>
<th>O(n)，O(1)</th>
</tr>
</thead>
<tbody>
<tr>
<td>最坏时间复杂度</td>
<td>O(nlogn)</td>
</tr>
<tr>
<td>最优时间复杂度</td>
<td>O(nlogn)</td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td>O(nlogn)</td>
</tr>
</tbody>
</table>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="/数据结构：树/">数据结构：树</a></li>
<li><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="external">https://www.cnblogs.com/chengxiao/p/6129630.html</a></li>
<li><a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/" target="_blank" rel="external">http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/</a></li>
<li><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/" target="_blank" rel="external">http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/</a></li>
</ul>
<h1 id="归并排序（MER）"><a href="#归并排序（MER）" class="headerlink" title="归并排序（MER）"></a>归并排序（MER）</h1><p><img src="https://i.imgur.com/7sbKXQt.gif" alt="归并排序"><br><img src="https://i.imgur.com/FN392sX.gif" alt="归并排序"><br><strong>归并排序思路:</strong></p>
<ol>
<li>分解：将列表越分越小，直至分成一个元素。</li>
<li>一个元素是有序的。</li>
<li>合并：将两个有序列表归并，列表越来越大。</li>
</ol>
<p><img src="https://i.imgur.com/dXgFcwQ.png" alt="归并排序流程"></p>
<h2 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(data, low, mid, high)</span>:</span></div><div class="line">    <span class="string">'''一次归并'''</span></div><div class="line">    i = low</div><div class="line">    j = mid + <span class="number">1</span></div><div class="line">    ltmp = []  <span class="comment"># 临时列表</span></div><div class="line">    <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= high:</div><div class="line">        <span class="keyword">if</span> data[i] &lt;= data[j]:</div><div class="line">            ltmp.append((data[i]))</div><div class="line">            i += <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:  <span class="comment"># data[i] &gt; data[j]</span></div><div class="line">            ltmp.append(data[j])</div><div class="line">            j += <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> i &lt;= mid:</div><div class="line">        ltmp.append(data[i])</div><div class="line">        i += <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> j &lt;= high:</div><div class="line">        ltmp.append(data[j])</div><div class="line">        j += <span class="number">1</span></div><div class="line">    data[low:high + <span class="number">1</span>] = ltmp</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergesort</span><span class="params">(data, low, high)</span>:</span></div><div class="line">    <span class="string">'''归并排序'''</span></div><div class="line">    <span class="keyword">if</span> low &lt; high:</div><div class="line">        mid = (low + high) // <span class="number">2</span> <span class="comment"># 获取中间位置</span></div><div class="line">        mergesort(data, low, mid) <span class="comment"># 分解左半部分</span></div><div class="line">        mergesort(data, mid + <span class="number">1</span>, high) <span class="comment"># 分解右半部分</span></div><div class="line">        merge(data, low, mid, high) <span class="comment"># 归并</span></div><div class="line">    <span class="keyword">return</span> data</div></pre></td></tr></table></figure>
<h2 id="加深理解"><a href="#加深理解" class="headerlink" title="加深理解"></a>加深理解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">if</span> x &gt; <span class="number">1</span>:</div><div class="line">        y = x // <span class="number">2</span></div><div class="line">        func(y)</div><div class="line">        func(y)</div><div class="line">        print(y)</div><div class="line">func(<span class="number">20</span>)</div><div class="line"><span class="comment"># 看最后的输出 画图</span></div></pre></td></tr></table></figure>
<p>或者结合<a href="/递归/">递归</a></p>
<p><img src="https://i.imgur.com/XBeGCIP.png" alt="递归输出"></p>
<table>
<thead>
<tr>
<th>空间时间复杂度</th>
<th>O(n)</th>
</tr>
</thead>
<tbody>
<tr>
<td>最坏时间复杂度</td>
<td>O(nlogn)</td>
</tr>
<tr>
<td>最优时间复杂度</td>
<td>O(n)</td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td>O(nlogn)</td>
</tr>
</tbody>
</table>
<ul>
<li>快速排序、堆排序、归并排序 - 小结</li>
</ul>
<p>三种排序算法的时间复杂度都是O(nlogn)</p>
<ul>
<li>运行时间:</li>
</ul>
<p><code>快速排序</code> &lt; <code>归并排序</code> &lt; <code>堆排序</code></p>
<p>三种排序算法的缺点：</p>
<table>
<thead>
<tr>
<th>快速排序</th>
<th>极端情况下排序效率低</th>
</tr>
</thead>
<tbody>
<tr>
<td>归并排序</td>
<td>需要额外的内存开销</td>
</tr>
<tr>
<td>堆排序</td>
<td>在快的排序算法中相对较慢</td>
</tr>
</tbody>
</table>
<h1 id="计数排序（COU）"><a href="#计数排序（COU）" class="headerlink" title="计数排序（COU）"></a>计数排序（COU）</h1><p><img src="https://i.imgur.com/piK8FYS.gif" alt="计数排序"></p>
<blockquote>
<p>题: 现在有一个列表，列表中的数范围都在 0 到 100 之间，列表长度大约为 100 万。设计算法在 O(n) 时间复杂度内将列表进行排序。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_sort</span><span class="params">(data, maxnum = <span class="number">100</span>)</span>:</span></div><div class="line">    <span class="string">'''计数排序  O(n)'''</span></div><div class="line">    count = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(maxnum+<span class="number">1</span>)]</div><div class="line">    result = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</div><div class="line">        count[i] += <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> num,count <span class="keyword">in</span> enumerate(count):</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</div><div class="line">            result.append(num)</div><div class="line"><span class="comment"># 或</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_sort</span><span class="params">(data, max_num)</span>:</span></div><div class="line">    count = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(max_num + <span class="number">1</span>)]</div><div class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> data:</div><div class="line">        count[num] += <span class="number">1</span></div><div class="line">    i = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> num, m <span class="keyword">in</span> enumerate(count):</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</div><div class="line">            data[i] = num</div><div class="line">            i += <span class="number">1</span></div></pre></td></tr></table></figure>
<p>因为要开额外的内存空间，所以使用并不多。计数排序限定元素不会太大的时候，如：年龄可以使用计数排序</p>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序是一种分组插入排序算法。O(1.3n)</p>
<p><img src="https://i.imgur.com/s1gQYYA.gif" alt="希尔排序"></p>
<p><strong>希尔排序思路：</strong></p>
<ol>
<li>先取一个正整数 d1(d1 &lt; n)，把全部记录分成 d1 个组，所有距离为 d1 的倍数的记录看成一组，然后在各组内进行插入排序</li>
<li>然后取 d2(d2 &lt; d1)</li>
<li>重复上述分组和排序操作；直到取 di = 1(i &gt;= 1) 位置，即所有记录成为一个组，最后对这个组进行插入排序。一般选 d1 约为 n/2，d2 为 d1 /2， d3 为 d2/2 ，…， di = 1。</li>
</ol>
<p>希尔排序每趟并不使某些元素有序，而是使整体数据越来越接近有序；最后一趟排序使得所有数据有序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 修改插入排序</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort_gap</span><span class="params">(data, gap)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, len(data)):</div><div class="line">        tmp = data[i]</div><div class="line">        j = j - gap</div><div class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> tmp &lt; data[j]:</div><div class="line">            data[j + gap] = data[j]</div><div class="line">            j = j - gap</div><div class="line">        data[j + gap] = tmp</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(data)</span>:</span></div><div class="line">    <span class="string">'''希尔排序'''</span></div><div class="line">    d = len(data) // <span class="number">2</span></div><div class="line">    <span class="keyword">while</span> d &gt; <span class="number">0</span>:</div><div class="line">        insert_sort_gap(data,d)</div><div class="line">        d = d // <span class="number">2</span></div></pre></td></tr></table></figure>
<h2 id="优化版-2"><a href="#优化版-2" class="headerlink" title="优化版"></a>优化版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(data)</span>:</span></div><div class="line">    gap = len(data) // <span class="number">2</span></div><div class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap,len(data)):</div><div class="line">            tmp = data[i]</div><div class="line">            j = i-gap</div><div class="line">            <span class="keyword">while</span> j &gt;=<span class="number">0</span> <span class="keyword">and</span> tmp &lt; data[j]:</div><div class="line">                data[j+gap] = data[j]</div><div class="line">                j -= gap</div><div class="line">            data[j+gap] = tmp</div><div class="line">        gap /= <span class="number">2</span></div></pre></td></tr></table></figure>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><h2 id="排序算法指标"><a href="#排序算法指标" class="headerlink" title="排序算法指标"></a>排序算法指标</h2><p><img src="https://i.imgur.com/kkVSVGH.jpg" alt="排序算法指标"></p>
<h2 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h2><p>排序关键字相同的情况下，对象的相对位置不变</p>
<h2 id="计时装饰器"><a href="#计时装饰器" class="headerlink" title="计时装饰器"></a>计时装饰器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_time</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">        t1 = time.time()</div><div class="line">        x = func(*args, **kwargs)</div><div class="line">        t2 = time.time()</div><div class="line">        print(<span class="string">"%s running time %s secs."</span> % (func.__name__, t2 - t1))</div><div class="line">        <span class="keyword">return</span> x</div><div class="line">    <span class="keyword">return</span> wrapper</div></pre></td></tr></table></figure>
<h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>博客部分图片截取自 <a href="https://visualgo.net/zh/sorting" target="_blank" rel="external">https://visualgo.net/zh/sorting</a></li>
<li><a href="http://bubkoo.com" target="_blank" rel="external">http://bubkoo.com</a></li>
<li><a href="http://chenyvehtung.github.io/2017/02/26/sort-algorithms.html" target="_blank" rel="external">http://chenyvehtung.github.io/2017/02/26/sort-algorithms.html</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Category:%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="external">维基百科-排序算法</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo: ERROR Process failed: _posts/*]]></title>
      <url>/hexo-ERROR-Process-failed-posts/</url>
      <content type="html"><![CDATA[<p>文章的格式出现错误了</p>
<a id="more"></a>
<ul>
<li>错误提示</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ hexo s</div><div class="line">ERROR Process failed: _posts/*</div><div class="line">Error at </div><div class="line">.....</div></pre></td></tr></table></figure>
<ul>
<li>原因</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">title: Hexo</div><div class="line">date: 2017-12-13 12:21:33</div><div class="line">tags:Hexo #tags冒号后面应当有个空格,其他地方也应当注意</div></pre></td></tr></table></figure>
<ul>
<li>正确格式(加上那个空格就好了)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">title: Hexo</div><div class="line">date: 2017-12-13 12:21:33</div><div class="line">tags: Hexo</div></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://shitaibin.github.io/2015/12/13/hexo-errors/" target="_blank" rel="external">http://shitaibin.github.io/2015/12/13/hexo-errors/</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python:消息队列Rabbitmq基本使用]]></title>
      <url>/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97Rabbitmq%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>为什么用Rabbitmq instead of python queue ?</p>
<a id="more"></a>
<blockquote>
<p>是因为python queue 不能跨进程 </p>
</blockquote>
<p><strong>队列的作用:</strong>    </p>
<pre><code>1. 存储消息、数据
2. 保证消息顺序 
3. 保证数据的交付
</code></pre><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 斐波那契数列</span></div><div class="line">1 1 2 3 5 8 13 ...</div><div class="line"><span class="comment"># 启动rabbitmq，并验证启动情况 </span></div><div class="line">rabbitmq-server --detached &amp;ps aux |grep rabbitmq</div><div class="line"><span class="comment"># 以服务的方式启动</span></div><div class="line">service rabbitmq-server start</div><div class="line"><span class="comment"># 启用维护插件</span></div><div class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management </div><div class="line"><span class="comment"># 重启</span></div><div class="line">service rabbitmq-server restart</div><div class="line"></div><div class="line"><span class="comment"># erroe</span></div><div class="line">pika.exceptions.ProbableAuthenticationError</div><div class="line"><span class="comment"># 解决方法</span></div><div class="line"><span class="comment"># 写入信息 并保存/关闭防火墙 'systemctl stop filewallf'</span></div><div class="line">vim /etc/rabbitmq/rabbitmq.config</div><div class="line">[&#123;rabbit, [&#123;loopback_users, []&#125;]&#125;].</div><div class="line"><span class="comment"># 查看当前队列</span></div><div class="line">rabbitmqctl list_queues</div></pre></td></tr></table></figure>
<h2 id="基本使用实现"><a href="#基本使用实现" class="headerlink" title="基本使用实现"></a>基本使用实现</h2><h3 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line"><span class="comment"># 创建连接</span></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 声明消息队列</span></div><div class="line">channel.queue_declare(queue=<span class="string">'hello'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 发送消息到上面声明的hello队列，</span></div><div class="line"><span class="comment"># 其中exchange表示交换器，能精确指定消息应该发送到哪个队列，</span></div><div class="line"><span class="comment"># routing_key设置为队列的名称，</span></div><div class="line"><span class="comment"># body就是发送的内容，</span></div><div class="line">channel.basic_publish(exchange=<span class="string">''</span>,routing_key=<span class="string">'hello'</span>,body=<span class="string">'Hello World!'</span>)</div><div class="line"></div><div class="line">print(<span class="string">'[x] Sent "Hello World!"'</span>)</div><div class="line"></div><div class="line"><span class="comment"># sh命令</span></div><div class="line"><span class="comment"># 用 rabbitmqctl list_queues 查看队列</span></div><div class="line"><span class="string">'''</span></div><div class="line">Listing queues</div><div class="line">hello	1</div><div class="line">'''</div></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/6vYEGPV.jpg" alt=""></p>
<h3 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line"><span class="comment"># 创建连接</span></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 声明消息队列</span></div><div class="line">channel.queue_declare(queue=<span class="string">'hello'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 接收消息 回调函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callbcak</span><span class="params">(ch,method,properties,body)</span>:</span></div><div class="line">    print(<span class="string">"Received %r"</span>%(body))</div><div class="line"></div><div class="line"><span class="comment"># 告诉rabbitmq使用callback来接收信息</span></div><div class="line">channel.basic_consume(callbcak,queue=<span class="string">'hello'</span>,no_ack=<span class="keyword">True</span>)</div><div class="line"></div><div class="line"><span class="comment">#开始接收信息，并进入阻塞状态，队列里有信息才会调用callback进行处理。按ctrl+c退出。</span></div><div class="line">channel.start_consuming()</div><div class="line"></div><div class="line"><span class="comment"># 终端会阻塞住</span></div><div class="line"><span class="string">'''</span></div><div class="line">Received b'Hello World!'</div><div class="line">'''</div></pre></td></tr></table></figure>
<h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><h3 id="消息不丢失"><a href="#消息不丢失" class="headerlink" title="消息不丢失"></a>消息不丢失</h3><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">    msg = <span class="string">' '</span>.join(sys.argv[<span class="number">1</span>:])<span class="keyword">or</span> <span class="string">'Hello World! %s'</span> % time.time()</div><div class="line">    channel.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">                          routing_key=<span class="string">'hello'</span>,</div><div class="line">                          body=bytes(msg,encoding=<span class="string">'utf8'</span>),)</div></pre></td></tr></table></figure>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><ul>
<li><code>no_ack=False</code> 消费者退出不消息不丢失</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 修改回调函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callbcak</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">"Received %r"</span> % (body))</div><div class="line">    time.sleep(<span class="number">5</span>)</div><div class="line">    print(<span class="string">"[x] Done"</span>)</div></pre></td></tr></table></figure>
<h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><ul>
<li>消息持久化存储,</li>
</ul>
<blockquote>
<p>虽然消息反馈机制，但是如果rabbitmq自身挂掉的话，那么任务还是会丢失。所以需要将任务持久化存储起来。声明持久化存储：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 原队列</span></div><div class="line">channel.queue_declare(queue=<span class="string">'hello'</span>, durable=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<p>但是这个程序会执行错误，因为hello这个队列已经存在，并且是非持久化的，rabbitmq不允许使用不同的参数来重新定义存在的队列。重新定义一个队列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 重新定义一个队列</span></div><div class="line">channel.queue_declare(queue=<span class="string">'task_queue'</span>, durable=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<p>在发送任务的时候，用delivery_mode=2来标记任务为持久化存储：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">channel.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">       routing_key=<span class="string">"task_queue"</span>,</div><div class="line">       body=message,</div><div class="line">       properties=pika.BasicProperties(</div><div class="line">          delivery_mode = <span class="number">2</span>, <span class="comment"># make message persistent</span></div><div class="line">       ))</div></pre></td></tr></table></figure>
<h3 id="公平调度"><a href="#公平调度" class="headerlink" title="公平调度"></a>公平调度</h3><p><code>prefetch_count = 1</code></p>
<p>虽然每个工作者是依次分配到任务，但是每个任务不一定一样。可能有的任务比较重，执行时间比较久；有的任务比较轻，执行时间比较短。如果能公平调度就最好了，使用basic_qos设置prefetch_count=1，使得rabbitmq不会在同一时间给工作者分配多个任务，即只有工作者完成任务之后，才会再次接收到任务。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">channel.basic_qos(prefetch_count=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<ul>
<li>new_task.py完整代码</li>
</ul>
<blockquote>
<p>发送者/生产者</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    host=<span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line">channel.queue_declare(queue=<span class="string">'task_queue'</span>, durable=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">message = <span class="string">' '</span>.join(sys.argv[<span class="number">1</span>:]) <span class="keyword">or</span> <span class="string">"Hello World!"</span></div><div class="line">channel.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">                      routing_key=<span class="string">'task_queue'</span>,</div><div class="line">                      body=message,</div><div class="line">                      properties=pika.BasicProperties(</div><div class="line">                          delivery_mode=<span class="number">2</span>,  <span class="comment"># make message persistent</span></div><div class="line">                      ))</div><div class="line">print(<span class="string">" [x] Sent %r"</span> % (message,))</div><div class="line">connection.close()</div></pre></td></tr></table></figure>
<ul>
<li>worker.py完整代码</li>
</ul>
<blockquote>
<p>接受者/消费者</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line">channel.queue_declare(queue=<span class="string">'task_queue'</span>, durable=<span class="keyword">True</span>)</div><div class="line">print(<span class="string">' [*] Waiting for messages. To exit press CTRL+C'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">" [x] Received %r"</span> % (body,))</div><div class="line">    time.sleep(<span class="number">6</span>)</div><div class="line">    print(<span class="string">" [x] Done"</span>,ch.basic_ack(delivery_tag=method.delivery_tag))</div><div class="line"></div><div class="line"></div><div class="line">channel.basic_qos(prefetch_count=<span class="number">1</span>)</div><div class="line">channel.basic_consume(callback,</div><div class="line">                      queue=<span class="string">'task_queue'</span>)</div><div class="line"></div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure>
<h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>广播交换机的工作原理：消息发送端先将消息发送给交换机，交换机再将消息发送到绑定的消息队列，而后每个接收端都能从各自的消息队列里接收到信息。</p>
<p><img src="https://i.imgur.com/mK7MEC5.jpg" alt=""></p>
<h3 id="消费者-接收端receive-py代码分析"><a href="#消费者-接收端receive-py代码分析" class="headerlink" title="消费者/接收端receive.py代码分析"></a>消费者/接收端receive.py代码分析</h3><p>和最早的receive.py相比，主要是做了两个改动：</p>
<ul>
<li>定义交换机</li>
<li>不使用hello队列了，随机生成一个临时队列，并绑定到交换机上</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    <span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 定义交换机</span></div><div class="line">channel.exchange_declare(exchange=<span class="string">'messages'</span>, type=<span class="string">'fanout'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 随机生成队列，并绑定到交换机上</span></div><div class="line"><span class="comment"># 参数'exclusive=True'表示当接收端退出时，销毁临时产生的队列，这样就不会占用资源。</span></div><div class="line">result = channel.queue_declare(exclusive=<span class="keyword">True</span>)</div><div class="line">queue_name = result.method.queue</div><div class="line">channel.queue_bind(exchange=<span class="string">'messages'</span>, queue=queue_name)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">" [x] Received %r"</span> % (body,))</div><div class="line"></div><div class="line"></div><div class="line">channel.basic_consume(callback, queue=queue_name, no_ack=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">print(<span class="string">' [*] Waiting for messages. To exit press CTRL+C'</span>)</div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure>
<p>执行<code>rabbitmqctl list_queues</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">task_queue	0</div><div class="line">hello	5</div><div class="line"><span class="comment"># 定义了交换机</span></div><div class="line">amq.gen-K0M17k_3LVYO0b7m0s-K1g	0</div></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/1EuVNfF.jpg" alt=""></p>
<h3 id="生产者-发送端send-py代码分析"><a href="#生产者-发送端send-py代码分析" class="headerlink" title="生产者/发送端send.py代码分析"></a>生产者/发送端send.py代码分析</h3><p>和最早的send.py相比，也只做了两个改动：</p>
<ul>
<li>定义交换机</li>
<li>不是将消息发送到hello队列，而是发送到交换机</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    <span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 定义交换机</span></div><div class="line"><span class="comment"># type='fanout' 表示广播的意思</span></div><div class="line">channel.exchange_declare(exchange=<span class="string">'messages'</span>, type=<span class="string">'fanout'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 将消息发送到交换机</span></div><div class="line"><span class="comment"># basic_publish方法的参数exchange被设定为相应交换机，</span></div><div class="line"><span class="comment"># 因为是要广播出去，发送到所有队列，所以routing_key就不需要设定了。</span></div><div class="line">channel.basic_publish(exchange=<span class="string">'messages'</span>, routing_key=<span class="string">''</span>, body=<span class="string">'Hello World!'</span>)</div><div class="line">print(<span class="string">" [x] Sent 'Hello World!'"</span>)</div><div class="line">connection.close()</div></pre></td></tr></table></figure>
<p>exchange如果为空，表示是使用匿名的交换机，在上面交换机信息的图片中可以看到有amq.*这样的交换机，就是系统默认的交换机了。routing_key在使用匿名交换机的时候才需要指定，表示发送到哪个队列的意思。第一篇的例子演示了这个功能。</p>
<p>打开另外一个终端，执行send.py，可以观察到receive.py接收到了消息。如果有多个终端执行receive.py，那么每个receive.py都会接收到消息。</p>
<h2 id="组播-路由"><a href="#组播-路由" class="headerlink" title="组播/路由"></a>组播/路由</h2><h3 id="生产者-send-py代码分析"><a href="#生产者-send-py代码分析" class="headerlink" title="生产者/send.py代码分析"></a>生产者/send.py代码分析</h3><p>和广播相比，改动点主要在两个方面：</p>
<ul>
<li>设定交换机的类型（type）为direct。上一篇是设置为fanout，表示广播的意思，会将消息发送到所有接收端，这里设置为direct表示要根据设定的路由键来发送消息。</li>
<li>发送信息时设置发送的路由键。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    <span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 定义交换机，设置类型为direct</span></div><div class="line">channel.exchange_declare(exchange=<span class="string">'messages'</span>, type=<span class="string">'direct'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 定义三个路由键</span></div><div class="line">routings = [<span class="string">'warning'</span>, <span class="string">'error'</span>]</div><div class="line"></div><div class="line"><span class="comment"># 将消息依次发送到交换机，并设置路由键</span></div><div class="line"><span class="keyword">for</span> routing <span class="keyword">in</span> routings:</div><div class="line">    message = <span class="string">'%s message.'</span> % routing</div><div class="line">    channel.basic_publish(exchange=<span class="string">'messages'</span>,</div><div class="line">                          routing_key=routing,</div><div class="line">                          body=message)</div><div class="line">    print(message)</div><div class="line"></div><div class="line">connection.close()</div></pre></td></tr></table></figure>
<h3 id="消费者-receive-py代码分析"><a href="#消费者-receive-py代码分析" class="headerlink" title="消费者/receive.py代码分析"></a>消费者/receive.py代码分析</h3><p>和广播相比，改动点主要在三个方面：</p>
<ul>
<li>设定交换机的类型（type）为direct。</li>
<li>增加命令行获取参数功能，参数即为路由键。</li>
<li>将队列绑定到交换机上时，设定路由键。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika, sys</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    <span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 定义交换机，设置类型为direct</span></div><div class="line">channel.exchange_declare(exchange=<span class="string">'messages'</span>, type=<span class="string">'direct'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 从命令行获取路由键参数，如果没有，则设置为info</span></div><div class="line">routings = sys.argv[<span class="number">1</span>:]</div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> routings:</div><div class="line">    routings = [<span class="string">'info'</span>]</div><div class="line"></div><div class="line"><span class="comment"># 生成临时队列，并绑定到交换机上，设置路由键</span></div><div class="line">result = channel.queue_declare(exclusive=<span class="keyword">True</span>)</div><div class="line">queue_name = result.method.queue</div><div class="line"><span class="keyword">for</span> routing <span class="keyword">in</span> routings:</div><div class="line">    channel.queue_bind(exchange=<span class="string">'messages'</span>,</div><div class="line">                       queue=queue_name,</div><div class="line">                       routing_key=routing)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">" [x] Received %r"</span> % (body,))</div><div class="line"></div><div class="line"></div><div class="line">channel.basic_consume(callback, queue=queue_name, no_ack=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">print(<span class="string">' [*] Waiting for messages. To exit press CTRL+C'</span>)</div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure>
<p>打开两个终端，一个运行代码python receive.py info warning，表示只接收info和warning的消息。另外一个终端运行send.py，可以观察到接收终端只接收到了info和warning的消息。如果打开多个终端运行receive.py，并传入不同的路由键参数，可以看到更明显的效果。</p>
<p>当接收端正在运行时，可以使用rabbitmqctl list_bindings来查看绑定情况。</p>
<h2 id="按规则发送-正则"><a href="#按规则发送-正则" class="headerlink" title="按规则发送/正则"></a>按规则发送/正则</h2><p>上面路由键/组播的功能，通过设置路由键，可以将消息发送到相应的队列，这里的路由键是要完全匹配，比如info消息的只能发到路由键为info的消息队列。</p>
<p>路由键模糊匹配，就是可以使用正则表达式，和常用的正则表示式不同，这里的话“#”表示所有、全部的意思；“*”只匹配到一个词。看完示例就能明白了。</p>
<h3 id="send-py代码分析"><a href="#send-py代码分析" class="headerlink" title="send.py代码分析"></a>send.py代码分析</h3><p>因为要进行路由键模糊匹配，所以交换机的类型要设置为topic，设置为topic，就可以使用#，*的匹配符号了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    <span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 定义交换机，设置类型为topic</span></div><div class="line">channel.exchange_declare(exchange=<span class="string">'messages'</span>, type=<span class="string">'topic'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 定义路由键</span></div><div class="line"><span class="comment"># 四种类型的消息</span></div><div class="line">routings = [<span class="string">'happy.work'</span>, <span class="string">'happy.life'</span>, <span class="string">'sad.work'</span>, <span class="string">'sad.life'</span>]</div><div class="line"></div><div class="line"><span class="comment"># 将消息依次发送到交换机，并设定路由键</span></div><div class="line"><span class="keyword">for</span> routing <span class="keyword">in</span> routings:</div><div class="line">    message = <span class="string">'%s message.'</span> % routing</div><div class="line">    channel.basic_publish(exchange=<span class="string">'messages'</span>,</div><div class="line">                          routing_key=routing,</div><div class="line">                          body=message)</div><div class="line">    print(message)</div><div class="line"></div><div class="line">connection.close()</div></pre></td></tr></table></figure>
<h3 id="receive-py代码分析"><a href="#receive-py代码分析" class="headerlink" title="receive.py代码分析"></a>receive.py代码分析</h3><p>类型要设定为topic就可以了。从命令行接收参数的功能稍微调整了一下，没有参数时报错退出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika, sys</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    <span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 定义交换机，设置类型为topic</span></div><div class="line">channel.exchange_declare(exchange=<span class="string">'messages'</span>, type=<span class="string">'topic'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 从命令行获取路由参数，如果没有，则报错退出</span></div><div class="line">routings = sys.argv[<span class="number">1</span>:]</div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> routings:</div><div class="line">    <span class="comment"># print(&gt;&gt; sys.stderr, "Usage: %s [routing_key]..." % (sys.argv[0],))</span></div><div class="line">    print(sys.stderr, <span class="string">"Usage: %s [routing_key]..."</span> % (sys.argv[<span class="number">0</span>],))</div><div class="line">    exit()</div><div class="line"></div><div class="line"><span class="comment"># 生成临时队列，并绑定到交换机上，设置路由键</span></div><div class="line">result = channel.queue_declare(exclusive=<span class="keyword">True</span>)</div><div class="line">queue_name = result.method.queue</div><div class="line"><span class="keyword">for</span> routing <span class="keyword">in</span> routings:</div><div class="line">    channel.queue_bind(exchange=<span class="string">'messages'</span>,</div><div class="line">                       queue=queue_name,</div><div class="line">                       routing_key=routing)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">" [x] Received %r"</span> % (body,))</div><div class="line"></div><div class="line"></div><div class="line">channel.basic_consume(callback, queue=queue_name, no_ack=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">print(<span class="string">' [*] Waiting for messages. To exit press CTRL+C'</span>)</div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure>
<h3 id="实验运行"><a href="#实验运行" class="headerlink" title="实验运行"></a>实验运行</h3><p>打开多个终端,分别传入不同的规则,观察结果<br>如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">python3 receive_topic.py <span class="string">"#"</span></div><div class="line">python3 receive_topic.py <span class="string">"happy.*"</span></div><div class="line">python3 receive_topic.py <span class="string">"*.work"</span></div></pre></td></tr></table></figure>
<h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p>1、发送信息时，如果不设置路由键，那么路由键设置为”*”的接收端是否能接收到消息？</p>
<blockquote>
<p>发送信息时，如果不设置路由键，默认是表示广播出去，理论上所有接收端都可以收到消息，但是笔者试了下，路由键设置为”*”的接收端收不到任何消息。</p>
<p>只有发送消息时，设置路由键为一个词，路由键设置为”*”的接收端才能收到消息。在这里，每个词使用”.”符号分开的。</p>
</blockquote>
<p>2、发送消息时，如果路由键设置为”..”，那么路由键设置为”#.*”的接收端是否能接收到消息？如果发送消息时，路由键设置为一个词呢？</p>
<blockquote>
<p>两种情况，笔者都测试过了，可以的。</p>
</blockquote>
<p>3、”a.*.#” 和”a.#”的区别</p>
<blockquote>
<ul>
<li><p>“a.#”只要字符串开头的一个词是a就可以了，比如a、a.haha、a.haha.haha。而这样的词是不行的，如abs、abc、abc.haha。</p>
</li>
<li><p>“a.<em>.#”必须要满足a.</em>的字符串才可以，比如a.、a.haha、a.haha.haha。而这样的词是不行的，如a。</p>
</li>
</ul>
</blockquote>
<h2 id="远程结果返回RPC"><a href="#远程结果返回RPC" class="headerlink" title="远程结果返回RPC"></a>远程结果返回RPC</h2><p>Remote Producre Call<br>处理方法描述：</p>
<blockquote>
<p>发送端在发送信息前，产生一个接收消息的临时队列，该队列用来接收返回的结果。其实在这里接收端、发送端的概念已经比较模糊了，因为发送端也同样要接收消息，接收端同样也要发送消息，所以这里笔者使用另外的示例来演示这一过程。</p>
</blockquote>
<h3 id="compute-py代码分析"><a href="#compute-py代码分析" class="headerlink" title="compute.py代码分析"></a>compute.py代码分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line"><span class="comment"># 连接rabbitmq服务器</span></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    host=<span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 定义队列</span></div><div class="line">channel.queue_declare(queue=<span class="string">'compute_queue'</span>)</div><div class="line">print(<span class="string">' [*] Waiting for n'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 将n值加1</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">increase</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">return</span> n + <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 定义接收到消息的处理方法</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">" [.] increase(%s)"</span> % (body,))</div><div class="line"></div><div class="line">    response = increase(int(body))</div><div class="line"></div><div class="line">    <span class="comment"># 将计算结果发送回控制中心</span></div><div class="line">    ch.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">                     routing_key=properties.reply_to,</div><div class="line">                     body=str(response))</div><div class="line">    ch.basic_ack(delivery_tag=method.delivery_tag)</div><div class="line"></div><div class="line"></div><div class="line">channel.basic_qos(prefetch_count=<span class="number">1</span>)</div><div class="line">channel.basic_consume(request, queue=<span class="string">'compute_queue'</span>)</div><div class="line"></div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure>
<h3 id="center-py代码分析"><a href="#center-py代码分析" class="headerlink" title="center.py代码分析"></a>center.py代码分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Center</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">            host=<span class="string">'10.211.55.10'</span>))</div><div class="line"></div><div class="line">        self.channel = self.connection.channel()</div><div class="line"></div><div class="line">        <span class="comment"># 定义接收返回消息的队列</span></div><div class="line">        result = self.channel.queue_declare(exclusive=<span class="keyword">True</span>)</div><div class="line">        self.callback_queue = result.method.queue</div><div class="line"></div><div class="line">        self.channel.basic_consume(self.on_response,</div><div class="line">                                   no_ack=<span class="keyword">True</span>,</div><div class="line">                                   queue=self.callback_queue)</div><div class="line"></div><div class="line">    <span class="comment"># 定义接收到返回消息的处理方法</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_response</span><span class="params">(self, ch, method, props, body)</span>:</span></div><div class="line">        self.response = body</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(self, n)</span>:</span></div><div class="line">        self.response = <span class="keyword">None</span></div><div class="line">        <span class="comment"># 发送计算请求，并声明返回队列</span></div><div class="line">        self.channel.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">                                   routing_key=<span class="string">'compute_queue'</span>,</div><div class="line">                                   properties=pika.BasicProperties(</div><div class="line">                                       reply_to=self.callback_queue,</div><div class="line">                                   ),</div><div class="line">                                   body=str(n))</div><div class="line">        <span class="comment"># 接收返回的数据</span></div><div class="line">        <span class="keyword">while</span> self.response <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            self.connection.process_data_events()</div><div class="line">        <span class="keyword">return</span> int(self.response)</div><div class="line"></div><div class="line"></div><div class="line">center = Center()</div><div class="line"></div><div class="line">print(<span class="string">" [x] Requesting increase(30)"</span>)</div><div class="line">response = center.request(<span class="number">30</span>)</div><div class="line">print(<span class="string">" [.] Got %r"</span> % (response,))</div></pre></td></tr></table></figure>
<p>上面代码定义了接收返回数据的队列和处理方法，并且在发送请求的时候将该队列赋值给<code>reply_to</code>，在计算节点代码中就是通过这个参数来获取返回队列的。</p>
<h2 id="相互关联编号correlation-id"><a href="#相互关联编号correlation-id" class="headerlink" title="相互关联编号correlation id"></a>相互关联编号correlation id</h2><p><code>correlation id</code>运行原理：</p>
<blockquote>
<p>控制中心发送计算请求时设置correlation id，而后计算节点将计算结果，连同接收到的correlation id一起返回，这样控制中心就能通过correlation id来标识请求。其实correlation id也可以理解为请求的唯一标识码。</p>
</blockquote>
<p>示例内容：</p>
<blockquote>
<p>控制中心开启多个线程，每个线程都发起一次计算请求，通过correlation id，每个线程都能准确收到相应的计算结果。</p>
</blockquote>
<h3 id="compute-py代码分析-1"><a href="#compute-py代码分析-1" class="headerlink" title="compute.py代码分析"></a>compute.py代码分析</h3><p>和上面相比，只需修改一个地方：</p>
<blockquote>
<p>将计算结果发送回控制中心时，增加参数correlation_id的设定，该参数的值其实是从控制中心发送过来的，这里只是再次发送回去。代码如下：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line"><span class="comment"># 连接rabbitmq服务器</span></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    host=<span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 定义队列</span></div><div class="line">channel.queue_declare(queue=<span class="string">'compute_queue'</span>)</div><div class="line">print(<span class="string">' [*] Waiting for n'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 将n值加1</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">increase</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">return</span> n + <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 定义接收到消息的处理方法</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(ch, method, props, body)</span>:</span></div><div class="line">    print(<span class="string">" [.] increase(%s)"</span> % (body,))</div><div class="line"></div><div class="line">    response = increase(int(body))</div><div class="line"></div><div class="line">    <span class="comment"># 将计算结果发送回控制中心，增加correlation_id的设定</span></div><div class="line">    ch.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">                     routing_key=props.reply_to,</div><div class="line">                     properties=pika.BasicProperties(correlation_id= \</div><div class="line">                                                         props.correlation_id),</div><div class="line">                     body=str(response))</div><div class="line">    ch.basic_ack(delivery_tag=method.delivery_tag)</div><div class="line"></div><div class="line"></div><div class="line">channel.basic_qos(prefetch_count=<span class="number">1</span>)</div><div class="line">channel.basic_consume(request, queue=<span class="string">'compute_queue'</span>)</div><div class="line"></div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure>
<h3 id="center-py代码分析-1"><a href="#center-py代码分析-1" class="headerlink" title="center.py代码分析"></a>center.py代码分析</h3><p>控制中心代码稍微复杂些，其中比较关键的有三个地方：</p>
<ul>
<li>使用python的uuid来产生唯一的correlation_id。</li>
<li>发送计算请求时，设定参数correlation_id。</li>
<li>定义一个字典来保存返回的数据，并且键值为相应线程产生的correlation_id。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika, threading, uuid</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 自定义线程类，继承threading.Thread</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, num)</span>:</span></div><div class="line">        super(MyThread, self).__init__()</div><div class="line">        self.func = func</div><div class="line">        self.num = num</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">" [x] Requesting increase(%d)"</span> % self.num)</div><div class="line">        response = self.func(self.num)</div><div class="line">        print(<span class="string">" [.] increase(%d)=%d"</span> % (self.num, response))</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 控制中心类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Center</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">            host=<span class="string">'10.211.55.10'</span>))</div><div class="line"></div><div class="line">        self.channel = self.connection.channel()</div><div class="line"></div><div class="line">        <span class="comment"># 定义接收返回消息的队列</span></div><div class="line">        result = self.channel.queue_declare(exclusive=<span class="keyword">True</span>)</div><div class="line">        self.callback_queue = result.method.queue</div><div class="line"></div><div class="line">        self.channel.basic_consume(self.on_response,</div><div class="line">                                   no_ack=<span class="keyword">True</span>,</div><div class="line">                                   queue=self.callback_queue)</div><div class="line"></div><div class="line">        <span class="comment"># 返回的结果都会存储在该字典里</span></div><div class="line">        self.response = &#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment"># 定义接收到返回消息的处理方法</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_response</span><span class="params">(self, ch, method, props, body)</span>:</span></div><div class="line">        self.response[props.correlation_id] = body</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(self, n)</span>:</span></div><div class="line">        corr_id = str(uuid.uuid4())     <span class="comment">#  产生 id</span></div><div class="line">        self.response[corr_id] = <span class="keyword">None</span></div><div class="line"></div><div class="line">        <span class="comment"># 发送计算请求，并设定返回队列和correlation_id</span></div><div class="line">        self.channel.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">                                   routing_key=<span class="string">'compute_queue'</span>,</div><div class="line">                                   properties=pika.BasicProperties(</div><div class="line">                                       reply_to=self.callback_queue,</div><div class="line">                                       correlation_id=corr_id,</div><div class="line">                                   ),</div><div class="line">                                   body=str(n))</div><div class="line">        <span class="comment"># 接收返回的数据</span></div><div class="line">        <span class="keyword">while</span> self.response[corr_id] <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            self.connection.process_data_events()</div><div class="line">        <span class="keyword">return</span> int(self.response[corr_id])</div><div class="line"></div><div class="line"></div><div class="line">center = Center()</div><div class="line"><span class="comment"># 发起5次计算请求</span></div><div class="line">nums = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]</div><div class="line">threads = []</div><div class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</div><div class="line">    threads.append(MyThread(center.request, num))</div><div class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</div><div class="line">    thread.start()</div><div class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</div><div class="line">    thread.join()</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.csdn.net/chenjiebin/article/details/8253433" target="_blank" rel="external">http://blog.csdn.net/chenjiebin/article/details/8253433</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Rabbitmq </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[密码学基础]]></title>
      <url>/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>平常用的登录密码不叫密码，是登录口令</p>
<a id="more"></a>
<p>密码有一个加密和解密的过程</p>
<p><strong>video:</strong> <a href="https://youtu.be/loJ62rvH8aE" target="_blank" rel="external">https://youtu.be/loJ62rvH8aE</a></p>
<h2 id="古典密码"><a href="#古典密码" class="headerlink" title="古典密码"></a>古典密码</h2><h3 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ABC</div><div class="line">CDE</div><div class="line">// 往后移动3位或者多位</div></pre></td></tr></table></figure>
<p>非常容易破解</p>
<h3 id="维吉尼亚密码"><a href="#维吉尼亚密码" class="headerlink" title="维吉尼亚密码"></a>维吉尼亚密码</h3><blockquote>
<p>不知道密钥是非常非常难破解的</p>
</blockquote>
<p><img src="https://i.imgur.com/OAm1EPk.jpg" alt="维吉尼亚密码"></p>
<ul>
<li>RSA<ul>
<li>公钥</li>
<li>私钥 </li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">明文--&gt; 公钥 --&gt; 密文</div><div class="line">密文--&gt; 私钥 --&gt; 明文</div></pre></td></tr></table></figure>
<p>基于<code>大数难分解</code><br>两个质数相乘</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">p1 = <span class="number">53</span></div><div class="line">p2 = <span class="number">59</span></div><div class="line">n = <span class="number">3127</span>  <span class="comment"># 53 * 59 = 3127</span></div><div class="line"><span class="comment"># 欧拉函数</span></div><div class="line">Φ(n)(p1<span class="number">-1</span>)*(p2<span class="number">-1</span>)= <span class="number">3016</span> <span class="comment"># fai 小写 φ</span></div><div class="line">e = <span class="number">3</span>   <span class="comment"># e 和欧拉函数互质 只要互质随便取</span></div><div class="line"><span class="comment"># 公钥是 n，e</span></div><div class="line">d = (k*φ(n)+<span class="number">1</span>)/e = <span class="number">2011</span> <span class="comment"># 私钥 (2**3016+1)/3 = 2011</span></div><div class="line"></div><div class="line"><span class="comment"># 验证</span></div><div class="line">m = <span class="number">89</span> <span class="comment"># 加密信息 </span></div><div class="line">c = (m**e)%n = <span class="number">1394</span>   <span class="comment"># 密文 (89**3)%3127 = 1394</span></div><div class="line">明文 = (x**d)%n = <span class="number">89</span> <span class="comment"># 明文 (1394**2011)%3127 = 89</span></div></pre></td></tr></table></figure>
<p>扩展:</p>
<p><strong>费马小定理</strong>来验证.</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[列表查找]]></title>
      <url>/%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE/</url>
      <content type="html"><![CDATA[<a id="more"></a>
<h1 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h1><ul>
<li>从列表第一个元素开始，顺序进行搜索，直到找到为止。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">li = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line">index(<span class="number">1</span>)    <span class="comment"># 顺序查找</span></div><div class="line"></div><div class="line"><span class="comment"># 顺序查找 ipython  O(n) 复杂度</span></div><div class="line"><span class="keyword">import</span> random</div><div class="line">n = <span class="number">10000</span></div><div class="line">li = list(range(n))</div><div class="line">random.shuffle(li)</div><div class="line">%timeit li.index(<span class="number">3200</span>)</div><div class="line"><span class="comment">#221 µs ± 11.1 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</span></div></pre></td></tr></table></figure>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><blockquote>
<p>只能用于有序列表</p>
</blockquote>
<p>从有序列表的候选区<code>data[0:n]</code>开始，通过对待查找的值与候选区中间值的比较，可以使候选区减少一半。<code>O(logn)</code> 复杂度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 二分查找</span></div><div class="line"><span class="comment"># 循环版本</span></div><div class="line"><span class="comment"># def bin_search(li,low,high):</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bin_search</span><span class="params">(li, val)</span>:</span></div><div class="line">    <span class="string">'''循环二分 时间复杂度 O(logn)'''</span></div><div class="line">    low = <span class="number">0</span></div><div class="line">    high = len(li) - <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> low &lt;= high:</div><div class="line">        mid = (low + high) // <span class="number">2</span></div><div class="line">        <span class="keyword">if</span> li[mid] == val:</div><div class="line">            <span class="keyword">return</span> mid</div><div class="line">        <span class="keyword">elif</span> li[mid] &lt; val:</div><div class="line">            low = mid + <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:  <span class="comment"># &gt;</span></div><div class="line">            high = mid - <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line"><span class="comment"># 5.6 µs ± 441 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)</span></div><div class="line"></div><div class="line"><span class="comment"># 递归版本  递归需要切换进出栈</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bin_search_rec</span><span class="params">(data_set,value,low,high)</span>:</span></div><div class="line">    <span class="string">''' 尾递归 和 非递归的效率基本一样 '''</span></div><div class="line">    <span class="keyword">if</span> low &lt;= high:</div><div class="line">        mid = (low+high) // <span class="number">2</span></div><div class="line">        <span class="keyword">if</span> data_set[mid] == value:</div><div class="line">            <span class="keyword">return</span> mid</div><div class="line">        <span class="keyword">elif</span> data_set[mid] &gt; value:</div><div class="line">            <span class="comment"># 尾递归不用切换出栈</span></div><div class="line">            <span class="keyword">return</span> bin_search_rec(data_set,value,low,mid<span class="number">-1</span>)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> bin_search_rec(data_set,value,mid+<span class="number">1</span>,high)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span></div><div class="line"></div><div class="line"><span class="comment"># %timeit l1.index(3200)</span></div><div class="line"><span class="comment"># l1.sort()   # 排序</span></div><div class="line"><span class="comment"># %timeit bin_search(l1,3200)</span></div><div class="line">print(bin_search(l1,<span class="number">4000</span>))</div></pre></td></tr></table></figure>
<p>刷题：Letcode<br><a href="https://leetcode.com/problems/search-for-a-range/?tab=Description" target="_blank" rel="external">34. Search for a Range (二分查找升级版)</a><br><a href="https://leetcode.com/problems/two-sum/?tab=Description" target="_blank" rel="external">1. Two Sum</a></p>
<h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><p>1  <a href="https://leetcode.com/problems/search-for-a-range/?tab=Description" target="_blank" rel="external">34. Search for a Range (二分查找升级版)</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bin_search</span><span class="params">(li, val)</span>:</span></div><div class="line">    <span class="string">'''循环二分 时间复杂度 O(logn)'''</span></div><div class="line">    low = <span class="number">0</span></div><div class="line">    high = len(li) - <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> low &lt;= high:</div><div class="line">        mid = (low + high) // <span class="number">2</span></div><div class="line">        <span class="keyword">if</span> li[mid] == val:</div><div class="line">            a = mid</div><div class="line">            b = mid</div><div class="line">            <span class="keyword">while</span> li[a] = value <span class="keyword">and</span> a &gt;= <span class="number">1</span>:</div><div class="line">                a -= <span class="number">1</span></div><div class="line">            <span class="keyword">while</span> li[b] = value <span class="keyword">and</span> b &lt; len(li):    <span class="comment"># b &lt;= len(li) - 1</span></div><div class="line">                b += <span class="number">1</span></div><div class="line">            <span class="keyword">return</span> (a+<span class="number">1</span>,b<span class="number">-1</span>)</div><div class="line">        <span class="keyword">elif</span> li[mid] &lt; val:</div><div class="line">            low = mid + <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:  <span class="comment"># &gt;</span></div><div class="line">            high = mid - <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">None</span></div></pre></td></tr></table></figure>
<p>2 . <a href="https://leetcode.com/problems/two-sum/?tab=Description" target="_blank" rel="external">1. Two Sum</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_sum</span><span class="params">(nums, target)</span>:</span></div><div class="line">    l = len(nums)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,l):</div><div class="line">            print(nums[i],nums[j])</div><div class="line">            <span class="keyword">if</span> nums[i] + nums[j] == target:</div><div class="line">                <span class="keyword">return</span> (i,j)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">            </div><div class="line">print(two_sum([<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>],<span class="number">9</span>))</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bin_search</span><span class="params">(data_set, value)</span>:</span></div><div class="line">    low = <span class="number">0</span></div><div class="line">    high = len(data_set) - <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> low &lt;= high:</div><div class="line">        mid = (low + high) // <span class="number">2</span></div><div class="line">        <span class="keyword">if</span> data_set[mid] == value:</div><div class="line">            <span class="keyword">return</span> mid</div><div class="line">        <span class="keyword">elif</span> data_set[mid] &gt; value:</div><div class="line">            high = mid - <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            low = mid + <span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_sum_2</span><span class="params">(li, target)</span>:</span></div><div class="line">    li.sort()</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(li)):</div><div class="line">        b = target - li[i]</div><div class="line">        j = bin_search(li, b)</div><div class="line">        <span class="keyword">if</span> j != <span class="keyword">None</span> <span class="keyword">and</span> i != j:</div><div class="line">            <span class="keyword">return</span> i, j</div><div class="line"></div><div class="line">print(two_sum_2([<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>], <span class="number">14</span>))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_sum_3</span><span class="params">(li, target)</span>:</span></div><div class="line">    li.sort()   <span class="comment"># nlogn</span></div><div class="line">    i = <span class="number">0</span></div><div class="line">    j = len(li) - <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> i&lt;j:</div><div class="line">        sum = li[i]+li[j]</div><div class="line">        <span class="keyword">if</span> sum &gt; target:</div><div class="line">            j-=<span class="number">1</span></div><div class="line">        <span class="keyword">elif</span> sum &lt; target:</div><div class="line">            i+=<span class="number">1</span></div><div class="line">        <span class="keyword">else</span>: <span class="comment">#sum==target</span></div><div class="line">            <span class="keyword">return</span> (i,j)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">None</span></div></pre></td></tr></table></figure>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p><a href="https://leetcode.com/problems/two-sum/?tab=Description" target="_blank" rel="external">1. Two Sum</a> 如果是 3 个数 就把第一个数固定, 后面的列表用 two_sum_3 来计算</p>
<blockquote>
<p>如果这样时间复杂度<br>nlogn + n²<br>最终的时间复杂度是 n²</p>
</blockquote>
<p>如果用二分查找, 就需要先排序, 定住两个数, 排序(nlogn) + <code>定住两个数(n²)</code> <code>二分(n²logn)</code> 最终的复杂度是 <code>n²logn</code></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[时间复杂度与空间复杂度]]></title>
      <url>/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      <content type="html"><![CDATA[<p>算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。用来评估算法运行效率的单位。<br><a id="more"></a></p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><blockquote>
<p>时间复杂度是用来估计算法运行时间的一个式子（单位） T(n) = O(n^2)</p>
</blockquote>
<p>按数量级递增排列，常见的时间复杂度有：常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n2)，立方阶O(n3),…， k次方阶O(nk),指数阶O(2n)。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。</p>
<ul>
<li>一般来说,时间复杂度高的算法比复杂度底的算法慢.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">'Hello World'</span>)    <span class="comment"># O(1)</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):    <span class="comment"># O(n)</span></div><div class="line">    print(<span class="string">'Hello World'</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):    <span class="comment"># O(n²)</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">        print(<span class="string">'Hello World'</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):    <span class="comment"># O(n³)</span></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> rnage(n):</div><div class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</div><div class="line">            print(<span class="string">'Hello World'</span>)</div></pre></td></tr></table></figure>
<h2 id="如何一眼判断时间复杂度"><a href="#如何一眼判断时间复杂度" class="headerlink" title="如何一眼判断时间复杂度"></a>如何一眼判断时间复杂度</h2><ul>
<li>循环减半的过程 –&gt;<code>O(logn)</code></li>
<li>几次循环就是<code>n</code>的几次方的复杂度</li>
</ul>
<h2 id="时间复杂度排序"><a href="#时间复杂度排序" class="headerlink" title="时间复杂度排序"></a>时间复杂度排序</h2><ul>
<li>常见的时间复杂度</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n²)&lt;O(n²logn)&lt;O(n³)</div></pre></td></tr></table></figure>
<ul>
<li>不常见的时间复杂度</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">O(n!) O(2n) O(nn) …</div></pre></td></tr></table></figure>
<pre><code>几秒钟/O(1)
几分钟/O(n)
几小时/O(n²) // 2 平方
高级： 函数 见进阶
</code></pre><h2 id="判断时间复杂度"><a href="#判断时间复杂度" class="headerlink" title="判断时间复杂度"></a>判断时间复杂度</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1    O(1)  时间复杂度</span></div><div class="line">print(<span class="string">'Hello World'</span>)</div><div class="line">print(<span class="string">'Hello Python'</span>)</div><div class="line">print(<span class="string">'Hello Algorithm'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 2    O(n²) 时间复杂度</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">    print(<span class="string">'Hello World'</span>)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">        print(<span class="string">'Hello World'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 3    O(n²) 时间复杂度</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</div><div class="line">        print(<span class="string">'Hello World'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 以2为底64的对数</span></div><div class="line">n = <span class="number">64</span></div><div class="line"><span class="keyword">while</span> n &gt; <span class="number">1</span>:</div><div class="line">    print(n)</div><div class="line">    n = n // <span class="number">2</span></div><div class="line"><span class="comment"># 时间复杂度 O(log2n) / O(logn)</span></div><div class="line"><span class="comment"># 每次少一半</span></div></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/A0jhF7s.jpg" alt=""></p>
<h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><blockquote>
<p>用来评估算法内存占用大小的式子    S(n) = O(n^2) 表示内存占用<br>时间复杂度比空间复杂度更重要</p>
</blockquote>
<ul>
<li>空间换时间</li>
</ul>
<p>一个列表就是 O(n)<br>二维列表复杂度就是 O(n²)<br>…</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Charles: Response 出现乱码]]></title>
      <url>/Charles-Response-%E4%B9%B1%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>使用 Charles 抓 https 包的时候, Reponse 出现乱码<br><a id="more"></a></p>
<p>系统环境: MAC<br>软件版本: 4.2.1<br>浏览器: Google Chrome</p>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>没有信任 Charles 的证书,信任 Charles 的证书就好了</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><h2 id="安装-Charles-证书"><a href="#安装-Charles-证书" class="headerlink" title="安装 Charles 证书"></a>安装 Charles 证书</h2><p><code>Help</code> &gt; <code>SSL Proxying</code> &gt; <code>Install Charles Root Certificate</code></p>
<p><img src="https://i.imgur.com/JavIfh7.jpg" alt="安装 Charles 证书"></p>
<h2 id="信任-Charles-证书"><a href="#信任-Charles-证书" class="headerlink" title="信任 Charles 证书"></a>信任 Charles 证书</h2><p>安装完成后会自动弹出钥匙串,找到 Charles 的证书信任即可</p>
<p><img src="https://i.imgur.com/gATUIEf.jpg" alt="信任 Charles 证书1"></p>
<p><img src="https://i.imgur.com/4xU3IVQ.jpg" alt="信任 Charles 证书2"></p>
<h2 id="Charles-设置"><a href="#Charles-设置" class="headerlink" title="Charles 设置"></a>Charles 设置</h2><p><code>Proxy</code> &gt; <code>SSL Proxying Settings</code></p>
<p><img src="https://i.imgur.com/BqoK9Hy.jpg" alt="Charles 设置"></p>
<h2 id="ok"><a href="#ok" class="headerlink" title="ok"></a>ok</h2><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>发布这篇文章的时候问题已经被解决,但是没有问题截图,有时间的话再补上.</p>
]]></content>
      
        
        <tags>
            
            <tag> Charles </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
