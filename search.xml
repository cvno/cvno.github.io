<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Phantomjs]]></title>
      <url>/2018/01/Phantomjs.html</url>
      <content type="html"><![CDATA[<h1 id="无法打开https网站"><a href="#无法打开https网站" class="headerlink" title="无法打开https网站"></a>无法打开https网站</h1><p>用 <code>phantomjs</code> 自动登陆并爬取一些数据，发现爬取 <code>https</code> 类型的网站的时候无法正常操作</p>
<p><code>Phantomjs</code>中有个<code>service_args</code>参数可以忽略https错误</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">driver = webdriver.PhantomJS(desired_capabilities=cap, service_args=[<span class="string">'--ignore-ssl-errors=true'</span>])</div></pre></td></tr></table></figure>
<h1 id="获取-cookie"><a href="#获取-cookie" class="headerlink" title="获取 cookie"></a>获取 cookie</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</div><div class="line"><span class="keyword">import</span> pickle</div><div class="line">driver=webdriver.PhantomJS()</div><div class="line">driver.get(url)  <span class="comment">#此处url填写需要访问的地址</span></div><div class="line"><span class="comment"># 获得 cookie信息</span></div><div class="line">cookie_list = driver.get_cookies()</div><div class="line"><span class="keyword">print</span> (cookie_list)</div><div class="line">cookie_dict = &#123;&#125;</div><div class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> cookie_list:</div><div class="line">    <span class="comment">#写入文件</span></div><div class="line">    f = open(<span class="string">'cookie.txt'</span>,<span class="string">'wb+'</span>)</div><div class="line">    pickle.dump(cookie, f)</div><div class="line">    f.close()</div><div class="line">　　　</div><div class="line">cookie_dict[cookie[<span class="string">'name'</span>]] = cookie[<span class="string">'value'</span>]</div></pre></td></tr></table></figure>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><a href="http://www.cnblogs.com/fly-kaka/p/6656196.html" target="_blank" rel="external">http://www.cnblogs.com/fly-kaka/p/6656196.html</a></li>
<li><a href="https://www.cnblogs.com/Jacck/p/7675284.html" target="_blank" rel="external">https://www.cnblogs.com/Jacck/p/7675284.html</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Phantomjs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式]]></title>
      <url>/2018/01/design-patterns.html</url>
      <content type="html"><![CDATA[<h1 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h1><p>Christopher Alexander:“每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样你就能一次又一次地使用该方案而不必做重复劳动。”</p>
<p>每一个设计模式系统地命名、解释和评价了面向对象系统中一个重要的和重复出现的设计。</p>
<p>GoF（Gang of Four）</p>
<p>设计模式四个基本要素：模式名称、问题、解决方案、效果</p>
<p>面向对象的三大特性: </p>
<ul>
<li>封装：把数据和函数包装在类里 类的边界限制了一些外界的访问</li>
<li>继承：复用</li>
<li>多态：多态语言</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 封装</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.__test = x <span class="comment"># 私有变量</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gettest</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.__test</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">settest</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.__test = x</div><div class="line"></div><div class="line"><span class="comment"># 继承：复用</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">    <span class="comment"># override 重写 覆写</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">settest</span><span class="params">(self)</span>:</span></div><div class="line">        self.__test = x + <span class="number">1</span></div><div class="line"></div><div class="line"><span class="comment"># 多态 python 是一种多态语言</span></div><div class="line"><span class="comment"># 一个函数的多种表现</span></div><div class="line"></div><div class="line"><span class="comment"># 重载 python 不支持</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(x, y)</span>:</span></div><div class="line">    <span class="keyword">return</span> x+y</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(x, y, z)</span>:</span></div><div class="line">    <span class="keyword">return</span> x+y+z</div><div class="line"></div><div class="line">test(<span class="number">2</span>,<span class="number">3</span>)</div><div class="line">test(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</div></pre></td></tr></table></figure>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>一种特殊的类（抽象类），声明了若干方法，要求继承该接口的类必须实现这些方法。目的就是对外保持一致</p>
<p><strong>作用：</strong>限制继承接口的类的方法的名称及调用方式；隐藏了类的内部实现。</p>
<p>接口就是一种抽象的基类（父类），限制继承它的类必须实现接口中定义的某些方法</p>
<p>其实就是限制程序员的东西, 不能乱写, 按照定的规范去写</p>
<p><a href="https://gist.github.com/cvno/7f92b3a09c119f30d02460817f3de9cf#file-intergace-py" target="_blank" rel="external">示例</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 接口的两种写法</span></div><div class="line"><span class="comment"># 1.</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">raise</span> NotImplementedError <span class="comment"># 限制  子类必须实现</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'B.test'</span>)</div><div class="line"><span class="comment"># 2. 抽象类不能实例化        </span></div><div class="line"><span class="keyword">from</span> abs <span class="keyword">import</span> bastractmethod,ABCMeta  </div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(metaclass=ABCMeta)</span>:</span>    <span class="comment"># 抽象类</span></div><div class="line"><span class="meta">    @abstractmethod </span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span>    <span class="comment"># 抽象方法   必须在子类实现</span></div><div class="line">        <span class="keyword">raise</span> NotImplementedError <span class="comment"># 限制  子类必须实现</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'B.test'</span>)</div><div class="line"></div><div class="line">a = B() <span class="comment"># 不能实例化</span></div><div class="line">b = C() <span class="comment"># 可以实例化</span></div></pre></td></tr></table></figure>
<h1 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h1><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</p>
<h2 id="里氏（Liskov）替换原则"><a href="#里氏（Liskov）替换原则" class="headerlink" title="里氏（Liskov）替换原则"></a>里氏（Liskov）替换原则</h2><p>所有引用基类（父类）的地方必须能透明地使用其子类的对象。功能保持一致</p>
<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。换言之，<strong>要针对接口（抽象）编程，而不是针对实现（实例）编程。</strong></p>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。（多继承）<a href="https://gist.github.com/cvno/7f92b3a09c119f30d02460817f3de9cf#file-0x02-py" target="_blank" rel="external">示例</a></p>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>一个软件实体应当尽可能少地与其他实体发生相互作用。<strong>解耦</strong></p>
<p><em>五大原则没有这个迪米特法则</em></p>
<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。 一个类（class）只干一件事</p>
<ul>
<li>合成复用原则</li>
</ul>
<p>尽量使用合成／聚合的方式，而不是继承。<a href="https://gist.github.com/cvno/7f92b3a09c119f30d02460817f3de9cf#file-0x03-py" target="_blank" rel="external">示例</a></p>
<p><code>合成</code> <code>复用</code> <code>继承</code> 的使用分情况而定</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>定义一个用于创建对象的接口（工厂接口），让子类决定实例化哪一个产品类。<br><strong>角色：</strong></p>
<ul>
<li>抽象工厂角色（Creator）</li>
<li>具体工厂角色（Concrete Creator）</li>
<li>抽象产品角色（Product）</li>
<li>具体产品角色（Concrete Product）</li>
</ul>
<p>工厂方法模式相比简单工厂模式将每个具体产品都对应了一个具体工厂。</p>
<p><a href="https://gist.github.com/cvno/7f92b3a09c119f30d02460817f3de9cf#file-factory_method-py" target="_blank" rel="external">示例</a></p>
<p><img src="https://i.imgur.com/pgobtQV.jpg" alt="工厂方法模式"></p>
<p><strong>适用场景：</strong></p>
<ul>
<li>需要生产多种、大量复杂对象的时候</li>
<li>需要降低耦合度的时候</li>
<li>当系统中的产品种类需要经常扩展的时候</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>每个具体产品都对应一个具体工厂类，不需要修改工厂类代码</li>
<li>隐藏了对象创建的实现细节</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>每增加一个具体产品类，就必须增加一个相应的具体工厂类</li>
</ul>
<h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><p>不直接向客户端暴露对象创建的实现细节，而是通过一个工厂类来负责创建产品类的实例。<br><strong>角色：</strong></p>
<ul>
<li>工厂角色（Creator）</li>
<li>抽象产品角色（Product）</li>
<li>具体产品角色（Concrete Product）</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>隐藏了对象创建的实现细节</li>
<li>客户端不需要修改代码</li>
</ul>
<p><strong>缺点：</strong><br>违反了单一职责原则，将创建逻辑集中到一个工厂类里<br>当添加新产品时，需要修改工厂类代码，违反了开闭原则</p>
<p><a href="https://gist.github.com/cvno/7f92b3a09c119f30d02460817f3de9cf#file-factory-py" target="_blank" rel="external">示例</a></p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>比如: 数据库连接</p>
<p>好的单列模式会写一个基类（<a href="https://gist.github.com/cvno/7f92b3a09c119f30d02460817f3de9cf#file-singleton-py" target="_blank" rel="external">示例</a>）</p>
<p>单例（Singleton）: 保证一个类只有一个实例，并提供一个访问它的全局访问点。</p>
<p>适用场景:</p>
<ul>
<li>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时</li>
</ul>
<p>优点:</p>
<ul>
<li>对唯一实例的受控访问</li>
<li>单例相当于全局变量，但防止了命名空间被污染</li>
</ul>
<p>与单例模式功能相似的概念：全局变量、静态变量（方法）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></div><div class="line">    test = <span class="number">0</span></div><div class="line">    </div><div class="line">A.test = <span class="number">1</span></div><div class="line"></div><div class="line">a = A()</div><div class="line">print(a.test)</div><div class="line"><span class="comment"># a.test = 1 # 对象变量的修改不会影响到类的静态变量</span></div><div class="line"></div><div class="line">b = A()</div><div class="line">print(b.test)</div></pre></td></tr></table></figure>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>定义一个工厂类接口，让工厂子类来创建一系列相关或相互依赖的对象。<br><strong>例：</strong>生产一部手机，需要<code>手机壳</code>、<code>CPU</code>、<code>操作系统</code>三类对象进行组装，其中每类对象都有不同的种类。对每个具体工厂，分别生产一部手机所需要的三个对象。</p>
<p><strong>角色：</strong></p>
<p><a href="https://gist.github.com/cvno/7f92b3a09c119f30d02460817f3de9cf#file-abstract_factory-py" target="_blank" rel="external">示例</a></p>
<ul>
<li>抽象工厂角色（Creator）</li>
<li>具体工厂角色（Concrete Creator）</li>
<li>抽象产品角色（Product）</li>
<li>具体产品角色（Concrete Product）</li>
<li>客户端（Client)</li>
</ul>
<p>相比工厂方法模式，抽象工厂模式中的每个具体工厂都生产一套产品。</p>
<p><img src="https://i.imgur.com/fW3OyP8.jpg" alt="抽象工厂模式"></p>
<p>适用场景：</p>
<ul>
<li>系统要独立于产品的创建与组合时</li>
<li>强调一系列相关的产品对象的设计以便进行联合使用时</li>
<li>提供一个产品类库，想隐藏产品的具体实现时</li>
</ul>
<p>优点：</p>
<ul>
<li>将客户端与类的具体实现相分离</li>
<li>每个工厂创建了一个完整的产品系列，使得易于交换产品系列</li>
<li>有利于产品的一致性（即产品之间的约束关系）</li>
</ul>
<p>缺点：</p>
<ul>
<li>难以支持新种类的（抽象）产品</li>
</ul>
<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p><strong>角色：</strong></p>
<ul>
<li>抽象建造者（Builder）</li>
<li>具体建造者（Concrete Builder）</li>
<li>指挥者（Director）</li>
<li>产品（Product）</li>
</ul>
<p>建造者模式与抽象工厂模式相似，也用来创建复杂对象。主要区别是建造者模式着重一步步构造一个复杂对象，而抽象工厂模式着重于多个系列的产品对象。</p>
<p><img src="https://i.imgur.com/z8IFFM0.jpg" alt="建造者模式"></p>
<p><a href="https://gist.github.com/cvno/7f92b3a09c119f30d02460817f3de9cf#file-builder-py" target="_blank" rel="external">示例</a></p>
<p>适用场景：</p>
<ul>
<li>当创建复杂对象的算法（Director）应该独立于该对象的组成部分（Builder）时</li>
<li>当构造过程允许被构造的对象有不同的表示时（不同Builder）。</li>
</ul>
<p>优点：</p>
<ul>
<li>隐藏了一个产品的内部结构和装配过程</li>
<li>将构造代码与表示代码分开</li>
<li>可以对构造过程进行更精细的控制</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="https://i.imgur.com/Drh1aHu.jpg" alt="小结"></p>
<p>使用 Abstract Factory（抽象工厂）、<del>Prototype（原型模式）</del> 或 Builder（建造者） 的设计甚至比使用 Factory Method（工厂方法） 的那些设计更灵活，但它们也更加复杂。通常，设计以使用 Factory Method（简单工厂也可以） 开始，并且当设计者发现需要更大的灵活性时，设计便会向其他创建型模式演化。当你在设计标准之间进行权衡的时候，了解多个模式可以给你提供更多的选择余地。</p>
<p><strong>也就是说，不用一开始就选好模式，先从简单的模式开始，如果需要频繁的改代码，就用工厂方法，等等…… 一步一步递进</strong></p>
<p>依赖于继承的创建型模式：工厂方法模式<br>依赖于组合的创建性模式：抽象工厂模式、创建者模式</p>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br>角色：</p>
<ul>
<li>目标接口（Target）</li>
<li>待适配的类（Adaptee）</li>
<li>适配器（Adapter）(套壳)</li>
</ul>
<p>两种实现方式：</p>
<ul>
<li>类适配器：使用多继承</li>
<li>对象适配器：使用组合</li>
</ul>
<p><a href="https://gist.github.com/cvno/7f92b3a09c119f30d02460817f3de9cf#file-singleton-py" target="_blank" rel="external">示例</a></p>
<p><img src="https://i.imgur.com/JOPSOGt.jpg" alt="适配器模式"></p>
<p><strong>适用场景：</strong><br>想使用一个已经存在的类，而它的接口不符合你的要求<br>（对象适配器）想使用一些已经存在的子类，但不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</p>
<p><img src="https://i.imgur.com/59PiTXw.jpg" alt=""></p>
<p>类适配器和对象适配器有不同的权衡。</p>
<p><strong>类适配器</strong></p>
<ul>
<li>用一个具体的 Adapter 类对 Adaptee 和 Target 进行匹配。结果是当我们想要匹配一个类以及所有它的子类时，类 Adapter 将不能胜任工作。</li>
<li>使得 Adapter 可以重定义 Adaptee 的部分行为，因为 Adapter 是 Adaptee 的一个子类。</li>
<li>仅仅引入（继承）了一个对象，并不需要额外的指针以间接得到 adaptee。</li>
</ul>
<p><strong>对象适配器则</strong></p>
<ul>
<li>允许一个 Adapter 与多个 Adaptee-即 Adaptee 本身以及它的所有子类（如果有子类的话）一同时工作。Adapter 也可以一次给所有的 Adaptee 添加功能。</li>
<li>使得重定义 Adaptee 的行为比较困难。这就需要生成 Adaptee 的子类并且使得 Adapter 引用这个子类而不是引用 Adaptee 本身。</li>
</ul>
<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>二叉树的结构<br><strong>角色：</strong></p>
<ul>
<li>抽象组件（Component）</li>
<li>叶子组件（Leaf）</li>
<li>复合组件（Composite）</li>
<li>客户端（Client）</li>
</ul>
<p><a href="https://gist.github.com/cvno/7f92b3a09c119f30d02460817f3de9cf#file-composite-py" target="_blank" rel="external">示例</a></p>
<p><img src="https://i.imgur.com/PFRWJ87.jpg" alt="组合模式"></p>
<p><strong>适用场景：</strong></p>
<ul>
<li>表示对象的“部分-整体”层次结构（特别是结构是递归的）</li>
<li>希望用户忽略组合对象与单个对象的不同，用户统一地使用组合结构中的所有对象</li>
</ul>
<p>优点：</p>
<ul>
<li>定义了包含基本对象和组合对象的类层次结构</li>
<li>简化客户端代码，即客户端可以一致地使用组合对象和单个对象</li>
<li>更容易增加新类型的组件</li>
</ul>
<p>缺点：</p>
<ul>
<li>很难限制组合中的组件</li>
</ul>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>为其他对象提供一种代理以控制对这个对象的访问。<br><strong>角色：</strong></p>
<ul>
<li>抽象实体（Subject）</li>
<li>实体（RealSubject）</li>
<li>代理（Proxy）</li>
</ul>
<p><a href="https://gist.github.com/cvno/7f92b3a09c119f30d02460817f3de9cf#file-daili-py" target="_blank" rel="external">示例</a></p>
<p><strong>适用场景：</strong></p>
<ul>
<li>远程代理：为远程的对象提供代理</li>
<li>虚代理：根据需要创建很大的对象</li>
<li>保护代理：控制对原始对象的访问，用于对象有不同访问权限时</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>远程代理：可以隐藏对象位于远程地址空间的事实</li>
<li>虚代理：可以进行优化，例如根据要求创建对象</li>
<li>保护代理：允许在访问一个对象时有一些附加的内务处理</li>
</ul>
<p><img src="https://i.imgur.com/TCdmacp.jpg" alt="代理模式"></p>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p>
<p><strong>角色：</strong></p>
<ul>
<li>抽象处理者（Handler）</li>
<li>具体处理者（ConcreteHandler）</li>
<li>客户端（Client）</li>
</ul>
<p><a href="https://gist.github.com/cvno/7f92b3a09c119f30d02460817f3de9cf#file-chain_of_responsibility-py" target="_blank" rel="external">示例</a></p>
<p><strong>例：</strong><br>请假部门批准：leader -&gt; 部门经理 -&gt; 总经理<br>Javascript事件浮升机制</p>
<p><img src="https://i.imgur.com/o9AR9Wq.jpg" alt="责任链模式"></p>
<p><strong>适用场景：</strong></p>
<ul>
<li>有多个对象可以处理一个请求，哪个对象处理由运行时决定</li>
<li>在不明确接收者的情况下，向多个对象中的一个提交一个请求</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>降低耦合度：一个对象无需知道是其他哪一个对象处理其请求</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>请求不保证被接收：链的末端没有处理或链配置错误</li>
</ul>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示</p>
<p>实现方法：<code>__iter__</code>、<code>__next__</code></p>
<p><a href="https://gist.github.com/cvno/7f92b3a09c119f30d02460817f3de9cf#file-iterator-py" target="_blank" rel="external">示例</a></p>
<p>适用于封装数据结构,这种结构类似与列表,或树,封装数据类型,不让外人知道是怎么存的</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新。观察者模式又称“发布-订阅”模式</p>
<p><strong>角色：</strong></p>
<ul>
<li>抽象主题（Subject）</li>
<li>具体主题（ConcreteSubject）——发布者</li>
<li>抽象观察者（Observer）</li>
<li>具体观察者（ConcreteObserver）——订阅者</li>
</ul>
<p><a href="https://gist.github.com/cvno/7f92b3a09c119f30d02460817f3de9cf#file-iterator-py" target="_blank" rel="external">示例</a></p>
<p><img src="https://i.imgur.com/P23pGAX.jpg" alt="观察者模式"></p>
<p><strong>适用场景：</strong></p>
<ul>
<li>当一个抽象模型有两方面，其中一个方面依赖于另一个方面。将这两者封装在独立对象中以使它们可以各自独立地改变和复用。</li>
<li>当对一个对象的改变需要同时改变其它对象，而不知道具体有多少对象有待改变。</li>
<li>当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之，你不希望这些对象是紧密耦合的。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>目标和观察者之间的耦合最小</li>
<li>支持广播通信</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>多个观察者之间互不知道对方存在，因此一个观察者对主题的修改可能造成错误的更新。</li>
</ul>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p>
<p><strong>角色：</strong></p>
<ul>
<li>抽象策略（Strategy）</li>
<li>具体策略（ConcreteStrategy）</li>
<li>上下文（Context）</li>
</ul>
<p><a href="https://gist.github.com/cvno/7f92b3a09c119f30d02460817f3de9cf#file-strategy-py" target="_blank" rel="external">示例</a></p>
<p><strong>适用场景：</strong></p>
<ul>
<li>许多相关的类仅仅是行为有异</li>
<li>需要使用一个算法的不同变体</li>
<li>算法使用了客户端无需知道的数据</li>
<li>一个类中的多种行为以多个条件语句的形式存在，可以将这些行为封装如不同的策略类中。</li>
</ul>
<p><img src="https://i.imgur.com/T3L7jr1.jpg" alt="策略模式"></p>
<p><strong>优点：</strong></p>
<ul>
<li>定义了一系列可重用的算法和行为</li>
<li>消除了一些条件语句</li>
<li>可以提供相同行为的不同实现</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>客户必须了解不同的策略</li>
<li>策略与上下文之间的通信开销</li>
<li>增加了对象的数目</li>
</ul>
<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p><strong>角色：</strong></p>
<ul>
<li>抽象类（AbstractClass）：定义抽象的原子操作（钩子操作）；实现一个模板方法作为算法的骨架。</li>
<li>具体类（ConcreteClass）：实现原子操作</li>
</ul>
<p><a href="https://gist.github.com/cvno/7f92b3a09c119f30d02460817f3de9cf#file-template_method-py" target="_blank" rel="external">示例</a></p>
<p><img src="https://i.imgur.com/GX4zMoi.jpg" alt="模板方法模式"></p>
<p><strong>适用场景：</strong></p>
<ul>
<li>一次性实现一个算法的不变的部分</li>
<li>各个子类中的公共行为应该被提取出来并集中到一个公共父类中以避免代码重复</li>
<li>控制子类扩展</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><em>设计模式可互相嵌套, 如: 策略模式的算法写成单例模式比较好; </em></p>
<ul>
<li><p>创建型模式都是对象怎么创建</p>
</li>
<li><p>结构型模式是怎么把类组织在一起</p>
<ol>
<li>适配器模式类写坏了, 和其他类不适配</li>
<li>组合模式是几个类怎么表现一样, 叶子节点和复合节点怎么表现一样</li>
<li>代理模式提供几种代理, 以控制加权限, 或加内容</li>
</ol>
</li>
<li><p>行为型模式是怎么做事, 方法函数怎么做</p>
<ol>
<li>责任链模式, 一个一个传下去</li>
<li>迭代器模式, 一个一个拿元素处理 （应用面狭小）</li>
<li>观察者模式, 一个一个更新</li>
</ol>
</li>
</ul>
<h2 id="加深理解"><a href="#加深理解" class="headerlink" title="加深理解"></a>加深理解</h2><p>工厂模式是什么？有什么用？怎么用？什么好处？</p>
<p><del>哪个工厂模式,简单工厂模式，工厂方法模式还是抽象工厂模式。</del></p>
<p><strong>简单工厂模式</strong>就是把所有产品的创建细节都隐藏在一个工厂里，也就是把要创建的这个类的对象的创建细节隐藏在工厂里，这就叫简单工厂。</p>
<p><strong>问题：</strong>因为这个类所有的产品创建细节都隐藏在一个工厂里，那如果要加产品，就需要改工厂的代码，这个就不符合开闭原则。简单工厂的一个类，承载了很多产品的创建，所以不符合<strong>单一职责原则</strong>。就需要从简单工厂升级到工厂方法模式。</p>
<hr>
<p><strong>工厂方法模式</strong>就是是一个产品，一种产品的创建过程，它隐藏在一个单独的工厂里，每一个产品对应一个工厂，同样, 产品的创建过程隐藏在这个工厂里，</p>
<p><strong>需要的注意的是：</strong>有多个工厂的时候，我们需要一个工厂的接口<del>–<strong>抽象工厂</strong>，</del>也就是工厂方法模式。工厂方法模式还是把对象的创建过程隐藏在了工厂里。它和之前简单工厂相比的话，一个产品对应一个工厂，加新产品的话，只需要再加一个工厂就可以了，不需要修改工厂代码。缺点就是加一个产品需要添加两类。类写的比较多，这是工厂方法模式。</p>
<hr>
<p><strong>抽象工厂模式</strong>和跟前面的两个就不太一样，它是生产一个产品系列，或者叫一套产品，生产一套产品的时候，一个工厂负责生产一套。<br>好处: </p>
<ul>
<li>第一，把对象的创建细节隐藏在工厂里, </li>
<li>第二, 可以保持产品系列的一致性，也就是加约束。</li>
</ul>
<p>比如：苹果的IOS只能加苹果的手机壳，苹果CPU, 这就叫一致性，小产品之间的约束。</p>
<h2 id="设计模式大全"><a href="#设计模式大全" class="headerlink" title="设计模式大全"></a>设计模式大全</h2><ul>
<li>创建型模式：<ol>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
<li>创建者模式</li>
<li>原型模式</li>
<li>单例模式</li>
</ol>
</li>
<li>结构型模式<ol>
<li>适配器模式</li>
<li>桥模式</li>
<li>组合模式</li>
<li>装饰模式</li>
<li>外观模式</li>
<li>享元模式</li>
<li>代理模式</li>
</ol>
</li>
<li>行为型模式<ol>
<li>解释器模式</li>
<li>责任链模式</li>
<li>命令模式</li>
<li>迭代器模式</li>
<li>中介者模式</li>
<li>备忘录模式</li>
<li>观察者模式</li>
<li>状态模式</li>
<li>策略模式</li>
<li>访问者模式</li>
<li>模板方法模式</li>
</ol>
</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[设置django admin 显示为中文]]></title>
      <url>/2018/01/django-admin-cn.html</url>
      <content type="html"><![CDATA[<p>默认的 django admin 组件 显示为英文，设置 django admin 显示为中文很简单，只需在 settings.py 的 MIDDLEWARE_CLASSES 中添加一句 <code>&#39;django.middleware.locale.LocaleMiddleware&#39;</code> 即可。</p>
<p>如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">MIDDLEWARE_CLASSES = (</div><div class="line">    &apos;django.contrib.sessions.middleware.SessionMiddleware&apos;,</div><div class="line">    &apos;django.middleware.common.CommonMiddleware&apos;,</div><div class="line">    &apos;django.middleware.csrf.CsrfViewMiddleware&apos;,</div><div class="line">    &apos;django.contrib.auth.middleware.AuthenticationMiddleware&apos;,</div><div class="line">    &apos;django.contrib.messages.middleware.MessageMiddleware&apos;,</div><div class="line">    &apos;django.middleware.clickjacking.XFrameOptionsMiddleware&apos;,</div><div class="line">    &apos;django.middleware.locale.LocaleMiddleware&apos;,</div><div class="line">)</div></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ol>
<li><p><code>&#39;django.middleware.locale.LocaleMiddleware&#39;</code> 必须放在 <code>&#39;django.contrib.sessions.middleware.SessionMiddleware&#39;</code> 之后。</p>
</li>
<li><p>如果添加上面这句话后还是显示英文，则可能是浏览器语言设置问题，在浏览器语言设置中添加中文并放到首位试试。比如 Firefox 浏览器设置为：Firefox-&gt;Edit-&gt;Preferences-&gt;  Content-&gt;Languages </p>
</li>
</ol>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><a href="https://my.oschina.net/means/blog/287753" target="_blank" rel="external">https://my.oschina.net/means/blog/287753</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> django </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker 操作]]></title>
      <url>/2018/01/my-docker-note.html</url>
      <content type="html"><![CDATA[<h1 id="why"><a href="#why" class="headerlink" title="why?"></a>why?</h1><ul>
<li>更高效的利用系统资源</li>
<li>更快速的启动时间</li>
<li>一致的运行环境</li>
<li>持续交付和部署</li>
<li>更轻松的迁移</li>
<li>更轻松的维护和扩展</li>
</ul>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul>
<li>镜像（Image）</li>
<li>容器（Container）</li>
<li>仓库（Repository）</li>
</ul>
<p>理解了这三个概念，就理解了 Docker 的整个生命周期。</p>
<h1 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h1><p>从 Docker 镜像仓库获取镜像的命令是 docker pull。其命令格式为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</div></pre></td></tr></table></figure>
<p><strong>如:</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ docker pull ubuntu:16.04</div><div class="line">16.04: Pulling from library/ubuntu</div><div class="line">bf5d46315322: Pull complete</div><div class="line">9f13e0ac480c: Pull complete</div><div class="line">e8988b5b3097: Pull complete</div><div class="line">40af181810e7: Pull complete</div><div class="line">e6f7c7e5c03e: Pull complete</div><div class="line">Digest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe</div><div class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:16.04</div></pre></td></tr></table></figure>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run -it --rm ubuntu:16.04 bash</div></pre></td></tr></table></figure>
<p>说明一下上面用到的参数。</p>
<ul>
<li>-it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。</li>
<li>–rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 –rm 可以避免浪费空间。</li>
<li>ubuntu:16.04：这是指用 ubuntu:16.04 镜像为基础来启动容器。</li>
<li>bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash。</li>
</ul>
<p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 cat /etc/os-release，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 Ubuntu 16.04.4 LTS 系统。</p>
<h1 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h1><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。</p>
<p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p>
<h2 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h2><ul>
<li>无交互</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker run ubuntu:14.04 /bin/<span class="built_in">echo</span> <span class="string">'Hello world'</span></div><div class="line">Hello world</div></pre></td></tr></table></figure>
<ul>
<li>允许交互</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker run -t -i ubuntu:14.04 /bin/bash</div><div class="line">root@af8bae53bdd3:/<span class="comment">#</span></div></pre></td></tr></table></figure>
<p>其中，-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开。</p>
<p><strong>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：</strong></p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载<br>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<h2 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h2><p>可以利用 docker container start 命令，直接将一个已经终止的容器启动运行。</p>
<p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 ps 或 top 来查看进程信息。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">root@ba267838cc1b:/<span class="comment"># ps</span></div><div class="line">  PID TTY          TIME CMD</div><div class="line">    1 ?        00:00:00 bash</div><div class="line">   11 ?        00:00:00 ps</div></pre></td></tr></table></figure>
<p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p>
<h1 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h1><p>需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。可以通过添加 -d 参数来实现。</p>
<ul>
<li>不使用 -d 参数运行容器。</li>
</ul>
<p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p>
<ul>
<li>使用了 -d 参数运行容器。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker run -d ubuntu:17.10 /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></div><div class="line">77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a</div></pre></td></tr></table></figure>
<p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 docker logs 查看)。容器是否会长久运行，是和 docker run 指定的命令有关，和 -d 参数无关。</p>
<p>使用 -d 参数启动后会返回一个唯一的 id，也可以通过 docker container ls 命令来查看容器信息。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ docker container ls</div><div class="line">CONTAINER ID  IMAGE         COMMAND               CREATED        STATUS       PORTS NAMES</div><div class="line">77b2dc01fe0f  ubuntu:17.10  /bin/sh -c <span class="string">'while tr  2 minutes ago  Up 1 minute        agitated_wright</span></div></pre></td></tr></table></figure>
<p>要获取容器的输出信息，可以通过 docker container logs 命令。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ docker container logs [container ID or NAMES]</div><div class="line">hello world</div><div class="line">hello world</div><div class="line">hello world</div><div class="line">. . .</div></pre></td></tr></table></figure>
<h1 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h1><p>可以使用 docker container stop 来终止一个运行中的容器。</p>
<p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p>
<p>用户通过 exit 命令或 Ctrl+d 来退出终端时，所创建的容器立刻终止。</p>
<p>终止状态的容器可以用 docker container ls -a 命令看到。例如</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker ps -a</div><div class="line">CONTAINER ID        IMAGE                    COMMAND                CREATED             STATUS                          PORTS               NAMES</div><div class="line">ba267838cc1b        ubuntu:14.04             <span class="string">"/bin/bash"</span>            30 minutes ago      Exited (0) About a minute ago                       trusting_newton</div><div class="line">98e5efa7d997        training/webapp:latest   <span class="string">"python app.py"</span>        About an hour ago   Exited (0) 34 minutes ago                           backstabbing_pike</div></pre></td></tr></table></figure>
<p>处于终止状态的容器，可以通过 docker container start 命令来重新启动。</p>
<h2 id="重新启动"><a href="#重新启动" class="headerlink" title="重新启动"></a>重新启动</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker container restart</div></pre></td></tr></table></figure>
<p>此外，docker container restart 命令会将一个运行态的容器终止，然后再重新启动它。</p>
<h1 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h1><p>在使用 -d 参数时，容器启动后会进入后台。</p>
<p>某些时候需要进入容器进行操作，包括使用 docker attach 命令或 docker exec 命令，推荐大家使用 docker exec 命令，因为使用 attach stdin 执行 exit 会导致容器停止。</p>
<h2 id="attach-命令"><a href="#attach-命令" class="headerlink" title="attach 命令"></a>attach 命令</h2><p>docker attach 是 Docker 自带的命令。下面示例如何使用该命令。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ docker run -dit ubuntu</div><div class="line">243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550</div><div class="line"></div><div class="line">$ docker container ls</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line">243c32535da7        ubuntu:latest       <span class="string">"/bin/bash"</span>         18 seconds ago      Up 17 seconds                           nostalgic_hypatia</div><div class="line"></div><div class="line">$ docker attach 243c</div><div class="line">root@243c32535da7:/<span class="comment">#</span></div></pre></td></tr></table></figure>
<h2 id="exec-命令"><a href="#exec-命令" class="headerlink" title="exec 命令"></a>exec 命令</h2><p><strong>-i -t 参数</strong><br>docker exec 后边可以跟多个参数，这里主要说明 -i -t 参数。</p>
<p>只用 -i 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p>
<p>当 -i -t 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ docker run -dit ubuntu</div><div class="line">69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6</div><div class="line"></div><div class="line">$ docker container ls</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line">69d137adef7a        ubuntu:latest       <span class="string">"/bin/bash"</span>         18 seconds ago      Up 17 seconds                           zealous_swirles</div><div class="line"></div><div class="line">$ docker <span class="built_in">exec</span> -i 69d1 bash</div><div class="line">ls</div><div class="line">bin</div><div class="line">boot</div><div class="line">dev</div><div class="line">...</div><div class="line"></div><div class="line">$ docker <span class="built_in">exec</span> -it 69d1 bash</div><div class="line">root@69d137adef7a:/<span class="comment">#</span></div></pre></td></tr></table></figure>
<h1 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h1><h2 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h2><p>如果要导出本地某个容器，可以使用 docker export 命令。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker ps -a</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES</div><div class="line">7691a814370e        ubuntu:14.04        <span class="string">"/bin/bash"</span>         36 hours ago        Exited (0) 21 hours ago                       <span class="built_in">test</span></div><div class="line">$ docker <span class="built_in">export</span> 7691a814370e &gt; ubuntu.tar</div></pre></td></tr></table></figure>
<h2 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h2><p>可以使用 docker import 从容器快照文件中再导入为镜像，例如</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ cat ubuntu.tar | docker import - <span class="built_in">test</span>/ubuntu:v1.0</div><div class="line">$ docker image ls</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE</div><div class="line"><span class="built_in">test</span>/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB</div></pre></td></tr></table></figure>
<p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker import http://example.com/exampleimage.tgz example/imagerepo</div></pre></td></tr></table></figure>
<p><em>注：用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</em></p>
<h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker container rm  trusting_newton</div><div class="line">trusting_newton</div></pre></td></tr></table></figure>
<p>如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。</p>
<h2 id="清理所有处于终止状态的容器"><a href="#清理所有处于终止状态的容器" class="headerlink" title="清理所有处于终止状态的容器"></a>清理所有处于终止状态的容器</h2><p>用 docker container ls -a 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker container prune</div></pre></td></tr></table></figure>
<h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker --version  <span class="comment"># docker版本</span></div><div class="line">$ docker info   <span class="comment"># docker信息</span></div><div class="line">$ docker run --rm ubuntu:16.04 /bin/cat <span class="string">'/etc/os-release'</span></div><div class="line">$ docker run -it --name web  --rm ubuntu:16.04 bash</div></pre></td></tr></table></figure>
<h2 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ docker stop myUbuntu</div><div class="line">myUbuntu</div></pre></td></tr></table></figure>
<h2 id="删除容器-1"><a href="#删除容器-1" class="headerlink" title="删除容器"></a>删除容器</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ docker rm myUbuntu</div><div class="line">myUbuntu</div></pre></td></tr></table></figure>
<h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜ docker images ls</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">nginx               latest              6b914bbcb89e        3 weeks ago         182 MB</div><div class="line">ubuntu              14.04               7c09e61e9035        3 weeks ago         188 MB</div></pre></td></tr></table></figure>
<h3 id="列出部分镜像"><a href="#列出部分镜像" class="headerlink" title="列出部分镜像"></a>列出部分镜像</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker image ls ubuntu</div><div class="line">$ docker image ls ubuntu:16.04</div></pre></td></tr></table></figure>
<p>docker image ls 还支持强大的过滤器参数 –filter，或者简写 -f</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker image ls -f since=mongo:3.2</div><div class="line">$ docker image ls -f</div></pre></td></tr></table></figure>
<p>想查看某个位置之前的镜像也可以，只需要把 since 换成 before 即可。</p>
<p>如果定义了 LABEL，还可以通过 LABEL 来过滤</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">label=com.example.version=0.1</div></pre></td></tr></table></figure>
<h3 id="以特定格式显示"><a href="#以特定格式显示" class="headerlink" title="以特定格式显示"></a>以特定格式显示</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ docker image ls -q</div><div class="line">$ docker image ls --format <span class="string">"&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;"</span></div><div class="line">$ docker image ls --format <span class="string">"table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;"</span></div></pre></td></tr></table></figure>
<h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker rmi 7c09e61e9035</div><div class="line">Untagged: ubuntu:14.04</div><div class="line">Untagged: ...</div><div class="line">$ docker image rm $(docker image ls -q redis)</div></pre></td></tr></table></figure>
<h2 id="查看容器修改内容"><a href="#查看容器修改内容" class="headerlink" title="查看容器修改内容"></a>查看容器修改内容</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ docker diff webserver</div><div class="line">C /root</div><div class="line">A /root/.bash_history</div><div class="line">...</div></pre></td></tr></table></figure>
<h2 id="查看docker进程"><a href="#查看docker进程" class="headerlink" title="查看docker进程"></a>查看docker进程</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜  ~ docker ps -a</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div></pre></td></tr></table></figure>
<h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run --name webserver -d -p 80:80 nginx</div></pre></td></tr></table></figure>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><a href="http://blog.csdn.net/zhengyong15984285623/article/details/66971949" target="_blank" rel="external">http://blog.csdn.net/zhengyong15984285623/article/details/66971949</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/" target="_blank" rel="external">https://yeasy.gitbooks.io/docker_practice/</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据结构基础]]></title>
      <url>/2017/12/data-structure-basis.html</url>
      <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>数据结构是设计数据以何种方式组织并存储在计算机中。</p>
<p>比如：<code>列表</code>、<code>集合</code>与<code>字典</code>等都是一种数据结构。</p>
<p>详细的说：</p>
<ul>
<li>物理层面：就是以什么样的物理存储方式</li>
<li>逻辑方式：列表，字典，集合，树</li>
</ul>
<p><strong>线性数据结构，树形数据结构，图形数据结构，</strong> 基本是线性数据结构</p>
<p>N.Wirth: “程序=数据结构+算法”</p>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>列表：在其他编程语言中称为“数组”，是一种基本的数据结构类型。如果更学术一点的说法是“线性表”。</p>
<p><strong>数组与列表的不同之处：</strong><br>数组是定长的数组，如果开的内存空间长度为7，就不能再追加，只能存7个，并且这7个元素类型还必须是一样的</p>
<p><strong>数组：定长，元素类型统一。</strong></p>
<p>Python中的给一个列表，开一块连续内存空间，开的内存空间的长度不会刚好是列表的长度，一定会多，而内存中：变量指向的列表的元素存的是一个个内存地址（地址的格子才是真正存元素值的地方），每个元素占用的空间都是一样的，大部分编译型的语言直接存的值，而python存的不是值，而是值的内存地址。</p>
<p>Python中一直<code>append</code>值的原理：如果之前的空间不够，就再开时原来一倍的内存空间，然后把旧的删掉</p>
<blockquote>
<p>列表<code>li[2]</code>寻址的时候是<code>li+2*内存地址的字节</code></p>
</blockquote>
<p>32位机器一个地址4个子节<br>64位机器一个地址8个字节</p>
<p><strong>关于列表的问题：</strong></p>
<ul>
<li>列表中元素使如何存储的？(上述)</li>
<li>列表提供了哪些基本的操作？(下标查找，插入，删除)</li>
<li>这些操作的时间复杂度是多少？<ul>
<li>O(1)</li>
<li>O(n)(插入的时候，插入位置之后的值都需要往后挪)</li>
</ul>
</li>
</ul>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表中每一个元素都是一个对象，每个对象称为一个节点，包含有数据域key和指向下一个节点的指针next。通过各个节点之间的相互连接，最终串联成一个链表。</p>
<p>为什么用链表？<br>链表的插入和删除特别快</p>
<p><strong>节点定义:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,item)</span>:</span></div><div class="line">        self.item = item</div><div class="line">        self.next = <span class="keyword">None</span></div><div class="line"></div><div class="line">n1 = Node(<span class="number">1</span>)</div><div class="line">n2 = Node(<span class="number">2</span>)</div><div class="line">n3 = Node(<span class="number">3</span>)</div><div class="line"></div><div class="line">n1.next = n2</div><div class="line">n2.next = n3</div><div class="line"></div><div class="line">print(n1.next.item) <span class="comment"># 2</span></div><div class="line">print(n1.next.next.item) <span class="comment"># 3</span></div></pre></td></tr></table></figure>
<ul>
<li>头节点</li>
</ul>
<p><img src="https://i.imgur.com/P1WJgQ8.jpg" alt="单向链表"></p>
<h2 id="链表的遍历"><a href="#链表的遍历" class="headerlink" title="链表的遍历"></a>链表的遍历</h2><p><img src="https://i.imgur.com/xvc5L8B.jpg" alt="链表遍历"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">traversal</span><span class="params">(head)</span>:</span></div><div class="line">    curNode = head  <span class="comment"># 临时用指针</span></div><div class="line">    <span class="keyword">while</span> curNode <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">        print(curNode.data)</div><div class="line">        curNode = curNode.next</div></pre></td></tr></table></figure>
<h2 id="链表节点的插入和删除"><a href="#链表节点的插入和删除" class="headerlink" title="链表节点的插入和删除"></a>链表节点的插入和删除</h2><p>O1的时间复杂度</p>
<ul>
<li>插入</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p.next = curNode.next</div><div class="line">curNode.next = p</div></pre></td></tr></table></figure>
<ul>
<li>删除</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">p = curNode.next</div><div class="line">curNode.next = curNode.next.next</div><div class="line"><span class="comment"># 也可以 &gt;&gt; curNode.next = p.next</span></div><div class="line"><span class="keyword">del</span> p</div></pre></td></tr></table></figure>
<h2 id="建立链表"><a href="#建立链表" class="headerlink" title="建立链表"></a>建立链表</h2><ul>
<li>头插法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">createLinkList</span><span class="params">(li)</span>:</span></div><div class="line">    l = Node()</div><div class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> li:</div><div class="line">        s = Node(Num)</div><div class="line">        s.next = l.next</div><div class="line">        l.next = s</div><div class="line">    <span class="keyword">return</span> l</div></pre></td></tr></table></figure>
<ul>
<li>尾插法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">createLinkList</span><span class="params">(li)</span>:</span></div><div class="line">    l = Node()</div><div class="line">    r = l   <span class="comment"># r 指向尾节点</span></div><div class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> li :</div><div class="line">        s = Node(num)</div><div class="line">        r.next = s</div><div class="line">        r = s</div></pre></td></tr></table></figure>
<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p>双链表中每个节点有两个指针：一个指向后面节点、一个指向前面节点。</p>
<p><strong>节点定义：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,item = None)</span>:</span></div><div class="line">        self.item = item</div><div class="line">        self.next = <span class="keyword">None</span></div><div class="line">        self.prior = <span class="keyword">None</span></div></pre></td></tr></table></figure>
<h3 id="双链表节点的插入和删除"><a href="#双链表节点的插入和删除" class="headerlink" title="双链表节点的插入和删除"></a>双链表节点的插入和删除</h3><ul>
<li>插入</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">p.next = curNode.next</div><div class="line">curNode.next.prior = p</div><div class="line">p.prior = curNode</div><div class="line">curNode.next = p</div></pre></td></tr></table></figure>
<ul>
<li>删除</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">p = curNode.next</div><div class="line">curNode.next = p.next</div><div class="line">p.next.prior = curNode</div><div class="line"><span class="keyword">del</span> p</div></pre></td></tr></table></figure>
<h2 id="链表分析"><a href="#链表分析" class="headerlink" title="链表分析"></a>链表分析</h2><h3 id="列表与链表"><a href="#列表与链表" class="headerlink" title="列表与链表"></a>列表与链表</h3><ul>
<li>按元素值查找（链表二分是On的复杂度）</li>
<li>按下标查找（链表没有法用下表查找，李列表：O1，链表On）</li>
<li>在某元素后插入（列表：On，链表：O1）</li>
<li>删除某元素（列表：On，链表：O1）</li>
</ul>
<p>树也是以链表的形式存</p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈(Stack)是一个数据集合，可以理解为只能在一端进行插入或删除操作的列表。</p>
<p><strong>特点：</strong> 后进先出（last-in, first-out）LIFO</p>
<p><strong>概念：</strong></p>
<ul>
<li>栈顶</li>
<li>栈底</li>
</ul>
<p><strong>基本操作：</strong></p>
<ul>
<li>进栈（压栈）：push</li>
<li>出栈：pop</li>
<li>取栈顶：gettop</li>
</ul>
<p><strong>应用实例：</strong></p>
<ul>
<li>Word 的撤销操作（撤销的时候后边的操作）</li>
<li>重做</li>
</ul>
<blockquote>
<p>两个栈,撤销栈出栈，重做栈压栈；重做操作是记录撤销操作的。</p>
</blockquote>
<h2 id="栈的简单实现-Python"><a href="#栈的简单实现-Python" class="headerlink" title="栈的简单实现(Python)"></a>栈的简单实现(Python)</h2><p>不需要自己定义，使用列表结构即可。</p>
<ul>
<li>进栈函数：append</li>
<li>出栈函数：pop</li>
<li>查看栈顶函数：li[-1]</li>
</ul>
<h2 id="栈的应用-括号匹配问题"><a href="#栈的应用-括号匹配问题" class="headerlink" title="栈的应用 - 括号匹配问题"></a>栈的应用 - 括号匹配问题</h2><p>给一个字符串，其中包含小括号、中括号、大括号，求该字符串中的括号是否匹配。</p>
<ul>
<li><code>()()[]{}</code>        匹配</li>
<li><code>([{()}])</code>        匹配</li>
<li><code>[](</code>        不匹配</li>
<li><code>[(])</code>        不匹配</li>
</ul>
<p>代码补全，当栈是空的，栈才是合法的</p>
<ul>
<li><a href="https://github.com/cvno/Note/blob/master/1/code1.py" target="_blank" rel="external">代码实现括号匹配</a></li>
</ul>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列(Queue)是一个数据集合，仅允许在列表的一端进行插入，另一端进行删除。</p>
<ul>
<li>进行插入的一端称为队尾(rear)，插入动作称为进队或入队</li>
<li>进行删除的一端称为队头(front)，删除动作称为出队</li>
<li>队列的性质：先进先出(First-in, First-out)</li>
<li>双向队列：队列的两端都允许进行进队和出队操作。</li>
</ul>
<p><img src="https://i.imgur.com/cct8beO.jpg" alt="队列"></p>
<p><img src="https://i.imgur.com/ruUddhR.jpg" alt="队列模型"></p>
<h2 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h2><p><strong>用Python的列表来实现出队复杂度太高</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">使用方法：from collections import deque</div><div class="line">- 创建队列：queue = deque(li)</div><div class="line">- 进队：append</div><div class="line">- 出队：popleft</div><div class="line">- 双向队列队首进队：appendleft</div><div class="line">- 双向队列队尾进队：pop</div></pre></td></tr></table></figure>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><ul>
<li>初步设想：列表+两个下标指针</li>
<li>创建一个列表和两个变量，front变量指向队首，rear变量指向队尾。初始时，front和rear都为0。</li>
<li>进队操作：元素写到li[rear]的位置，rear自增1。</li>
<li>出队操作：返回li[front]的元素，front自减1。</li>
</ul>
<p><img src="https://i.imgur.com/VsKQCZb.jpg" alt="队列"></p>
<h2 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h2><p>环形队列：当队尾指针front == Maxsize + 1时，再前进一个位置就自动到0。<br><strong>实现方式：求余数运算</strong></p>
<ul>
<li>队首指针前进1：front = (front + 1) % MaxSize</li>
<li>队尾指针前进1：rear = (rear + 1) % MaxSize</li>
<li>队空条件：rear == front</li>
<li>队满条件：(rear + 1) % MaxSize == front</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul>
<li>通过Python自带库</li>
<li><a href="https://gist.github.com/cvno/eeb1073a4fc23e42885a6112671f0545" target="_blank" rel="external">手写循环队列</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> queue    <span class="comment"># 线程同步</span></div><div class="line"><span class="comment">########  分割  ########</span></div><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</div><div class="line">queue = deque()</div><div class="line">queue.append(<span class="number">1</span>)</div><div class="line">queue.append(<span class="number">2</span>)</div><div class="line">queue.append(<span class="number">3</span>)</div><div class="line">print( ())</div><div class="line">print(queue.popleft())</div><div class="line"><span class="comment">########  分割  ########</span></div><div class="line">queue.appendleft(<span class="number">2</span>)</div><div class="line">queue.pop()</div></pre></td></tr></table></figure>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="Python中的集合与字典"><a href="#Python中的集合与字典" class="headerlink" title="Python中的集合与字典"></a>Python中的集合与字典</h2><p>哈希表查找</p>
<blockquote>
<p>哈希表（Hash Table，又称为散列表），是一种线性表的存储结构。通过把每个对象的关键字k作为自变量，通过一个哈希函数h(k)，将k映射到下标h(k)处，并将该对象存储在这个位置。</p>
</blockquote>
<p><strong>例如：</strong>数据集合{1,6,7,9}，假设存在哈希函数h(x)使得h(1) = 0, h(6) = 2, h(7) = 4, h(9) = 5，那么这个哈希表被存储为[1,None, 6, None, 7, 9]。</p>
<p>当我们查找元素6所在的位置时，通过哈希函数h(x)获得该元素所在的下标（h(6) = 2），因此在2位置即可找到该元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">li = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</div><div class="line">s = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; <span class="comment"># 集合的效率更高</span></div><div class="line"><span class="comment"># 哈希函数设计的再好也避免不了碰撞</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#</span></div></pre></td></tr></table></figure>
<h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>哈希冲突：由于哈希表的下标范围是有限的，而元素关键字的值是接近无限的，因此可能会出现h(102) = 56， h(2003) = 56这种情况。此时，两个元素映射到同一个下标处，造成哈希冲突。</p>
<p><strong>解决哈希冲突</strong></p>
<ul>
<li>拉链法（将所有冲突的元素用链表连接）</li>
<li>开放寻址法（通过哈希冲突函数得到新的地址）</li>
</ul>
<p><img src="http://onk83djzp.bkt.clouddn.com/2017-12-13-15131769752694.jpg" alt="拉链法"></p>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p><strong>在Python中的字典：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = &#123;&apos;name&apos;: &apos;Alex&apos;, &apos;age&apos;: 18, &apos;gender&apos;: &apos;Man&apos;&#125;</div></pre></td></tr></table></figure>
<p>使用哈希表存储字典，通过哈希函数将字典的键映射为下标。假设h(‘name’) = 3, h(‘age’) = 1, h(‘gender’) = 4，则哈希表存储为[None, 18, None, ’Alex’, ‘Man’]</p>
<p>在字典键值对数量不多的情况下，几乎不会发生哈希冲突，此时查找一个元素的时间复杂度为O(1)。</p>
<h1 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h1><p>给一个二维列表，表示迷宫（0表示通道，1表示围墙）。给出算法，求一条走出迷宫的路径。</p>
<h2 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h2><ul>
<li><a href="https://github.com/cvno/Note/blob/master/1/maze.py" target="_blank" rel="external">栈-方案</a></li>
</ul>
<p>深度优先 <strong>DFS（Depth[栈]-First-Search）</strong></p>
<h2 id="队列-1"><a href="#队列-1" class="headerlink" title="队列"></a>队列</h2><ul>
<li><a href="https://github.com/cvno/Note/blob/master/1/code2.py" target="_blank" rel="external">队列-方案</a></li>
</ul>
<p>使用二维列表存储多条路径<br><strong>如何是打印出路径是难点</strong></p>
<p><img src="http://onk83djzp.bkt.clouddn.com/15114913815577.jpg" alt="迷宫"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">maze = [</div><div class="line">    [1,1,1,1,1,1,1,1,1,1],</div><div class="line">    [1,0,0,1,0,0,0,1,0,1],</div><div class="line">    [1,0,0,1,0,0,0,1,0,1],</div><div class="line">    [1,0,0,0,0,1,1,0,0,1],</div><div class="line">    [1,0,1,1,1,0,0,0,0,1],</div><div class="line">    [1,0,0,0,1,0,0,0,0,1],</div><div class="line">    [1,0,1,0,0,0,1,0,0,1],</div><div class="line">    [1,0,1,1,1,0,1,1,0,1],</div><div class="line">    [1,1,0,0,0,0,0,0,0,1],</div><div class="line">    [1,1,1,1,1,1,1,1,1,1]</div><div class="line">]</div></pre></td></tr></table></figure>
<p>本文代码及 md 文件 <a href="https://github.com/cvno/Note/tree/master/1" target="_blank" rel="external">Github</a></p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 迷宫 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TOP 榜单算法（nlargest）]]></title>
      <url>/2017/12/top-list-algorithm.html</url>
      <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>现在有n个数（n&gt;10000），设计算法，按大小顺序得到前<del>10</del>m大的数。</p>
<a id="more"></a>
<ul>
<li>应用场景：榜单TOP 10</li>
</ul>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><ol>
<li>先排序，取前 10 个数 O(nlogn)</li>
<li>只留前 10 个数，开一个长度为 10 的列表，用插入排序取出 10 个数，来一个数和列表最后一个数比较，如果比它更小就扔掉 O(nm)不适用与 m 特别大的时候</li>
<li>堆 O(nlogm)</li>
</ol>
<p>用堆解决思路：</p>
<ol>
<li>取列表前m个元素建立一个小根堆。堆顶就是目前第m大的数。</li>
<li>依次向后遍历原列表，对于列表中的元素，如果小于堆顶，则忽略该元素；如果大于堆顶，则将堆顶更换为该元素，并且对堆进行一次调整；</li>
<li>遍历列表所有元素后，倒序弹出堆顶。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift</span><span class="params">(data, low, high)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    调整函数</div><div class="line">    data: 列表</div><div class="line">    low：待调整的子树的根位置</div><div class="line">    high：待调整的子树的最后一个节点的位置</div><div class="line">    """</div><div class="line">    i = low</div><div class="line">    j = <span class="number">2</span> * i + <span class="number">1</span></div><div class="line">    tmp = data[i]</div><div class="line">    <span class="comment"># i指向空位置</span></div><div class="line">    <span class="keyword">while</span> j&lt;=high:      <span class="comment">#领导已经撸到底了</span></div><div class="line">        <span class="keyword">if</span> j != high <span class="keyword">and</span> data[j] &lt; data[j+<span class="number">1</span>]:</div><div class="line">            j += <span class="number">1</span></div><div class="line">        <span class="comment">#j指向数值大的孩子</span></div><div class="line">        <span class="keyword">if</span> tmp &lt; data[j]:   <span class="comment">#如果小领导比撸下来的大领导能力值大</span></div><div class="line">            data[i] = data[j]</div><div class="line">            i = j</div><div class="line">            j = <span class="number">2</span>*i+<span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">break</span>       <span class="comment">#撸下来的领导比候选的领导能力值大</span></div><div class="line">    data[i] = tmp</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">topn</span><span class="params">(li, n)</span>:</span></div><div class="line">    heap = li[<span class="number">0</span>:n]</div><div class="line">    <span class="comment"># 建堆</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n // <span class="number">2</span> - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">        sift(heap, i, n - <span class="number">1</span>)</div><div class="line">        <span class="comment"># 遍历</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n, len(li)):</div><div class="line">        <span class="keyword">if</span> li[i] &gt; heap[<span class="number">0</span>]:</div><div class="line">            heap[<span class="number">0</span>] = li[i]</div><div class="line">            sift(heap, <span class="number">0</span>, n - <span class="number">1</span>)</div><div class="line">    <span class="comment"># 出数</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">        heap[<span class="number">0</span>], heap[i] = heap[i], heap[<span class="number">0</span>]</div><div class="line">        sift(heap, <span class="number">0</span>, i - <span class="number">1</span>)</div></pre></td></tr></table></figure>
<ul>
<li>Python内置模块——heapq</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> heapq</div><div class="line"><span class="comment"># 利用heapq模块实现堆排序</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapsort</span><span class="params">(li)</span>:</span></div><div class="line">    h = []</div><div class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> li:</div><div class="line">        heapq.heappush(h, value)<span class="comment"># 建堆, 并自动排序</span></div><div class="line">    <span class="keyword">return</span> [heappop(h) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(h))]</div><div class="line"></div><div class="line">heapsort([<span class="number">6</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>]) <span class="comment"># [0,2,1,3,5,6,7,9,4,8]</span></div><div class="line"></div><div class="line"><span class="comment"># ============== 分割线 ==============</span></div><div class="line"><span class="comment"># 利用heapq模块实现取top-k</span></div><div class="line">heapq.nlargest(<span class="number">100</span>, li)</div></pre></td></tr></table></figure>
<p>优先队列：一些元素的集合，POP操作每次执行都会从优先队列中弹出最大（或最小）的元素。</p>
<blockquote>
<p>堆——优先队列</p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://python.usyiyi.cn/translate/python_352/library/heapq.html" target="_blank" rel="external">http://python.usyiyi.cn/translate/python_352/library/heapq.html</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 位运算</span></div><div class="line"><span class="comment"># &gt;&gt; 除以2</span></div><div class="line"><span class="number">2</span> &gt;&gt; <span class="number">1</span> <span class="comment"># 1 </span></div><div class="line"><span class="number">4</span> &gt;&gt; <span class="number">1</span> <span class="comment"># 2</span></div><div class="line"><span class="number">8</span> &gt;&gt; <span class="number">1</span> <span class="comment"># 4</span></div><div class="line"><span class="comment"># &lt;&lt; 乘以 2</span></div><div class="line"><span class="number">2</span> &lt;&lt; <span class="number">1</span>  <span class="comment"># 4</span></div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> heapq </tag>
            
            <tag> nlargest </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据结构：树]]></title>
      <url>/2017/12/data-structure-tree.html</url>
      <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p><img src="https://i.imgur.com/JH2f8TO.jpg" alt="树（数据结构）"></p>
<ul>
<li>是一种数据结构（如：目录结构） </li>
<li>是一种可以递归定义的数据结构</li>
<li>是由 n 个节点组成的集合<ul>
<li>如果 n=0 ，那么是一颗空树</li>
<li>如果 n&gt;0 ，那么存在 1 个节点作为树的根节点，其他节点可以分为 m 个集合，每个集合本身又是一棵树。</li>
</ul>
</li>
</ul>
<p><strong>概念：</strong></p>
<ul>
<li>根节点（最顶端的节点）、叶子节点（没有孩子的节点，结构的最末端）</li>
<li>树的深度／高度（也就是树的层数）</li>
<li>节点度（也就是这个节点分了多少叉）</li>
<li>树的度（所有节点度的最大值）</li>
<li>孩子节点/父节点（看字面理解）</li>
<li>子树（根节点的字节点都是独立的树）</li>
</ul>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>度不超过 2 的树（节点最多有两个叉），它的孩子是有顺序的：左孩子，右孩子。<br><img src="https://i.imgur.com/Fq7IcbA.jpg" alt="二叉树的多种形态"></p>
<p>重点：满二叉树，完全二叉树</p>
<h2 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h2><ol>
<li>链式存储方式</li>
<li>顺序存储方式（列表）</li>
<li>面向对象的存储方式</li>
</ol>
<p><img src="https://i.imgur.com/X5OMYC1.jpg" alt=""></p>
<p>父节点和左孩子节点的编号下标有什么关系？</p>
<blockquote>
<p>0-1 1-3 2-5 3-7 4-9<br>规律：i = 2i+1</p>
</blockquote>
<p>父节点和右孩子节点的编号下标有什么关系？</p>
<blockquote>
<p>0-2 1-4 2-6 3-8 4-10<br>规律：i = 2i+2</p>
</blockquote>
<p>比如，我们要找根节点左孩子的左孩子：（0*2+1）*2+1 = 3 （下标） 所以是<code>6</code></p>
<h2 id="面向对象的存储方式"><a href="#面向对象的存储方式" class="headerlink" title="面向对象的存储方式"></a>面向对象的存储方式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinTreeNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data)</span>:</span></div><div class="line">        self.data = data</div><div class="line">        self.lchild = <span class="keyword">None</span></div><div class="line">        self.rchild = <span class="keyword">None</span></div><div class="line"></div><div class="line">k = BinTreeNode(<span class="string">'K'</span>)</div><div class="line">g = BinTreeNode(<span class="string">'G'</span>)</div><div class="line">c = BinTreeNode(<span class="string">'C'</span>)</div><div class="line">a = BinTreeNode(<span class="string">'A'</span>)</div><div class="line">b = BinTreeNode(<span class="string">'B'</span>)</div><div class="line">d = BinTreeNode(<span class="string">'D'</span>)</div><div class="line">e = BinTreeNode(<span class="string">'E'</span>)</div><div class="line">f = BinTreeNode(<span class="string">'F'</span>)</div><div class="line">h = BinTreeNode(<span class="string">'H'</span>)</div><div class="line"></div><div class="line"></div><div class="line">root = a</div><div class="line">a.lchild = b</div><div class="line">a.rchild = e</div><div class="line">b.lchild = h</div><div class="line">b.rchild = f</div><div class="line">f.lchild = d</div><div class="line">e.rchild = c</div><div class="line">c.lchild = k</div><div class="line">c.rchild = g</div></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/umYC031.jpg" alt="二叉树"></p>
<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">PreBianli</span><span class="params">(root)</span>:</span></div><div class="line">    p = root</div><div class="line">    <span class="keyword">if</span> p:</div><div class="line">        print(p.data, end=<span class="string">' '</span>)</div><div class="line">        PreBianli(p.lchild)</div><div class="line">        PreBianli(p.rchild)</div><div class="line"></div><div class="line"><span class="comment"># PreBianli(root)   # A B H F D E C K G    前序遍历</span></div></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/4pl3DJs.jpg" alt="前序遍历"></p>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">MidBianli</span><span class="params">(root)</span>:</span></div><div class="line">    p = root</div><div class="line">    <span class="keyword">if</span> p:</div><div class="line">        MidBianli(p.lchild)</div><div class="line">        print(p.data, end=<span class="string">' '</span>)</div><div class="line">        MidBianli(p.rchild)</div><div class="line"><span class="comment"># MidBianli(root)   # H B D F A E K C G    中序遍历</span></div></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/jJGlzo8.jpg" alt="中序遍历"></p>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">PostBianli</span><span class="params">(root)</span>:</span></div><div class="line">    p = root</div><div class="line">    <span class="keyword">if</span> p:</div><div class="line">        PostBianli(p.lchild)</div><div class="line">        PostBianli(p.rchild)</div><div class="line">        print(p.data, end=<span class="string">' '</span>)</div><div class="line"><span class="comment"># PostBianli(root)  # H D F B K G C E A    后序遍历</span></div></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/GyEjLF3.jpg" alt="后续遍历"></p>
<h4 id="层级遍历"><a href="#层级遍历" class="headerlink" title="层级遍历"></a>层级遍历</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">LevelBianli</span><span class="params">(root)</span>:</span></div><div class="line">    curLevel = [root]</div><div class="line">    nextLevel = []</div><div class="line">    <span class="keyword">while</span> len(curLevel)&gt;<span class="number">0</span>:</div><div class="line">        <span class="keyword">for</span> node <span class="keyword">in</span>  curLevel:</div><div class="line">            print(node.data, end=<span class="string">' '</span>)</div><div class="line">            <span class="keyword">if</span> node.lchild:</div><div class="line">                nextLevel.append(node.lchild)</div><div class="line">            <span class="keyword">if</span> node.rchild:</div><div class="line">                nextLevel.append(node.rchild)</div><div class="line">        curLevel = nextLevel</div><div class="line">        nextLevel = []</div><div class="line"></div><div class="line">LevelBianli(root)   <span class="comment"># A B E H F C D K G</span></div></pre></td></tr></table></figure>
<h2 id="二叉树小结"><a href="#二叉树小结" class="headerlink" title="二叉树小结"></a>二叉树小结</h2><ul>
<li>二叉树是度不超过 2 的树</li>
<li>满二叉树与完全二叉树</li>
<li>（完全）二叉树可以用列表来存储，通过规律可以从父亲找到孩子或者孩子找到父亲</li>
<li>二叉树遍历方式 : <code>前序遍历</code> <code>中序遍历</code> <code>后序遍历</code></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[递归]]></title>
      <url>/2017/12/recursion.html</url>
      <content type="html"><![CDATA[<p>在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。</p>
<p><strong>特点：</strong></p>
<ul>
<li>调用自身</li>
<li>结束条件</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(x)</span>:</span></div><div class="line">    print(x)</div><div class="line">    func1(x<span class="number">-1</span>)</div><div class="line"></div><div class="line"><span class="comment"># func1(3)  # 死递归 没有结束条件</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span>:</div><div class="line">        print(x)</div><div class="line">        func2(x+<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="comment"># func2(3)    # 3,4,5,6...  有结束条件，如果是正数还是会陷入死递归</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func3</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span>:</div><div class="line">        print(x)</div><div class="line">        func3(x<span class="number">-1</span>)</div><div class="line"></div><div class="line"><span class="comment"># func3(3)  # 3,2,1   有结束条件</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func4</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span>:</div><div class="line">        func4(x<span class="number">-1</span>)</div><div class="line">        print(x)</div><div class="line"></div><div class="line"><span class="comment"># func4(3)    # 1,2,3 有结束条件</span></div></pre></td></tr></table></figure>
<p>递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出）</p>
<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><img src="https://i.imgur.com/Z1qnoKw.jpg" alt="dog递归"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(depth)</span>:</span></div><div class="line">    <span class="keyword">if</span> depth == <span class="number">0</span>:</div><div class="line">        print(<span class="string">'我的小鲤鱼'</span>,end=<span class="string">''</span>)   <span class="comment"># 取消换行</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        print(<span class="string">'抱着'</span>,end=<span class="string">''</span>)</div><div class="line">        func(depth<span class="number">-1</span>)</div><div class="line">        print(<span class="string">'的我'</span>,end=<span class="string">''</span>)</div><div class="line"></div><div class="line">func(<span class="number">3</span>) <span class="comment"># 抱着抱着抱着我的小鲤鱼的我的我的我</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 利用递归函数计算阶乘</span></div><div class="line"><span class="comment"># N! = 1 * 2 * 3 * ... * N</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> n * fact(n<span class="number">-1</span>)</div><div class="line"></div><div class="line">print(<span class="string">'fact(1) ='</span>, fact(<span class="number">1</span>))</div><div class="line">print(<span class="string">'fact(5) ='</span>, fact(<span class="number">5</span>))</div><div class="line">print(<span class="string">'fact(10) ='</span>, fact(<span class="number">10</span>))</div><div class="line"></div><div class="line"><span class="comment"># 利用递归函数移动汉诺塔:</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(n, a, b, c)</span>:</span></div><div class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</div><div class="line">        print(<span class="string">'move'</span>, a, <span class="string">'--&gt;'</span>, c)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        move(n<span class="number">-1</span>, a, c, b)</div><div class="line">        move(<span class="number">1</span>, a, b, c)</div><div class="line">        move(n<span class="number">-1</span>, b, a, c)</div><div class="line"></div><div class="line">move(<span class="number">4</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>)</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[常用排序算法]]></title>
      <url>/2017/12/list-algorithm.html</url>
      <content type="html"><![CDATA[<p><strong>重点:</strong></p>
<ul>
<li>有序区</li>
<li>无序区</li>
</ul>
<h1 id="冒泡排序（BUB）"><a href="#冒泡排序（BUB）" class="headerlink" title="冒泡排序（BUB）"></a>冒泡排序（BUB）</h1><blockquote>
<p>列表每两个相邻的数, 如果前边的比后边的大, 那么交换这两个数</p>
</blockquote>
<p><strong>冒泡排序算法的流程如下：</strong></p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<p><img src="https://i.imgur.com/T0nk855.gif" alt="冒泡排序"></p>
<p><strong>关键点:</strong>  趟, 无序区</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># O(n²) 时间复杂度</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(li)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(li) &lt;= <span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> li</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(li)<span class="number">-1</span>): <span class="comment"># i 是趟</span></div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(li)-i - <span class="number">1</span>): <span class="comment"># j 是指针</span></div><div class="line">            <span class="keyword">if</span> li[j] &gt; li[j+<span class="number">1</span>]:</div><div class="line">                li[j], li[j+<span class="number">1</span>] = li[j+<span class="number">1</span>] , li[j]</div><div class="line">    <span class="keyword">return</span> li</div><div class="line">li = list(range(<span class="number">10000</span>))</div><div class="line"><span class="keyword">import</span> random <span class="keyword">as</span> rd</div><div class="line">rd.shuffle(li) <span class="comment"># 打乱顺序</span></div><div class="line">print(li)</div><div class="line">print(bubble_sort(li))</div></pre></td></tr></table></figure>
<h2 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(li)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(li) &lt;= <span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> li</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(li) - <span class="number">1</span>):  <span class="comment"># i 是趟</span></div><div class="line">        exchange = Flase</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(li) - i - <span class="number">1</span>):  <span class="comment"># j 是指针</span></div><div class="line">            <span class="keyword">if</span> li[j] &gt; li[j + <span class="number">1</span>]:</div><div class="line">                li[j], li[j + <span class="number">1</span>] = li[j + <span class="number">1</span>], li[j]</div><div class="line">                exchange = <span class="keyword">True</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exchange:</div><div class="line">            <span class="keyword">break</span></div><div class="line">    <span class="keyword">return</span> li</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>空间时间复杂度</th>
<th>O(1)</th>
</tr>
</thead>
<tbody>
<tr>
<td>最坏时间复杂度</td>
<td>O(n²)</td>
</tr>
<tr>
<td>最优时间复杂度</td>
<td>O(n)</td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td>O(n²)</td>
</tr>
</tbody>
</table>
<h1 id="选择排序（SEL）"><a href="#选择排序（SEL）" class="headerlink" title="选择排序（SEL）"></a>选择排序（SEL）</h1><p>每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。<br><img src="https://i.imgur.com/Y7JK85g.gif" alt="选择排序"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(li)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(li) - <span class="number">1</span>):  <span class="comment"># i 是趟</span></div><div class="line">        min_doc = i</div><div class="line">        <span class="comment"># 找i位置到最后位置范围内最小的数</span></div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(li)):  <span class="comment"># i可以换成i+1,省去和自己比</span></div><div class="line">            <span class="keyword">if</span> li[j] &lt; li[min_doc]:</div><div class="line">                min_doc = j</div><div class="line">        <span class="comment"># 和无序区第一个数作交换</span></div><div class="line">        <span class="comment"># 可以加上 i==min_loc 的判断,省去和自己换</span></div><div class="line">        <span class="keyword">if</span> min_doc != i:</div><div class="line">            li[min_doc], li[i] = li[i], li[min_doc]</div><div class="line">        <span class="string">'''</span></div><div class="line">        i, j, min_doc 都是下标</div><div class="line">        '''</div><div class="line">    <span class="keyword">return</span> li</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>空间时间复杂度</th>
<th>O(1)</th>
</tr>
</thead>
<tbody>
<tr>
<td>最坏时间复杂度</td>
<td>O(n²)</td>
</tr>
<tr>
<td>最优时间复杂度</td>
<td>O(n²)</td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td>O(n²)</td>
</tr>
</tbody>
</table>
<h1 id="插入排序（INS）"><a href="#插入排序（INS）" class="headerlink" title="插入排序（INS）"></a>插入排序（INS）</h1><p>插入排序每次取出数组后半部分的第一个元素，在排好序的前半部分中，为其找到最合适的位置并进行插入(扑克牌)<br><img src="https://i.imgur.com/UzdoF4Z.gif" alt="插入排序"></p>
<ul>
<li>列表被分为有序区和无序区两个部分。最初有序区只有一个元素。</li>
<li>每次从无序区选择一个元素，插入到有序区的位置，直到无序区变空。</li>
</ul>
<p><strong>插入排序算法的流程如下：</strong></p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤 2~5</li>
</ol>
<p><strong>关键点：</strong></p>
<ul>
<li>摸到的牌</li>
<li>手里的牌 (有序)</li>
</ul>
<h2 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(li)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(li) == <span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> li</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(li)):  <span class="comment"># i代表每次摸到的牌的下标</span></div><div class="line">        tmp = li[i]</div><div class="line">        j = i - <span class="number">1</span>  <span class="comment"># j代表手里最后一张牌的下标</span></div><div class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> tmp &lt; li[j]: <span class="comment"># 摸到的牌比手牌最后的牌小</span></div><div class="line">            li[j + <span class="number">1</span>] = li[j] <span class="comment"># 把最大的手牌往后挪动</span></div><div class="line">            j -= <span class="number">1</span></div><div class="line">        li[j + <span class="number">1</span>] = tmp <span class="comment"># 摸到的牌比手牌最后的牌大</span></div><div class="line">    <span class="keyword">return</span> li</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>空间时间复杂度</th>
<th>O(1)</th>
</tr>
</thead>
<tbody>
<tr>
<td>最坏时间复杂度</td>
<td>O(n²)</td>
</tr>
<tr>
<td>最优时间复杂度</td>
<td>O(n²)</td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td>O(n²)</td>
</tr>
</tbody>
</table>
<h1 id="快速排序（QUI）"><a href="#快速排序（QUI）" class="headerlink" title="快速排序（QUI）"></a>快速排序（QUI）</h1><p>博主看动图不是很理解, 建议看 <a href="http://bbs.ahalei.com/thread-4419-1-1.html" target="_blank" rel="external">这里</a><br><img src="https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" alt="快速排序"><br><img src="https://i.imgur.com/mEG5lt2.gif" alt="快速排序"></p>
<p><strong>快速排序算法的流程如下：</strong></p>
<ul>
<li>取一个元素p（第一个元素），使元素p归位；</li>
<li>列表被p分成两部分，左边都比p小，右边都比p大；</li>
<li>递归完成排序。</li>
</ul>
<p><strong>关键点：</strong></p>
<ul>
<li>整理(让元素归位)</li>
<li>递归</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(data, left, right)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    partition:归位函数</div><div class="line">    右手左手一个慢动作</div><div class="line">    右手左手慢动作重播</div><div class="line">    '''</div><div class="line">    tmp = data[left] <span class="comment"># 取基准数</span></div><div class="line">    <span class="keyword">while</span> left &lt; right:</div><div class="line">        <span class="comment"># 如果需要降序排序的话, 就把 data[right] &gt;= tmp 中的小于等于改为大于等于</span></div><div class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> data[right] &gt;= tmp:</div><div class="line">            right -= <span class="number">1</span> <span class="comment"># 左移</span></div><div class="line">        <span class="keyword">if</span> left &lt; right: <span class="comment"># 如果上面的循环是因为找到了 right 小于 tmp 的数而跳出循环</span></div><div class="line">            data[left] = data[right] <span class="comment"># 把小于 tmp 的这个元素放到 tmp 的位置上</span></div><div class="line">        <span class="comment"># 如果需要降序排序的话, 就把 data[right] &gt;= tmp 中的大于等于改为小于等于</span></div><div class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> data[left] &lt;= tmp:</div><div class="line">            left += <span class="number">1</span> <span class="comment"># 右移</span></div><div class="line">        data[right] = data[left] <span class="comment"># 把大于 tmp 的这个元素放到 tmp 的位置上</span></div><div class="line">    data[left] = tmp <span class="comment"># 那个 mid 回来</span></div><div class="line">    <span class="keyword">return</span> left</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_quick_sort</span><span class="params">(data, left, right)</span>:</span></div><div class="line">    <span class="keyword">if</span> left &lt; right:</div><div class="line">        mid = partition(data, left, right)</div><div class="line">        _quick_sort(data, left, mid - <span class="number">1</span>)</div><div class="line">        _quick_sort(data, mid + <span class="number">1</span>, right)</div><div class="line"></div><div class="line"><span class="meta">@cal_time</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(data)</span>:</span></div><div class="line">    <span class="keyword">return</span> _quick_sort(data,<span class="number">0</span>,len(data)<span class="number">-1</span>)</div></pre></td></tr></table></figure>
<h2 id="优化版-1"><a href="#优化版-1" class="headerlink" title="优化版"></a>优化版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 来自知乎 @风满楼</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(lists, left, right)</span>:</span></div><div class="line">    <span class="keyword">if</span> left &gt; right:</div><div class="line">        <span class="keyword">return</span> lists</div><div class="line">    low, high = left, right</div><div class="line">    key = lists[left]  <span class="comment"># key即是基准数</span></div><div class="line">    <span class="keyword">while</span> left &lt; right:</div><div class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> lists[right] &gt;= key:</div><div class="line">            right -= <span class="number">1</span> <span class="comment"># 左移</span></div><div class="line">        lists[left] = lists[right] </div><div class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> lists[left] &lt;= key:</div><div class="line">            left += <span class="number">1</span> <span class="comment"># 右移</span></div><div class="line">        lists[right] = lists[left]</div><div class="line">    lists[right] = key</div><div class="line">    quick_sort(lists, low, left - <span class="number">1</span>)</div><div class="line">    quick_sort(lists, right + <span class="number">1</span>, high)</div><div class="line">    <span class="keyword">return</span> lists</div><div class="line"></div><div class="line">quick(data,<span class="number">0</span>,len(data)<span class="number">-1</span>)</div></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>某些极端的情况下复杂度非常高, 如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">9 8 7 6 5 4 3 2 1</div></pre></td></tr></table></figure>
<p>出现的概率不多, 属于极端情况, 解决方法: 选基准的时候随机选一个数与第一个数交换。</p>
<table>
<thead>
<tr>
<th>空间时间复杂度</th>
<th>根据实现的方式不同而不同</th>
</tr>
</thead>
<tbody>
<tr>
<td>最坏时间复杂度</td>
<td>O(n²)</td>
</tr>
<tr>
<td>最优时间复杂度</td>
<td>O(nlogn)</td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td>O(nlogn)</td>
</tr>
</tbody>
</table>
<p>PS: 看到一个最狠的快排</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># https://github.com/qiwsir/algorithm/blob/master/quick_sort.md</span></div><div class="line">qs = <span class="keyword">lambda</span> xs : ( (len(xs) &lt;= <span class="number">1</span> <span class="keyword">and</span> [xs]) <span class="keyword">or</span> [ qs( [x <span class="keyword">for</span> x <span class="keyword">in</span> xs[<span class="number">1</span>:] <span class="keyword">if</span> x &lt; xs[<span class="number">0</span>]] ) + [xs[<span class="number">0</span>]] + qs( [x <span class="keyword">for</span> x <span class="keyword">in</span> xs[<span class="number">1</span>:] <span class="keyword">if</span> x &gt;= xs[<span class="number">0</span>]] ) ] )[<span class="number">0</span>]</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://ictar.github.io/2015/12/08/%E4%B9%9D%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6Python%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" target="_blank" rel="external">Ele - A面</a></li>
<li><a href="http://bbs.ahalei.com/thread-4419-1-1.html" target="_blank" rel="external">http://bbs.ahalei.com/thread-4419-1-1.html</a></li>
<li><a href="http://blog.csdn.net/v_july_v/article/details/6116297" target="_blank" rel="external">http://blog.csdn.net/v_july_v/article/details/6116297</a></li>
<li><a href="https://www.zhihu.com/question/26786398" target="_blank" rel="external">https://www.zhihu.com/question/26786398</a></li>
<li><a href="https://hellolynn.hpd.io/2017/08/03/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-quick-sort/" target="_blank" rel="external">https://hellolynn.hpd.io/2017/08/03/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-quick-sort/</a></li>
<li><a href="https://github.com/qiwsir/algorithm/blob/master/quick_sort.md" target="_blank" rel="external">https://github.com/qiwsir/algorithm/blob/master/quick_sort.md</a></li>
</ul>
<h1 id="堆排序（HEAP）"><a href="#堆排序（HEAP）" class="headerlink" title="堆排序（HEAP）"></a>堆排序（HEAP）</h1><p>堆排序用的是<a href="/2017/12/data-structure-tree.html">树</a>的结构<br><img src="https://i.imgur.com/JH2f8TO.jpg" alt="树（数据结构）"></p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ul>
<li>大根堆：一棵完全二叉树，满足任一节点都比其孩子节点大</li>
<li>小根堆：一棵完全二叉树，满足任一节点都比其孩子节点小</li>
</ul>
<p><img src="https://i.imgur.com/ShbrOiR.jpg" alt="大小根堆"></p>
<p><strong>假设：节点的左右子树都是堆，但自身不是堆</strong></p>
<blockquote>
<p>当根节点的左右子树都是堆时，可以通过一次向下的调整来将其变换成一个堆。</p>
</blockquote>
<p><img src="https://i.imgur.com/Vyt45u6.gif" alt="调整"></p>
<p><strong>堆排序过程:</strong></p>
<ol>
<li>建立堆</li>
<li>得到堆顶元素，为最大元素</li>
<li>去掉堆顶，将堆最后一个元素放到堆顶，此时可通过一次调整重新使堆有序。</li>
<li>堆顶元素为第二大元素。</li>
<li>重复步骤3，直到堆变空。</li>
</ol>
<ul>
<li>构建堆</li>
</ul>
<p>先从最小的子树开始看, 最后一步看整个的堆; 从最后一个非叶子节点为根的子树开始做调整<br><img src="https://i.imgur.com/VF7ia3X.gif" alt="构建堆"></p>
<ul>
<li>挨个出数</li>
</ul>
<p><img src="https://i.imgur.com/4fYb7L4.gif" alt="挨个出数"></p>
<h2 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift</span><span class="params">(data, low, high)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    调整函数</div><div class="line">    data: 列表</div><div class="line">    low：待调整的子树的根位置</div><div class="line">    high：待调整的子树的最后一个节点的位置</div><div class="line">    """</div><div class="line">    i = low</div><div class="line">    j = <span class="number">2</span> * i + <span class="number">1</span></div><div class="line">    tmp = data[i]</div><div class="line">    <span class="comment"># i指向空位置</span></div><div class="line">    <span class="keyword">while</span> j&lt;=high:      <span class="comment">#领导已经撸到底了</span></div><div class="line">        <span class="keyword">if</span> j != high <span class="keyword">and</span> data[j] &lt; data[j+<span class="number">1</span>]:</div><div class="line">            j += <span class="number">1</span></div><div class="line">        <span class="comment">#j指向数值大的孩子</span></div><div class="line">        <span class="keyword">if</span> tmp &lt; data[j]:   <span class="comment">#如果小领导比撸下来的大领导能力值大</span></div><div class="line">            data[i] = data[j]</div><div class="line">            i = j</div><div class="line">            j = <span class="number">2</span>*i+<span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">break</span>       <span class="comment">#撸下来的领导比候选的领导能力值大</span></div><div class="line">    data[i] = tmp</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(data)</span>:</span></div><div class="line">    n = len(data)</div><div class="line">    <span class="comment"># 建堆 从最后一个非叶子节点所以是 -1(2) 列表倒序</span></div><div class="line">    <span class="comment"># n//2-1 找最后一个非叶子节点</span></div><div class="line">    <span class="comment"># -1(1) 顾前不顾后</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n//<span class="number">2</span><span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">        sift(data, i,  n - <span class="number">1</span>) <span class="comment"># 这里的 n-1 是把所有子树的 high 都设置成整个堆的 high</span></div><div class="line">    <span class="comment"># 挨个出数</span></div><div class="line">    <span class="keyword">for</span> high <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">        data[<span class="number">0</span>], data[high] = data[high], data[<span class="number">0</span>]</div><div class="line">        sift(data, <span class="number">0</span>, high - <span class="number">1</span>)</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>空间时间复杂度</th>
<th>O(n)，O(1)</th>
</tr>
</thead>
<tbody>
<tr>
<td>最坏时间复杂度</td>
<td>O(nlogn)</td>
</tr>
<tr>
<td>最优时间复杂度</td>
<td>O(nlogn)</td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td>O(nlogn)</td>
</tr>
</tbody>
</table>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a href="/数据结构：树/">数据结构：树</a></li>
<li><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="external">https://www.cnblogs.com/chengxiao/p/6129630.html</a></li>
<li><a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/" target="_blank" rel="external">http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/</a></li>
<li><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/" target="_blank" rel="external">http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/</a></li>
</ul>
<h1 id="归并排序（MER）"><a href="#归并排序（MER）" class="headerlink" title="归并排序（MER）"></a>归并排序（MER）</h1><p><img src="https://i.imgur.com/7sbKXQt.gif" alt="归并排序"><br><img src="https://i.imgur.com/FN392sX.gif" alt="归并排序"><br><strong>归并排序思路:</strong></p>
<ol>
<li>分解：将列表越分越小，直至分成一个元素。</li>
<li>一个元素是有序的。</li>
<li>合并：将两个有序列表归并，列表越来越大。</li>
</ol>
<p><img src="https://i.imgur.com/dXgFcwQ.png" alt="归并排序流程"></p>
<ol>
<li>递归地将数组划分为两部分</li>
<li>直到两个子数组元素都为1时，返回并将两个数组进行排序融合</li>
<li>逐步返回，并递归融合，最终使得数组有序</li>
</ol>
<h2 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(data, low, mid, high)</span>:</span></div><div class="line">    <span class="string">'''一次归并'''</span></div><div class="line">    i = low</div><div class="line">    j = mid + <span class="number">1</span></div><div class="line">    ltmp = []  <span class="comment"># 临时列表</span></div><div class="line">    <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= high:</div><div class="line">        <span class="keyword">if</span> data[i] &lt;= data[j]:</div><div class="line">            ltmp.append((data[i]))</div><div class="line">            i += <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:  <span class="comment"># data[i] &gt; data[j]</span></div><div class="line">            ltmp.append(data[j])</div><div class="line">            j += <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> i &lt;= mid:</div><div class="line">        ltmp.append(data[i])</div><div class="line">        i += <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> j &lt;= high:</div><div class="line">        ltmp.append(data[j])</div><div class="line">        j += <span class="number">1</span></div><div class="line">    data[low:high + <span class="number">1</span>] = ltmp</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergesort</span><span class="params">(data, low, high)</span>:</span></div><div class="line">    <span class="string">'''归并排序'''</span></div><div class="line">    <span class="keyword">if</span> low &lt; high:</div><div class="line">        mid = (low + high) // <span class="number">2</span> <span class="comment"># 获取中间位置</span></div><div class="line">        mergesort(data, low, mid) <span class="comment"># 分解左半部分</span></div><div class="line">        mergesort(data, mid + <span class="number">1</span>, high) <span class="comment"># 分解右半部分</span></div><div class="line">        merge(data, low, mid, high) <span class="comment"># 归并</span></div><div class="line">    <span class="keyword">return</span> data</div></pre></td></tr></table></figure>
<h2 id="加深理解"><a href="#加深理解" class="headerlink" title="加深理解"></a>加深理解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">if</span> x &gt; <span class="number">1</span>:</div><div class="line">        y = x // <span class="number">2</span></div><div class="line">        func(y)</div><div class="line">        func(y)</div><div class="line">        print(y)</div><div class="line">func(<span class="number">20</span>)</div><div class="line"><span class="comment"># 看最后的输出 画图</span></div></pre></td></tr></table></figure>
<p>或者结合<a href="/递归/">递归</a></p>
<p><img src="https://i.imgur.com/XBeGCIP.png" alt="递归输出"></p>
<table>
<thead>
<tr>
<th>空间时间复杂度</th>
<th>O(n)</th>
</tr>
</thead>
<tbody>
<tr>
<td>最坏时间复杂度</td>
<td>O(nlogn)</td>
</tr>
<tr>
<td>最优时间复杂度</td>
<td>O(n)</td>
</tr>
<tr>
<td>平均时间复杂度</td>
<td>O(nlogn)</td>
</tr>
</tbody>
</table>
<ul>
<li>快速排序、堆排序、归并排序 - 小结</li>
</ul>
<p>三种排序算法的时间复杂度都是O(nlogn)</p>
<ul>
<li>运行时间:</li>
</ul>
<p><code>快速排序</code> &lt; <code>归并排序</code> &lt; <code>堆排序</code></p>
<p>三种排序算法的缺点：</p>
<table>
<thead>
<tr>
<th>快速排序</th>
<th>极端情况下排序效率低</th>
</tr>
</thead>
<tbody>
<tr>
<td>归并排序</td>
<td>需要额外的内存开销</td>
</tr>
<tr>
<td>堆排序</td>
<td>在快的排序算法中相对较慢</td>
</tr>
</tbody>
</table>
<h1 id="计数排序（COU）"><a href="#计数排序（COU）" class="headerlink" title="计数排序（COU）"></a>计数排序（COU）</h1><p><img src="https://i.imgur.com/piK8FYS.gif" alt="计数排序"></p>
<blockquote>
<p>题: 现在有一个列表，列表中的数范围都在 0 到 100 之间，列表长度大约为 100 万。设计算法在 O(n) 时间复杂度内将列表进行排序。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_sort</span><span class="params">(data, maxnum = <span class="number">100</span>)</span>:</span></div><div class="line">    <span class="string">'''计数排序  O(n)'''</span></div><div class="line">    count = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(maxnum+<span class="number">1</span>)]</div><div class="line">    result = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</div><div class="line">        count[i] += <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> num,count <span class="keyword">in</span> enumerate(count):</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</div><div class="line">            result.append(num)</div><div class="line"><span class="comment"># 或</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_sort</span><span class="params">(data, max_num)</span>:</span></div><div class="line">    count = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(max_num + <span class="number">1</span>)]</div><div class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> data:</div><div class="line">        count[num] += <span class="number">1</span></div><div class="line">    i = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> num, m <span class="keyword">in</span> enumerate(count):</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</div><div class="line">            data[i] = num</div><div class="line">            i += <span class="number">1</span></div></pre></td></tr></table></figure>
<p>因为要开额外的内存空间，所以使用并不多。计数排序限定元素不会太大的时候，如：年龄可以使用计数排序</p>
<h1 id="希尔排序（SHE）"><a href="#希尔排序（SHE）" class="headerlink" title="希尔排序（SHE）"></a>希尔排序（SHE）</h1><p>希尔排序是一种分组插入排序算法。O(1.3n)</p>
<p><img src="https://i.imgur.com/s1gQYYA.gif" alt="希尔排序"></p>
<ol>
<li>以数组元素长度的一半做为初始步长gap，将数组划分为gap个子数组</li>
<li>循环切换遍历子数组，在子数组内分别进行插入排序</li>
<li>将gap更新为gap/2，重复上述步骤1，2，直到gap为1</li>
</ol>
<p><img src="https://i.imgur.com/HXBOgwr.jpg" alt="步长为4的shell sort示例"></p>
<p><strong>希尔排序思路：</strong></p>
<ol>
<li>先取一个正整数 d<sub>1</sub>(d<sub>1</sub> &lt; n)，把全部记录分成 d<sub>1</sub> 个组，所有距离为 d<sub>1</sub> 的倍数的记录看成一组，然后在各组内进行插入排序</li>
<li>然后取 d<sub>2</sub>(d<sub>2</sub> &lt; d<sub>1</sub>)</li>
<li>重复上述分组和排序操作；直到取 d<sub>i</sub> = 1(i &gt;= 1) 位置，即所有记录成为一个组，最后对这个组进行插入排序。一般选 d1 约为 n/2，d<sub>2</sub> 为 d<sub>1</sub> /2， d<sub>3</sub> 为 d<sub>2</sub>/2 ，…， d<sub>i</sub> = 1。</li>
</ol>
<p>希尔排序每趟并不使某些元素有序，而是使整体数据越来越接近有序；最后一趟排序使得所有数据有序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 修改插入排序</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort_gap</span><span class="params">(data, gap)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, len(data)):</div><div class="line">        tmp = data[i]</div><div class="line">        j = i - gap</div><div class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> tmp &lt; data[j]:</div><div class="line">            data[j + gap] = data[j]</div><div class="line">            j = j - gap</div><div class="line">        data[j + gap] = tmp</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(data)</span>:</span></div><div class="line">    <span class="string">'''希尔排序'''</span></div><div class="line">    d = len(data) // <span class="number">2</span></div><div class="line">    <span class="keyword">while</span> d &gt; <span class="number">0</span>:</div><div class="line">        insert_sort_gap(data,d)</div><div class="line">        d = d // <span class="number">2</span></div><div class="line">    <span class="keyword">return</span> data</div></pre></td></tr></table></figure>
<h2 id="优化版-2"><a href="#优化版-2" class="headerlink" title="优化版"></a>优化版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(data)</span>:</span></div><div class="line">    n = len(data)</div><div class="line">    gap = len(data) // <span class="number">2</span></div><div class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, n):</div><div class="line">            tmp = data[i]</div><div class="line">            j = i - gap</div><div class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> tmp &lt; data[j]:</div><div class="line">                data[j + gap] = data[j]</div><div class="line">                j -= gap</div><div class="line">            data[j + gap] = tmp</div><div class="line">        gap = gap // <span class="number">2</span></div><div class="line">    <span class="keyword">return</span> data</div></pre></td></tr></table></figure>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><h2 id="排序算法指标"><a href="#排序算法指标" class="headerlink" title="排序算法指标"></a>排序算法指标</h2><p><img src="https://i.imgur.com/kkVSVGH.jpg" alt="排序算法指标"></p>
<h2 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h2><p>排序关键字相同的情况下，对象的相对位置不变</p>
<h2 id="计时装饰器"><a href="#计时装饰器" class="headerlink" title="计时装饰器"></a>计时装饰器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_time</span><span class="params">(func)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">        t1 = time.time()</div><div class="line">        x = func(*args, **kwargs)</div><div class="line">        t2 = time.time()</div><div class="line">        print(<span class="string">"%s running time %s secs."</span> % (func.__name__, t2 - t1))</div><div class="line">        <span class="keyword">return</span> x</div><div class="line">    <span class="keyword">return</span> wrapper</div></pre></td></tr></table></figure>
<h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>博客部分图片截取自 <a href="https://visualgo.net/zh/sorting" target="_blank" rel="external">https://visualgo.net/zh/sorting</a></li>
<li><a href="http://bubkoo.com" target="_blank" rel="external">http://bubkoo.com</a></li>
<li><a href="http://chenyvehtung.github.io/2017/02/26/sort-algorithms.html" target="_blank" rel="external">http://chenyvehtung.github.io/2017/02/26/sort-algorithms.html</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Category:%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="external">维基百科-排序算法</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo: ERROR Process failed: _posts/*]]></title>
      <url>/2017/12/hexo-ERROR-Process-failed-posts.html</url>
      <content type="html"><![CDATA[<p>文章的格式出现错误了</p>
<a id="more"></a>
<ul>
<li>错误提示</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ hexo s</div><div class="line">ERROR Process failed: _posts/*</div><div class="line">Error at </div><div class="line">.....</div></pre></td></tr></table></figure>
<ul>
<li>原因</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">title: Hexo</div><div class="line">date: 2017-12-13 12:21:33</div><div class="line">tags:Hexo #tags冒号后面应当有个空格,其他地方也应当注意</div></pre></td></tr></table></figure>
<ul>
<li>正确格式(加上那个空格就好了)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">title: Hexo</div><div class="line">date: 2017-12-13 12:21:33</div><div class="line">tags: Hexo</div></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://shitaibin.github.io/2015/12/13/hexo-errors/" target="_blank" rel="external">http://shitaibin.github.io/2015/12/13/hexo-errors/</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python:消息队列Rabbitmq基本使用]]></title>
      <url>/2017/12/rabbitmq-apply.html</url>
      <content type="html"><![CDATA[<p>为什么用Rabbitmq instead of python queue ?</p>
<a id="more"></a>
<blockquote>
<p>是因为python queue 不能跨进程 </p>
</blockquote>
<p><strong>队列的作用:</strong>    </p>
<pre><code>1. 存储消息、数据
2. 保证消息顺序 
3. 保证数据的交付
</code></pre><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 斐波那契数列</span></div><div class="line">1 1 2 3 5 8 13 ...</div><div class="line"><span class="comment"># 启动rabbitmq，并验证启动情况 </span></div><div class="line">rabbitmq-server --detached &amp;ps aux |grep rabbitmq</div><div class="line"><span class="comment"># 以服务的方式启动</span></div><div class="line">service rabbitmq-server start</div><div class="line"><span class="comment"># 启用维护插件</span></div><div class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management </div><div class="line"><span class="comment"># 重启</span></div><div class="line">service rabbitmq-server restart</div><div class="line"></div><div class="line"><span class="comment"># erroe</span></div><div class="line">pika.exceptions.ProbableAuthenticationError</div><div class="line"><span class="comment"># 解决方法</span></div><div class="line"><span class="comment"># 写入信息 并保存/关闭防火墙 'systemctl stop filewallf'</span></div><div class="line">vim /etc/rabbitmq/rabbitmq.config</div><div class="line">[&#123;rabbit, [&#123;loopback_users, []&#125;]&#125;].</div><div class="line"><span class="comment"># 查看当前队列</span></div><div class="line">rabbitmqctl list_queues</div></pre></td></tr></table></figure>
<h2 id="基本使用实现"><a href="#基本使用实现" class="headerlink" title="基本使用实现"></a>基本使用实现</h2><h3 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line"><span class="comment"># 创建连接</span></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 声明消息队列</span></div><div class="line">channel.queue_declare(queue=<span class="string">'hello'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 发送消息到上面声明的hello队列，</span></div><div class="line"><span class="comment"># 其中exchange表示交换器，能精确指定消息应该发送到哪个队列，</span></div><div class="line"><span class="comment"># routing_key设置为队列的名称，</span></div><div class="line"><span class="comment"># body就是发送的内容，</span></div><div class="line">channel.basic_publish(exchange=<span class="string">''</span>,routing_key=<span class="string">'hello'</span>,body=<span class="string">'Hello World!'</span>)</div><div class="line"></div><div class="line">print(<span class="string">'[x] Sent "Hello World!"'</span>)</div><div class="line"></div><div class="line"><span class="comment"># sh命令</span></div><div class="line"><span class="comment"># 用 rabbitmqctl list_queues 查看队列</span></div><div class="line"><span class="string">'''</span></div><div class="line">Listing queues</div><div class="line">hello	1</div><div class="line">'''</div></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/6vYEGPV.jpg" alt=""></p>
<h3 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line"><span class="comment"># 创建连接</span></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(<span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 声明消息队列</span></div><div class="line">channel.queue_declare(queue=<span class="string">'hello'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 接收消息 回调函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callbcak</span><span class="params">(ch,method,properties,body)</span>:</span></div><div class="line">    print(<span class="string">"Received %r"</span>%(body))</div><div class="line"></div><div class="line"><span class="comment"># 告诉rabbitmq使用callback来接收信息</span></div><div class="line">channel.basic_consume(callbcak,queue=<span class="string">'hello'</span>,no_ack=<span class="keyword">True</span>)</div><div class="line"></div><div class="line"><span class="comment">#开始接收信息，并进入阻塞状态，队列里有信息才会调用callback进行处理。按ctrl+c退出。</span></div><div class="line">channel.start_consuming()</div><div class="line"></div><div class="line"><span class="comment"># 终端会阻塞住</span></div><div class="line"><span class="string">'''</span></div><div class="line">Received b'Hello World!'</div><div class="line">'''</div></pre></td></tr></table></figure>
<h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><h3 id="消息不丢失"><a href="#消息不丢失" class="headerlink" title="消息不丢失"></a>消息不丢失</h3><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">    msg = <span class="string">' '</span>.join(sys.argv[<span class="number">1</span>:])<span class="keyword">or</span> <span class="string">'Hello World! %s'</span> % time.time()</div><div class="line">    channel.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">                          routing_key=<span class="string">'hello'</span>,</div><div class="line">                          body=bytes(msg,encoding=<span class="string">'utf8'</span>),)</div></pre></td></tr></table></figure>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><ul>
<li><code>no_ack=False</code> 消费者退出不消息不丢失</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 修改回调函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callbcak</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">"Received %r"</span> % (body))</div><div class="line">    time.sleep(<span class="number">5</span>)</div><div class="line">    print(<span class="string">"[x] Done"</span>)</div></pre></td></tr></table></figure>
<h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><ul>
<li>消息持久化存储,</li>
</ul>
<blockquote>
<p>虽然消息反馈机制，但是如果rabbitmq自身挂掉的话，那么任务还是会丢失。所以需要将任务持久化存储起来。声明持久化存储：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 原队列</span></div><div class="line">channel.queue_declare(queue=<span class="string">'hello'</span>, durable=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<p>但是这个程序会执行错误，因为hello这个队列已经存在，并且是非持久化的，rabbitmq不允许使用不同的参数来重新定义存在的队列。重新定义一个队列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 重新定义一个队列</span></div><div class="line">channel.queue_declare(queue=<span class="string">'task_queue'</span>, durable=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<p>在发送任务的时候，用delivery_mode=2来标记任务为持久化存储：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">channel.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">       routing_key=<span class="string">"task_queue"</span>,</div><div class="line">       body=message,</div><div class="line">       properties=pika.BasicProperties(</div><div class="line">          delivery_mode = <span class="number">2</span>, <span class="comment"># make message persistent</span></div><div class="line">       ))</div></pre></td></tr></table></figure>
<h3 id="公平调度"><a href="#公平调度" class="headerlink" title="公平调度"></a>公平调度</h3><p><code>prefetch_count = 1</code></p>
<p>虽然每个工作者是依次分配到任务，但是每个任务不一定一样。可能有的任务比较重，执行时间比较久；有的任务比较轻，执行时间比较短。如果能公平调度就最好了，使用basic_qos设置prefetch_count=1，使得rabbitmq不会在同一时间给工作者分配多个任务，即只有工作者完成任务之后，才会再次接收到任务。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">channel.basic_qos(prefetch_count=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<ul>
<li>new_task.py完整代码</li>
</ul>
<blockquote>
<p>发送者/生产者</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    host=<span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line">channel.queue_declare(queue=<span class="string">'task_queue'</span>, durable=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">message = <span class="string">' '</span>.join(sys.argv[<span class="number">1</span>:]) <span class="keyword">or</span> <span class="string">"Hello World!"</span></div><div class="line">channel.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">                      routing_key=<span class="string">'task_queue'</span>,</div><div class="line">                      body=message,</div><div class="line">                      properties=pika.BasicProperties(</div><div class="line">                          delivery_mode=<span class="number">2</span>,  <span class="comment"># make message persistent</span></div><div class="line">                      ))</div><div class="line">print(<span class="string">" [x] Sent %r"</span> % (message,))</div><div class="line">connection.close()</div></pre></td></tr></table></figure>
<ul>
<li>worker.py完整代码</li>
</ul>
<blockquote>
<p>接受者/消费者</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line">channel.queue_declare(queue=<span class="string">'task_queue'</span>, durable=<span class="keyword">True</span>)</div><div class="line">print(<span class="string">' [*] Waiting for messages. To exit press CTRL+C'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">" [x] Received %r"</span> % (body,))</div><div class="line">    time.sleep(<span class="number">6</span>)</div><div class="line">    print(<span class="string">" [x] Done"</span>,ch.basic_ack(delivery_tag=method.delivery_tag))</div><div class="line"></div><div class="line"></div><div class="line">channel.basic_qos(prefetch_count=<span class="number">1</span>)</div><div class="line">channel.basic_consume(callback,</div><div class="line">                      queue=<span class="string">'task_queue'</span>)</div><div class="line"></div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure>
<h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>广播交换机的工作原理：消息发送端先将消息发送给交换机，交换机再将消息发送到绑定的消息队列，而后每个接收端都能从各自的消息队列里接收到信息。</p>
<p><img src="https://i.imgur.com/mK7MEC5.jpg" alt=""></p>
<h3 id="消费者-接收端receive-py代码分析"><a href="#消费者-接收端receive-py代码分析" class="headerlink" title="消费者/接收端receive.py代码分析"></a>消费者/接收端receive.py代码分析</h3><p>和最早的receive.py相比，主要是做了两个改动：</p>
<ul>
<li>定义交换机</li>
<li>不使用hello队列了，随机生成一个临时队列，并绑定到交换机上</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    <span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 定义交换机</span></div><div class="line">channel.exchange_declare(exchange=<span class="string">'messages'</span>, type=<span class="string">'fanout'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 随机生成队列，并绑定到交换机上</span></div><div class="line"><span class="comment"># 参数'exclusive=True'表示当接收端退出时，销毁临时产生的队列，这样就不会占用资源。</span></div><div class="line">result = channel.queue_declare(exclusive=<span class="keyword">True</span>)</div><div class="line">queue_name = result.method.queue</div><div class="line">channel.queue_bind(exchange=<span class="string">'messages'</span>, queue=queue_name)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">" [x] Received %r"</span> % (body,))</div><div class="line"></div><div class="line"></div><div class="line">channel.basic_consume(callback, queue=queue_name, no_ack=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">print(<span class="string">' [*] Waiting for messages. To exit press CTRL+C'</span>)</div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure>
<p>执行<code>rabbitmqctl list_queues</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">task_queue	0</div><div class="line">hello	5</div><div class="line"><span class="comment"># 定义了交换机</span></div><div class="line">amq.gen-K0M17k_3LVYO0b7m0s-K1g	0</div></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/1EuVNfF.jpg" alt=""></p>
<h3 id="生产者-发送端send-py代码分析"><a href="#生产者-发送端send-py代码分析" class="headerlink" title="生产者/发送端send.py代码分析"></a>生产者/发送端send.py代码分析</h3><p>和最早的send.py相比，也只做了两个改动：</p>
<ul>
<li>定义交换机</li>
<li>不是将消息发送到hello队列，而是发送到交换机</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    <span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 定义交换机</span></div><div class="line"><span class="comment"># type='fanout' 表示广播的意思</span></div><div class="line">channel.exchange_declare(exchange=<span class="string">'messages'</span>, type=<span class="string">'fanout'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 将消息发送到交换机</span></div><div class="line"><span class="comment"># basic_publish方法的参数exchange被设定为相应交换机，</span></div><div class="line"><span class="comment"># 因为是要广播出去，发送到所有队列，所以routing_key就不需要设定了。</span></div><div class="line">channel.basic_publish(exchange=<span class="string">'messages'</span>, routing_key=<span class="string">''</span>, body=<span class="string">'Hello World!'</span>)</div><div class="line">print(<span class="string">" [x] Sent 'Hello World!'"</span>)</div><div class="line">connection.close()</div></pre></td></tr></table></figure>
<p>exchange如果为空，表示是使用匿名的交换机，在上面交换机信息的图片中可以看到有amq.*这样的交换机，就是系统默认的交换机了。routing_key在使用匿名交换机的时候才需要指定，表示发送到哪个队列的意思。第一篇的例子演示了这个功能。</p>
<p>打开另外一个终端，执行send.py，可以观察到receive.py接收到了消息。如果有多个终端执行receive.py，那么每个receive.py都会接收到消息。</p>
<h2 id="组播-路由"><a href="#组播-路由" class="headerlink" title="组播/路由"></a>组播/路由</h2><h3 id="生产者-send-py代码分析"><a href="#生产者-send-py代码分析" class="headerlink" title="生产者/send.py代码分析"></a>生产者/send.py代码分析</h3><p>和广播相比，改动点主要在两个方面：</p>
<ul>
<li>设定交换机的类型（type）为direct。上一篇是设置为fanout，表示广播的意思，会将消息发送到所有接收端，这里设置为direct表示要根据设定的路由键来发送消息。</li>
<li>发送信息时设置发送的路由键。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    <span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 定义交换机，设置类型为direct</span></div><div class="line">channel.exchange_declare(exchange=<span class="string">'messages'</span>, type=<span class="string">'direct'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 定义三个路由键</span></div><div class="line">routings = [<span class="string">'warning'</span>, <span class="string">'error'</span>]</div><div class="line"></div><div class="line"><span class="comment"># 将消息依次发送到交换机，并设置路由键</span></div><div class="line"><span class="keyword">for</span> routing <span class="keyword">in</span> routings:</div><div class="line">    message = <span class="string">'%s message.'</span> % routing</div><div class="line">    channel.basic_publish(exchange=<span class="string">'messages'</span>,</div><div class="line">                          routing_key=routing,</div><div class="line">                          body=message)</div><div class="line">    print(message)</div><div class="line"></div><div class="line">connection.close()</div></pre></td></tr></table></figure>
<h3 id="消费者-receive-py代码分析"><a href="#消费者-receive-py代码分析" class="headerlink" title="消费者/receive.py代码分析"></a>消费者/receive.py代码分析</h3><p>和广播相比，改动点主要在三个方面：</p>
<ul>
<li>设定交换机的类型（type）为direct。</li>
<li>增加命令行获取参数功能，参数即为路由键。</li>
<li>将队列绑定到交换机上时，设定路由键。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika, sys</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    <span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 定义交换机，设置类型为direct</span></div><div class="line">channel.exchange_declare(exchange=<span class="string">'messages'</span>, type=<span class="string">'direct'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 从命令行获取路由键参数，如果没有，则设置为info</span></div><div class="line">routings = sys.argv[<span class="number">1</span>:]</div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> routings:</div><div class="line">    routings = [<span class="string">'info'</span>]</div><div class="line"></div><div class="line"><span class="comment"># 生成临时队列，并绑定到交换机上，设置路由键</span></div><div class="line">result = channel.queue_declare(exclusive=<span class="keyword">True</span>)</div><div class="line">queue_name = result.method.queue</div><div class="line"><span class="keyword">for</span> routing <span class="keyword">in</span> routings:</div><div class="line">    channel.queue_bind(exchange=<span class="string">'messages'</span>,</div><div class="line">                       queue=queue_name,</div><div class="line">                       routing_key=routing)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">" [x] Received %r"</span> % (body,))</div><div class="line"></div><div class="line"></div><div class="line">channel.basic_consume(callback, queue=queue_name, no_ack=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">print(<span class="string">' [*] Waiting for messages. To exit press CTRL+C'</span>)</div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure>
<p>打开两个终端，一个运行代码python receive.py info warning，表示只接收info和warning的消息。另外一个终端运行send.py，可以观察到接收终端只接收到了info和warning的消息。如果打开多个终端运行receive.py，并传入不同的路由键参数，可以看到更明显的效果。</p>
<p>当接收端正在运行时，可以使用rabbitmqctl list_bindings来查看绑定情况。</p>
<h2 id="按规则发送-正则"><a href="#按规则发送-正则" class="headerlink" title="按规则发送/正则"></a>按规则发送/正则</h2><p>上面路由键/组播的功能，通过设置路由键，可以将消息发送到相应的队列，这里的路由键是要完全匹配，比如info消息的只能发到路由键为info的消息队列。</p>
<p>路由键模糊匹配，就是可以使用正则表达式，和常用的正则表示式不同，这里的话“#”表示所有、全部的意思；“*”只匹配到一个词。看完示例就能明白了。</p>
<h3 id="send-py代码分析"><a href="#send-py代码分析" class="headerlink" title="send.py代码分析"></a>send.py代码分析</h3><p>因为要进行路由键模糊匹配，所以交换机的类型要设置为topic，设置为topic，就可以使用#，*的匹配符号了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    <span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 定义交换机，设置类型为topic</span></div><div class="line">channel.exchange_declare(exchange=<span class="string">'messages'</span>, type=<span class="string">'topic'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 定义路由键</span></div><div class="line"><span class="comment"># 四种类型的消息</span></div><div class="line">routings = [<span class="string">'happy.work'</span>, <span class="string">'happy.life'</span>, <span class="string">'sad.work'</span>, <span class="string">'sad.life'</span>]</div><div class="line"></div><div class="line"><span class="comment"># 将消息依次发送到交换机，并设定路由键</span></div><div class="line"><span class="keyword">for</span> routing <span class="keyword">in</span> routings:</div><div class="line">    message = <span class="string">'%s message.'</span> % routing</div><div class="line">    channel.basic_publish(exchange=<span class="string">'messages'</span>,</div><div class="line">                          routing_key=routing,</div><div class="line">                          body=message)</div><div class="line">    print(message)</div><div class="line"></div><div class="line">connection.close()</div></pre></td></tr></table></figure>
<h3 id="receive-py代码分析"><a href="#receive-py代码分析" class="headerlink" title="receive.py代码分析"></a>receive.py代码分析</h3><p>类型要设定为topic就可以了。从命令行接收参数的功能稍微调整了一下，没有参数时报错退出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika, sys</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    <span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 定义交换机，设置类型为topic</span></div><div class="line">channel.exchange_declare(exchange=<span class="string">'messages'</span>, type=<span class="string">'topic'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 从命令行获取路由参数，如果没有，则报错退出</span></div><div class="line">routings = sys.argv[<span class="number">1</span>:]</div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> routings:</div><div class="line">    <span class="comment"># print(&gt;&gt; sys.stderr, "Usage: %s [routing_key]..." % (sys.argv[0],))</span></div><div class="line">    print(sys.stderr, <span class="string">"Usage: %s [routing_key]..."</span> % (sys.argv[<span class="number">0</span>],))</div><div class="line">    exit()</div><div class="line"></div><div class="line"><span class="comment"># 生成临时队列，并绑定到交换机上，设置路由键</span></div><div class="line">result = channel.queue_declare(exclusive=<span class="keyword">True</span>)</div><div class="line">queue_name = result.method.queue</div><div class="line"><span class="keyword">for</span> routing <span class="keyword">in</span> routings:</div><div class="line">    channel.queue_bind(exchange=<span class="string">'messages'</span>,</div><div class="line">                       queue=queue_name,</div><div class="line">                       routing_key=routing)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">" [x] Received %r"</span> % (body,))</div><div class="line"></div><div class="line"></div><div class="line">channel.basic_consume(callback, queue=queue_name, no_ack=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">print(<span class="string">' [*] Waiting for messages. To exit press CTRL+C'</span>)</div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure>
<h3 id="实验运行"><a href="#实验运行" class="headerlink" title="实验运行"></a>实验运行</h3><p>打开多个终端,分别传入不同的规则,观察结果<br>如:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">python3 receive_topic.py <span class="string">"#"</span></div><div class="line">python3 receive_topic.py <span class="string">"happy.*"</span></div><div class="line">python3 receive_topic.py <span class="string">"*.work"</span></div></pre></td></tr></table></figure>
<h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p>1、发送信息时，如果不设置路由键，那么路由键设置为”*”的接收端是否能接收到消息？</p>
<blockquote>
<p>发送信息时，如果不设置路由键，默认是表示广播出去，理论上所有接收端都可以收到消息，但是笔者试了下，路由键设置为”*”的接收端收不到任何消息。</p>
<p>只有发送消息时，设置路由键为一个词，路由键设置为”*”的接收端才能收到消息。在这里，每个词使用”.”符号分开的。</p>
</blockquote>
<p>2、发送消息时，如果路由键设置为”..”，那么路由键设置为”#.*”的接收端是否能接收到消息？如果发送消息时，路由键设置为一个词呢？</p>
<blockquote>
<p>两种情况，笔者都测试过了，可以的。</p>
</blockquote>
<p>3、”a.*.#” 和”a.#”的区别</p>
<blockquote>
<ul>
<li><p>“a.#”只要字符串开头的一个词是a就可以了，比如a、a.haha、a.haha.haha。而这样的词是不行的，如abs、abc、abc.haha。</p>
</li>
<li><p>“a.<em>.#”必须要满足a.</em>的字符串才可以，比如a.、a.haha、a.haha.haha。而这样的词是不行的，如a。</p>
</li>
</ul>
</blockquote>
<h2 id="远程结果返回RPC"><a href="#远程结果返回RPC" class="headerlink" title="远程结果返回RPC"></a>远程结果返回RPC</h2><p>Remote Producre Call<br>处理方法描述：</p>
<blockquote>
<p>发送端在发送信息前，产生一个接收消息的临时队列，该队列用来接收返回的结果。其实在这里接收端、发送端的概念已经比较模糊了，因为发送端也同样要接收消息，接收端同样也要发送消息，所以这里笔者使用另外的示例来演示这一过程。</p>
</blockquote>
<h3 id="compute-py代码分析"><a href="#compute-py代码分析" class="headerlink" title="compute.py代码分析"></a>compute.py代码分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line"><span class="comment"># 连接rabbitmq服务器</span></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    host=<span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 定义队列</span></div><div class="line">channel.queue_declare(queue=<span class="string">'compute_queue'</span>)</div><div class="line">print(<span class="string">' [*] Waiting for n'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 将n值加1</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">increase</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">return</span> n + <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 定义接收到消息的处理方法</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">" [.] increase(%s)"</span> % (body,))</div><div class="line"></div><div class="line">    response = increase(int(body))</div><div class="line"></div><div class="line">    <span class="comment"># 将计算结果发送回控制中心</span></div><div class="line">    ch.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">                     routing_key=properties.reply_to,</div><div class="line">                     body=str(response))</div><div class="line">    ch.basic_ack(delivery_tag=method.delivery_tag)</div><div class="line"></div><div class="line"></div><div class="line">channel.basic_qos(prefetch_count=<span class="number">1</span>)</div><div class="line">channel.basic_consume(request, queue=<span class="string">'compute_queue'</span>)</div><div class="line"></div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure>
<h3 id="center-py代码分析"><a href="#center-py代码分析" class="headerlink" title="center.py代码分析"></a>center.py代码分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Center</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">            host=<span class="string">'10.211.55.10'</span>))</div><div class="line"></div><div class="line">        self.channel = self.connection.channel()</div><div class="line"></div><div class="line">        <span class="comment"># 定义接收返回消息的队列</span></div><div class="line">        result = self.channel.queue_declare(exclusive=<span class="keyword">True</span>)</div><div class="line">        self.callback_queue = result.method.queue</div><div class="line"></div><div class="line">        self.channel.basic_consume(self.on_response,</div><div class="line">                                   no_ack=<span class="keyword">True</span>,</div><div class="line">                                   queue=self.callback_queue)</div><div class="line"></div><div class="line">    <span class="comment"># 定义接收到返回消息的处理方法</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_response</span><span class="params">(self, ch, method, props, body)</span>:</span></div><div class="line">        self.response = body</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(self, n)</span>:</span></div><div class="line">        self.response = <span class="keyword">None</span></div><div class="line">        <span class="comment"># 发送计算请求，并声明返回队列</span></div><div class="line">        self.channel.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">                                   routing_key=<span class="string">'compute_queue'</span>,</div><div class="line">                                   properties=pika.BasicProperties(</div><div class="line">                                       reply_to=self.callback_queue,</div><div class="line">                                   ),</div><div class="line">                                   body=str(n))</div><div class="line">        <span class="comment"># 接收返回的数据</span></div><div class="line">        <span class="keyword">while</span> self.response <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            self.connection.process_data_events()</div><div class="line">        <span class="keyword">return</span> int(self.response)</div><div class="line"></div><div class="line"></div><div class="line">center = Center()</div><div class="line"></div><div class="line">print(<span class="string">" [x] Requesting increase(30)"</span>)</div><div class="line">response = center.request(<span class="number">30</span>)</div><div class="line">print(<span class="string">" [.] Got %r"</span> % (response,))</div></pre></td></tr></table></figure>
<p>上面代码定义了接收返回数据的队列和处理方法，并且在发送请求的时候将该队列赋值给<code>reply_to</code>，在计算节点代码中就是通过这个参数来获取返回队列的。</p>
<h2 id="相互关联编号correlation-id"><a href="#相互关联编号correlation-id" class="headerlink" title="相互关联编号correlation id"></a>相互关联编号correlation id</h2><p><code>correlation id</code>运行原理：</p>
<blockquote>
<p>控制中心发送计算请求时设置correlation id，而后计算节点将计算结果，连同接收到的correlation id一起返回，这样控制中心就能通过correlation id来标识请求。其实correlation id也可以理解为请求的唯一标识码。</p>
</blockquote>
<p>示例内容：</p>
<blockquote>
<p>控制中心开启多个线程，每个线程都发起一次计算请求，通过correlation id，每个线程都能准确收到相应的计算结果。</p>
</blockquote>
<h3 id="compute-py代码分析-1"><a href="#compute-py代码分析-1" class="headerlink" title="compute.py代码分析"></a>compute.py代码分析</h3><p>和上面相比，只需修改一个地方：</p>
<blockquote>
<p>将计算结果发送回控制中心时，增加参数correlation_id的设定，该参数的值其实是从控制中心发送过来的，这里只是再次发送回去。代码如下：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line"><span class="comment"># 连接rabbitmq服务器</span></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    host=<span class="string">'10.211.55.10'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line"><span class="comment"># 定义队列</span></div><div class="line">channel.queue_declare(queue=<span class="string">'compute_queue'</span>)</div><div class="line">print(<span class="string">' [*] Waiting for n'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 将n值加1</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">increase</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">return</span> n + <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 定义接收到消息的处理方法</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(ch, method, props, body)</span>:</span></div><div class="line">    print(<span class="string">" [.] increase(%s)"</span> % (body,))</div><div class="line"></div><div class="line">    response = increase(int(body))</div><div class="line"></div><div class="line">    <span class="comment"># 将计算结果发送回控制中心，增加correlation_id的设定</span></div><div class="line">    ch.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">                     routing_key=props.reply_to,</div><div class="line">                     properties=pika.BasicProperties(correlation_id= \</div><div class="line">                                                         props.correlation_id),</div><div class="line">                     body=str(response))</div><div class="line">    ch.basic_ack(delivery_tag=method.delivery_tag)</div><div class="line"></div><div class="line"></div><div class="line">channel.basic_qos(prefetch_count=<span class="number">1</span>)</div><div class="line">channel.basic_consume(request, queue=<span class="string">'compute_queue'</span>)</div><div class="line"></div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure>
<h3 id="center-py代码分析-1"><a href="#center-py代码分析-1" class="headerlink" title="center.py代码分析"></a>center.py代码分析</h3><p>控制中心代码稍微复杂些，其中比较关键的有三个地方：</p>
<ul>
<li>使用python的uuid来产生唯一的correlation_id。</li>
<li>发送计算请求时，设定参数correlation_id。</li>
<li>定义一个字典来保存返回的数据，并且键值为相应线程产生的correlation_id。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pika, threading, uuid</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 自定义线程类，继承threading.Thread</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, num)</span>:</span></div><div class="line">        super(MyThread, self).__init__()</div><div class="line">        self.func = func</div><div class="line">        self.num = num</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">" [x] Requesting increase(%d)"</span> % self.num)</div><div class="line">        response = self.func(self.num)</div><div class="line">        print(<span class="string">" [.] increase(%d)=%d"</span> % (self.num, response))</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 控制中心类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Center</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">            host=<span class="string">'10.211.55.10'</span>))</div><div class="line"></div><div class="line">        self.channel = self.connection.channel()</div><div class="line"></div><div class="line">        <span class="comment"># 定义接收返回消息的队列</span></div><div class="line">        result = self.channel.queue_declare(exclusive=<span class="keyword">True</span>)</div><div class="line">        self.callback_queue = result.method.queue</div><div class="line"></div><div class="line">        self.channel.basic_consume(self.on_response,</div><div class="line">                                   no_ack=<span class="keyword">True</span>,</div><div class="line">                                   queue=self.callback_queue)</div><div class="line"></div><div class="line">        <span class="comment"># 返回的结果都会存储在该字典里</span></div><div class="line">        self.response = &#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment"># 定义接收到返回消息的处理方法</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_response</span><span class="params">(self, ch, method, props, body)</span>:</span></div><div class="line">        self.response[props.correlation_id] = body</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(self, n)</span>:</span></div><div class="line">        corr_id = str(uuid.uuid4())     <span class="comment">#  产生 id</span></div><div class="line">        self.response[corr_id] = <span class="keyword">None</span></div><div class="line"></div><div class="line">        <span class="comment"># 发送计算请求，并设定返回队列和correlation_id</span></div><div class="line">        self.channel.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">                                   routing_key=<span class="string">'compute_queue'</span>,</div><div class="line">                                   properties=pika.BasicProperties(</div><div class="line">                                       reply_to=self.callback_queue,</div><div class="line">                                       correlation_id=corr_id,</div><div class="line">                                   ),</div><div class="line">                                   body=str(n))</div><div class="line">        <span class="comment"># 接收返回的数据</span></div><div class="line">        <span class="keyword">while</span> self.response[corr_id] <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            self.connection.process_data_events()</div><div class="line">        <span class="keyword">return</span> int(self.response[corr_id])</div><div class="line"></div><div class="line"></div><div class="line">center = Center()</div><div class="line"><span class="comment"># 发起5次计算请求</span></div><div class="line">nums = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]</div><div class="line">threads = []</div><div class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</div><div class="line">    threads.append(MyThread(center.request, num))</div><div class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</div><div class="line">    thread.start()</div><div class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</div><div class="line">    thread.join()</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.csdn.net/chenjiebin/article/details/8253433" target="_blank" rel="external">http://blog.csdn.net/chenjiebin/article/details/8253433</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Rabbitmq </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[密码学基础]]></title>
      <url>/2017/11/basis-of-cryptography.html</url>
      <content type="html"><![CDATA[<p>平常用的登录密码不叫密码，是登录口令</p>
<a id="more"></a>
<p>密码有一个加密和解密的过程</p>
<p><strong>video:</strong> <a href="https://youtu.be/loJ62rvH8aE" target="_blank" rel="external">https://youtu.be/loJ62rvH8aE</a></p>
<h2 id="古典密码"><a href="#古典密码" class="headerlink" title="古典密码"></a>古典密码</h2><h3 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ABC</div><div class="line">CDE</div><div class="line">// 往后移动3位或者多位</div></pre></td></tr></table></figure>
<p>非常容易破解</p>
<h3 id="维吉尼亚密码"><a href="#维吉尼亚密码" class="headerlink" title="维吉尼亚密码"></a>维吉尼亚密码</h3><blockquote>
<p>不知道密钥是非常非常难破解的</p>
</blockquote>
<p><img src="https://i.imgur.com/OAm1EPk.jpg" alt="维吉尼亚密码"></p>
<ul>
<li>RSA<ul>
<li>公钥</li>
<li>私钥 </li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">明文--&gt; 公钥 --&gt; 密文</div><div class="line">密文--&gt; 私钥 --&gt; 明文</div></pre></td></tr></table></figure>
<p>基于<code>大数难分解</code><br>两个质数相乘</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">p1 = <span class="number">53</span></div><div class="line">p2 = <span class="number">59</span></div><div class="line">n = <span class="number">3127</span>  <span class="comment"># 53 * 59 = 3127</span></div><div class="line"><span class="comment"># 欧拉函数</span></div><div class="line">Φ(n)(p1<span class="number">-1</span>)*(p2<span class="number">-1</span>)= <span class="number">3016</span> <span class="comment"># fai 小写 φ</span></div><div class="line">e = <span class="number">3</span>   <span class="comment"># e 和欧拉函数互质 只要互质随便取</span></div><div class="line"><span class="comment"># 公钥是 n，e</span></div><div class="line">d = (k*φ(n)+<span class="number">1</span>)/e = <span class="number">2011</span> <span class="comment"># 私钥 (2**3016+1)/3 = 2011</span></div><div class="line"></div><div class="line"><span class="comment"># 验证</span></div><div class="line">m = <span class="number">89</span> <span class="comment"># 加密信息 </span></div><div class="line">c = (m**e)%n = <span class="number">1394</span>   <span class="comment"># 密文 (89**3)%3127 = 1394</span></div><div class="line">明文 = (x**d)%n = <span class="number">89</span> <span class="comment"># 明文 (1394**2011)%3127 = 89</span></div></pre></td></tr></table></figure>
<p>扩展:</p>
<p><strong>费马小定理</strong>来验证.</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[列表查找]]></title>
      <url>/2017/09/list-search.html</url>
      <content type="html"><![CDATA[<a id="more"></a>
<h1 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h1><ul>
<li>从列表第一个元素开始，顺序进行搜索，直到找到为止。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">li = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line">index(<span class="number">1</span>)    <span class="comment"># 顺序查找</span></div><div class="line"></div><div class="line"><span class="comment"># 顺序查找 ipython  O(n) 复杂度</span></div><div class="line"><span class="keyword">import</span> random</div><div class="line">n = <span class="number">10000</span></div><div class="line">li = list(range(n))</div><div class="line">random.shuffle(li)</div><div class="line">%timeit li.index(<span class="number">3200</span>)</div><div class="line"><span class="comment">#221 µs ± 11.1 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</span></div></pre></td></tr></table></figure>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><blockquote>
<p>只能用于有序列表</p>
</blockquote>
<p>从有序列表的候选区<code>data[0:n]</code>开始，通过对待查找的值与候选区中间值的比较，可以使候选区减少一半。<code>O(logn)</code> 复杂度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 二分查找</span></div><div class="line"><span class="comment"># 循环版本</span></div><div class="line"><span class="comment"># def bin_search(li,low,high):</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bin_search</span><span class="params">(li, val)</span>:</span></div><div class="line">    <span class="string">'''循环二分 时间复杂度 O(logn)'''</span></div><div class="line">    low = <span class="number">0</span></div><div class="line">    high = len(li) - <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> low &lt;= high:</div><div class="line">        mid = (low + high) // <span class="number">2</span></div><div class="line">        <span class="keyword">if</span> li[mid] == val:</div><div class="line">            <span class="keyword">return</span> mid</div><div class="line">        <span class="keyword">elif</span> li[mid] &lt; val:</div><div class="line">            low = mid + <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:  <span class="comment"># &gt;</span></div><div class="line">            high = mid - <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line"><span class="comment"># 5.6 µs ± 441 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)</span></div><div class="line"></div><div class="line"><span class="comment"># 递归版本  递归需要切换进出栈</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bin_search_rec</span><span class="params">(data_set,value,low,high)</span>:</span></div><div class="line">    <span class="string">''' 尾递归 和 非递归的效率基本一样 '''</span></div><div class="line">    <span class="keyword">if</span> low &lt;= high:</div><div class="line">        mid = (low+high) // <span class="number">2</span></div><div class="line">        <span class="keyword">if</span> data_set[mid] == value:</div><div class="line">            <span class="keyword">return</span> mid</div><div class="line">        <span class="keyword">elif</span> data_set[mid] &gt; value:</div><div class="line">            <span class="comment"># 尾递归不用切换出栈</span></div><div class="line">            <span class="keyword">return</span> bin_search_rec(data_set,value,low,mid<span class="number">-1</span>)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> bin_search_rec(data_set,value,mid+<span class="number">1</span>,high)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span></div><div class="line"></div><div class="line"><span class="comment"># %timeit l1.index(3200)</span></div><div class="line"><span class="comment"># l1.sort()   # 排序</span></div><div class="line"><span class="comment"># %timeit bin_search(l1,3200)</span></div><div class="line">print(bin_search(l1,<span class="number">4000</span>))</div></pre></td></tr></table></figure>
<p>刷题：Letcode<br><a href="https://leetcode.com/problems/search-for-a-range/?tab=Description" target="_blank" rel="external">34. Search for a Range (二分查找升级版)</a><br><a href="https://leetcode.com/problems/two-sum/?tab=Description" target="_blank" rel="external">1. Two Sum</a></p>
<h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><p>1  <a href="https://leetcode.com/problems/search-for-a-range/?tab=Description" target="_blank" rel="external">34. Search for a Range (二分查找升级版)</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bin_search</span><span class="params">(li, val)</span>:</span></div><div class="line">    <span class="string">'''循环二分 时间复杂度 O(logn)'''</span></div><div class="line">    low = <span class="number">0</span></div><div class="line">    high = len(li) - <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> low &lt;= high:</div><div class="line">        mid = (low + high) // <span class="number">2</span></div><div class="line">        <span class="keyword">if</span> li[mid] == val:</div><div class="line">            a = mid</div><div class="line">            b = mid</div><div class="line">            <span class="keyword">while</span> li[a] = value <span class="keyword">and</span> a &gt;= <span class="number">1</span>:</div><div class="line">                a -= <span class="number">1</span></div><div class="line">            <span class="keyword">while</span> li[b] = value <span class="keyword">and</span> b &lt; len(li):    <span class="comment"># b &lt;= len(li) - 1</span></div><div class="line">                b += <span class="number">1</span></div><div class="line">            <span class="keyword">return</span> (a+<span class="number">1</span>,b<span class="number">-1</span>)</div><div class="line">        <span class="keyword">elif</span> li[mid] &lt; val:</div><div class="line">            low = mid + <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:  <span class="comment"># &gt;</span></div><div class="line">            high = mid - <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">None</span></div></pre></td></tr></table></figure>
<p>2 . <a href="https://leetcode.com/problems/two-sum/?tab=Description" target="_blank" rel="external">1. Two Sum</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_sum</span><span class="params">(nums, target)</span>:</span></div><div class="line">    l = len(nums)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,l):</div><div class="line">            print(nums[i],nums[j])</div><div class="line">            <span class="keyword">if</span> nums[i] + nums[j] == target:</div><div class="line">                <span class="keyword">return</span> (i,j)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">            </div><div class="line">print(two_sum([<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>],<span class="number">9</span>))</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bin_search</span><span class="params">(data_set, value)</span>:</span></div><div class="line">    low = <span class="number">0</span></div><div class="line">    high = len(data_set) - <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> low &lt;= high:</div><div class="line">        mid = (low + high) // <span class="number">2</span></div><div class="line">        <span class="keyword">if</span> data_set[mid] == value:</div><div class="line">            <span class="keyword">return</span> mid</div><div class="line">        <span class="keyword">elif</span> data_set[mid] &gt; value:</div><div class="line">            high = mid - <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            low = mid + <span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_sum_2</span><span class="params">(li, target)</span>:</span></div><div class="line">    li.sort()</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(li)):</div><div class="line">        b = target - li[i]</div><div class="line">        j = bin_search(li, b)</div><div class="line">        <span class="keyword">if</span> j != <span class="keyword">None</span> <span class="keyword">and</span> i != j:</div><div class="line">            <span class="keyword">return</span> i, j</div><div class="line"></div><div class="line">print(two_sum_2([<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>], <span class="number">14</span>))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_sum_3</span><span class="params">(li, target)</span>:</span></div><div class="line">    li.sort()   <span class="comment"># nlogn</span></div><div class="line">    i = <span class="number">0</span></div><div class="line">    j = len(li) - <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> i&lt;j:</div><div class="line">        sum = li[i]+li[j]</div><div class="line">        <span class="keyword">if</span> sum &gt; target:</div><div class="line">            j-=<span class="number">1</span></div><div class="line">        <span class="keyword">elif</span> sum &lt; target:</div><div class="line">            i+=<span class="number">1</span></div><div class="line">        <span class="keyword">else</span>: <span class="comment">#sum==target</span></div><div class="line">            <span class="keyword">return</span> (i,j)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">None</span></div></pre></td></tr></table></figure>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p><a href="https://leetcode.com/problems/two-sum/?tab=Description" target="_blank" rel="external">1. Two Sum</a> 如果是 3 个数 就把第一个数固定, 后面的列表用 two_sum_3 来计算</p>
<blockquote>
<p>如果这样时间复杂度<br>nlogn + n²<br>最终的时间复杂度是 n²</p>
</blockquote>
<p>如果用二分查找, 就需要先排序, 定住两个数, 排序(nlogn) + <code>定住两个数(n²)</code> <code>二分(n²logn)</code> 最终的复杂度是 <code>n²logn</code></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[时间复杂度与空间复杂度]]></title>
      <url>/2017/09/algorithm-complexity.html</url>
      <content type="html"><![CDATA[<p>算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。用来评估算法运行效率的单位。<br><a id="more"></a></p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><blockquote>
<p>时间复杂度是用来估计算法运行时间的一个式子（单位） T(n) = O(n^2)</p>
</blockquote>
<p>按数量级递增排列，常见的时间复杂度有：常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n2)，立方阶O(n3),…， k次方阶O(nk),指数阶O(2n)。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。</p>
<ul>
<li>一般来说,时间复杂度高的算法比复杂度底的算法慢.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">'Hello World'</span>)    <span class="comment"># O(1)</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):    <span class="comment"># O(n)</span></div><div class="line">    print(<span class="string">'Hello World'</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):    <span class="comment"># O(n²)</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">        print(<span class="string">'Hello World'</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):    <span class="comment"># O(n³)</span></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> rnage(n):</div><div class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</div><div class="line">            print(<span class="string">'Hello World'</span>)</div></pre></td></tr></table></figure>
<h2 id="如何一眼判断时间复杂度"><a href="#如何一眼判断时间复杂度" class="headerlink" title="如何一眼判断时间复杂度"></a>如何一眼判断时间复杂度</h2><ul>
<li>循环减半的过程 –&gt;<code>O(logn)</code></li>
<li>几次循环就是<code>n</code>的几次方的复杂度</li>
</ul>
<h2 id="时间复杂度排序"><a href="#时间复杂度排序" class="headerlink" title="时间复杂度排序"></a>时间复杂度排序</h2><ul>
<li>常见的时间复杂度</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n²)&lt;O(n²logn)&lt;O(n³)</div></pre></td></tr></table></figure>
<ul>
<li>不常见的时间复杂度</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">O(n!) O(2n) O(nn) …</div></pre></td></tr></table></figure>
<pre><code>几秒钟/O(1)
几分钟/O(n)
几小时/O(n²) // 2 平方
高级： 函数 见进阶
</code></pre><h2 id="判断时间复杂度"><a href="#判断时间复杂度" class="headerlink" title="判断时间复杂度"></a>判断时间复杂度</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1    O(1)  时间复杂度</span></div><div class="line">print(<span class="string">'Hello World'</span>)</div><div class="line">print(<span class="string">'Hello Python'</span>)</div><div class="line">print(<span class="string">'Hello Algorithm'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 2    O(n²) 时间复杂度</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">    print(<span class="string">'Hello World'</span>)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">        print(<span class="string">'Hello World'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 3    O(n²) 时间复杂度</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</div><div class="line">        print(<span class="string">'Hello World'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 以2为底64的对数</span></div><div class="line">n = <span class="number">64</span></div><div class="line"><span class="keyword">while</span> n &gt; <span class="number">1</span>:</div><div class="line">    print(n)</div><div class="line">    n = n // <span class="number">2</span></div><div class="line"><span class="comment"># 时间复杂度 O(log2n) / O(logn)</span></div><div class="line"><span class="comment"># 每次少一半</span></div></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/A0jhF7s.jpg" alt=""></p>
<h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><blockquote>
<p>用来评估算法内存占用大小的式子    S(n) = O(n^2) 表示内存占用<br>时间复杂度比空间复杂度更重要</p>
</blockquote>
<ul>
<li>空间换时间</li>
</ul>
<p>一个列表就是 O(n)<br>二维列表复杂度就是 O(n²)<br>…</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Charles: Response 出现乱码]]></title>
      <url>/2017/09/Charles-Response-error.html</url>
      <content type="html"><![CDATA[<p>使用 Charles 抓 https 包的时候, Reponse 出现乱码<br><a id="more"></a></p>
<p>系统环境: MAC<br>软件版本: 4.2.1<br>浏览器: Google Chrome</p>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>没有信任 Charles 的证书,信任 Charles 的证书就好了</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><h2 id="安装-Charles-证书"><a href="#安装-Charles-证书" class="headerlink" title="安装 Charles 证书"></a>安装 Charles 证书</h2><p><code>Help</code> &gt; <code>SSL Proxying</code> &gt; <code>Install Charles Root Certificate</code></p>
<p><img src="https://i.imgur.com/JavIfh7.jpg" alt="安装 Charles 证书"></p>
<h2 id="信任-Charles-证书"><a href="#信任-Charles-证书" class="headerlink" title="信任 Charles 证书"></a>信任 Charles 证书</h2><p>安装完成后会自动弹出钥匙串,找到 Charles 的证书信任即可</p>
<p><img src="https://i.imgur.com/gATUIEf.jpg" alt="信任 Charles 证书1"></p>
<p><img src="https://i.imgur.com/4xU3IVQ.jpg" alt="信任 Charles 证书2"></p>
<h2 id="Charles-设置"><a href="#Charles-设置" class="headerlink" title="Charles 设置"></a>Charles 设置</h2><p><code>Proxy</code> &gt; <code>SSL Proxying Settings</code></p>
<p><img src="https://i.imgur.com/BqoK9Hy.jpg" alt="Charles 设置"></p>
<h2 id="ok"><a href="#ok" class="headerlink" title="ok"></a>ok</h2><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>发布这篇文章的时候问题已经被解决,但是没有问题截图,有时间的话再补上.</p>
]]></content>
      
        
        <tags>
            
            <tag> Charles </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
