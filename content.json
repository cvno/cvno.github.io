{"meta":{"title":"CVNO-Blog","subtitle":"何以解忧","description":"何以解忧","author":"CVNO","url":"https://cvno.github.io"},"pages":[{"title":"categories","date":"2017-12-18T07:21:56.000Z","updated":"2017-12-18T07:22:19.000Z","comments":true,"path":"categories/index.html","permalink":"https://cvno.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-12-18T07:20:12.000Z","updated":"2017-12-18T07:21:44.000Z","comments":true,"path":"tags/index.html","permalink":"https://cvno.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数据结构基础","slug":"数据结构基础","date":"2017-12-26T12:58:31.000Z","updated":"2017-12-26T13:33:27.000Z","comments":true,"path":"数据结构基础/","link":"","permalink":"https://cvno.github.io/数据结构基础/","excerpt":"","text":"概念数据结构是设计数据以何种方式组织并存储在计算机中。 比如：列表、集合与字典等都是一种数据结构。 详细的说： 物理层面：就是以什么样的物理存储方式 逻辑方式：列表，字典，集合，树 线性数据结构，树形数据结构，图形数据结构， 基本是线性数据结构 N.Wirth: “程序=数据结构+算法” 列表列表：在其他编程语言中称为“数组”，是一种基本的数据结构类型。如果更学术一点的说法是“线性表”。 数组与列表的不同之处：数组是定长的数组，如果开的内存空间长度为7，就不能再追加，只能存7个，并且这7个元素类型还必须是一样的 数组：定长，元素类型统一。 Python中的给一个列表，开一块连续内存空间，开的内存空间的长度不会刚好是列表的长度，一定会多，而内存中：变量指向的列表的元素存的是一个个内存地址（地址的格子才是真正存元素值的地方），每个元素占用的空间都是一样的，大部分编译型的语言直接存的值，而python存的不是值，而是值的内存地址。 Python中一直append值的原理：如果之前的空间不够，就再开时原来一倍的内存空间，然后把旧的删掉 列表li[2]寻址的时候是li+2*内存地址的字节 32位机器一个地址4个子节64位机器一个地址8个字节 关于列表的问题： 列表中元素使如何存储的？(上述) 列表提供了哪些基本的操作？(下标查找，插入，删除) 这些操作的时间复杂度是多少？ O(1) O(n)(插入的时候，插入位置之后的值都需要往后挪) 链表链表中每一个元素都是一个对象，每个对象称为一个节点，包含有数据域key和指向下一个节点的指针next。通过各个节点之间的相互连接，最终串联成一个链表。 为什么用链表？链表的插入和删除特别快 节点定义: 1234567891011121314class Node(object): def __init__(self,item): self.item = item self.next = Nonen1 = Node(1)n2 = Node(2)n3 = Node(3)n1.next = n2n2.next = n3print(n1.next.item) # 2print(n1.next.next.item) # 3 头节点 链表的遍历 12345def traversal(head): curNode = head # 临时用指针 while curNode is not None: print(curNode.data) curNode = curNode.next 链表节点的插入和删除O1的时间复杂度 插入 12p.next = curNode.nextcurNode.next = p 删除 1234p = curNode.nextcurNode.next = curNode.next.next# 也可以 &gt;&gt; curNode.next = p.nextdel p 建立链表 头插法 1234567def createLinkList(li): l = Node() for num in li: s = Node(Num) s.next = l.next l.next = s return l 尾插法 1234567def createLinkList(li): l = Node() r = l # r 指向尾节点 for num in li : s = Node(num) r.next = s r = s 双链表双链表中每个节点有两个指针：一个指向后面节点、一个指向前面节点。 节点定义： 12345class Node(object): def __init__(self,item = None): self.item = item self.next = None self.prior = None 双链表节点的插入和删除 插入 1234p.next = curNode.nextcurNode.next.prior = pp.prior = curNodecurNode.next = p 删除 1234p = curNode.nextcurNode.next = p.nextp.next.prior = curNodedel p 链表分析列表与链表 按元素值查找（链表二分是On的复杂度） 按下标查找（链表没有法用下表查找，李列表：O1，链表On） 在某元素后插入（列表：On，链表：O1） 删除某元素（列表：On，链表：O1） 树也是以链表的形式存 栈栈(Stack)是一个数据集合，可以理解为只能在一端进行插入或删除操作的列表。 特点： 后进先出（last-in, first-out）LIFO 概念： 栈顶 栈底 基本操作： 进栈（压栈）：push 出栈：pop 取栈顶：gettop 应用实例： Word 的撤销操作（撤销的时候后边的操作） 重做 两个栈,撤销栈出栈，重做栈压栈；重做操作是记录撤销操作的。 栈的简单实现(Python)不需要自己定义，使用列表结构即可。 进栈函数：append 出栈函数：pop 查看栈顶函数：li[-1] 栈的应用 - 括号匹配问题给一个字符串，其中包含小括号、中括号、大括号，求该字符串中的括号是否匹配。 ()()[]{} 匹配 ([{()}]) 匹配 []( 不匹配 [(]) 不匹配 代码补全，当栈是空的，栈才是合法的 代码实现括号匹配 队列队列(Queue)是一个数据集合，仅允许在列表的一端进行插入，另一端进行删除。 进行插入的一端称为队尾(rear)，插入动作称为进队或入队 进行删除的一端称为队头(front)，删除动作称为出队 队列的性质：先进先出(First-in, First-out) 双向队列：队列的两端都允许进行进队和出队操作。 队列的实现用Python的列表来实现出队复杂度太高 123456使用方法：from collections import deque- 创建队列：queue = deque(li)- 进队：append- 出队：popleft- 双向队列队首进队：appendleft- 双向队列队尾进队：pop 实现原理 初步设想：列表+两个下标指针 创建一个列表和两个变量，front变量指向队首，rear变量指向队尾。初始时，front和rear都为0。 进队操作：元素写到li[rear]的位置，rear自增1。 出队操作：返回li[front]的元素，front自减1。 环形队列环形队列：当队尾指针front == Maxsize + 1时，再前进一个位置就自动到0。实现方式：求余数运算 队首指针前进1：front = (front + 1) % MaxSize 队尾指针前进1：rear = (rear + 1) % MaxSize 队空条件：rear == front 队满条件：(rear + 1) % MaxSize == front 代码实现 通过Python自带库 手写循环队列 123456789101112import queue # 线程同步######## 分割 ########from collections import dequequeue = deque()queue.append(1)queue.append(2)queue.append(3)print( ())print(queue.popleft())######## 分割 ########queue.appendleft(2)queue.pop() 哈希表Python中的集合与字典哈希表查找 哈希表（Hash Table，又称为散列表），是一种线性表的存储结构。通过把每个对象的关键字k作为自变量，通过一个哈希函数h(k)，将k映射到下标h(k)处，并将该对象存储在这个位置。 例如：数据集合{1,6,7,9}，假设存在哈希函数h(x)使得h(1) = 0, h(6) = 2, h(7) = 4, h(9) = 5，那么这个哈希表被存储为[1,None, 6, None, 7, 9]。 当我们查找元素6所在的位置时，通过哈希函数h(x)获得该元素所在的下标（h(6) = 2），因此在2位置即可找到该元素。 12345li = [1,2,3,4]s = &#123;1,2,3,4&#125; # 集合的效率更高# 哈希函数设计的再好也避免不了碰撞## 哈希冲突哈希冲突：由于哈希表的下标范围是有限的，而元素关键字的值是接近无限的，因此可能会出现h(102) = 56， h(2003) = 56这种情况。此时，两个元素映射到同一个下标处，造成哈希冲突。 解决哈希冲突 拉链法（将所有冲突的元素用链表连接） 开放寻址法（通过哈希冲突函数得到新的地址） 字典在Python中的字典： 1a = &#123;&apos;name&apos;: &apos;Alex&apos;, &apos;age&apos;: 18, &apos;gender&apos;: &apos;Man&apos;&#125; 使用哈希表存储字典，通过哈希函数将字典的键映射为下标。假设h(‘name’) = 3, h(‘age’) = 1, h(‘gender’) = 4，则哈希表存储为[None, 18, None, ’Alex’, ‘Man’] 在字典键值对数量不多的情况下，几乎不会发生哈希冲突，此时查找一个元素的时间复杂度为O(1)。 迷宫问题给一个二维列表，表示迷宫（0表示通道，1表示围墙）。给出算法，求一条走出迷宫的路径。 栈 栈-方案 深度优先 DFS（Depth[栈]-First-Search） 队列 队列-方案 使用二维列表存储多条路径如何是打印出路径是难点 123456789101112maze = [ [1,1,1,1,1,1,1,1,1,1], [1,0,0,1,0,0,0,1,0,1], [1,0,0,1,0,0,0,1,0,1], [1,0,0,0,0,1,1,0,0,1], [1,0,1,1,1,0,0,0,0,1], [1,0,0,0,1,0,0,0,0,1], [1,0,1,0,0,0,1,0,0,1], [1,0,1,1,1,0,1,1,0,1], [1,1,0,0,0,0,0,0,0,1], [1,1,1,1,1,1,1,1,1,1]] 本文代码及 md 文件 Github","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://cvno.github.io/categories/数据结构/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://cvno.github.io/tags/链表/"},{"name":"栈","slug":"栈","permalink":"https://cvno.github.io/tags/栈/"},{"name":"队列","slug":"队列","permalink":"https://cvno.github.io/tags/队列/"},{"name":"哈希表","slug":"哈希表","permalink":"https://cvno.github.io/tags/哈希表/"},{"name":"迷宫","slug":"迷宫","permalink":"https://cvno.github.io/tags/迷宫/"}]},{"title":"TOP 榜单算法（nlargest）","slug":"TOP-榜单算法","date":"2017-12-26T05:52:13.000Z","updated":"2017-12-26T12:24:30.000Z","comments":true,"path":"TOP-榜单算法/","link":"","permalink":"https://cvno.github.io/TOP-榜单算法/","excerpt":"问题现在有n个数（n&gt;10000），设计算法，按大小顺序得到前10m大的数。","text":"问题现在有n个数（n&gt;10000），设计算法，按大小顺序得到前10m大的数。 应用场景：榜单TOP 10 解决方法 先排序，取前 10 个数 O(nlogn) 只留前 10 个数，开一个长度为 10 的列表，用插入排序取出 10 个数，来一个数和列表最后一个数比较，如果比它更小就扔掉 O(nm)不适用与 m 特别大的时候 堆 O(nlogm) 用堆解决思路： 取列表前m个元素建立一个小根堆。堆顶就是目前第m大的数。 依次向后遍历原列表，对于列表中的元素，如果小于堆顶，则忽略该元素；如果大于堆顶，则将堆顶更换为该元素，并且对堆进行一次调整； 遍历列表所有元素后，倒序弹出堆顶。 12345678910111213141516171819202122232425262728293031323334353637def sift(data, low, high): \"\"\" 调整函数 data: 列表 low：待调整的子树的根位置 high：待调整的子树的最后一个节点的位置 \"\"\" i = low j = 2 * i + 1 tmp = data[i] # i指向空位置 while j&lt;=high: #领导已经撸到底了 if j != high and data[j] &lt; data[j+1]: j += 1 #j指向数值大的孩子 if tmp &lt; data[j]: #如果小领导比撸下来的大领导能力值大 data[i] = data[j] i = j j = 2*i+1 else: break #撸下来的领导比候选的领导能力值大 data[i] = tmpdef topn(li, n): heap = li[0:n] # 建堆 for i in range(n // 2 - 1, -1, -1): sift(heap, i, n - 1) # 遍历 for i in range(n, len(li)): if li[i] &gt; heap[0]: heap[0] = li[i] sift(heap, 0, n - 1) # 出数 for i in range(n - 1, -1, -1): heap[0], heap[i] = heap[i], heap[0] sift(heap, 0, i - 1) Python内置模块——heapq 12345678910111213import heapq# 利用heapq模块实现堆排序def heapsort(li): h = [] for value in li: heapq.heappush(h, value)# 建堆, 并自动排序 return [heappop(h) for i in range(len(h))]heapsort([6,8,1,9,3,0,7,2,4,5]) # [0,2,1,3,5,6,7,9,4,8]# ============== 分割线 ==============# 利用heapq模块实现取top-kheapq.nlargest(100, li) 优先队列：一些元素的集合，POP操作每次执行都会从优先队列中弹出最大（或最小）的元素。 堆——优先队列 参考 http://python.usyiyi.cn/translate/python_352/library/heapq.html 1234567# 位运算# &gt;&gt; 除以22 &gt;&gt; 1 # 1 4 &gt;&gt; 1 # 28 &gt;&gt; 1 # 4# &lt;&lt; 乘以 22 &lt;&lt; 1 # 4","categories":[],"tags":[{"name":"heapq","slug":"heapq","permalink":"https://cvno.github.io/tags/heapq/"}]},{"title":"数据结构：树","slug":"数据结构：树","date":"2017-12-25T07:04:18.000Z","updated":"2017-12-26T03:49:30.000Z","comments":true,"path":"数据结构：树/","link":"","permalink":"https://cvno.github.io/数据结构：树/","excerpt":"","text":"树 是一种数据结构（如：目录结构） 是一种可以递归定义的数据结构 是由 n 个节点组成的集合 如果 n=0 ，那么是一颗空树 如果 n&gt;0 ，那么存在 1 个节点作为树的根节点，其他节点可以分为 m 个集合，每个集合本身又是一棵树。 概念： 根节点（最顶端的节点）、叶子节点（没有孩子的节点，结构的最末端） 树的深度／高度（也就是树的层数） 节点度（也就是这个节点分了多少叉） 树的度（所有节点度的最大值） 孩子节点/父节点（看字面理解） 子树（根节点的字节点都是独立的树） 二叉树度不超过 2 的树（节点最多有两个叉），它的孩子是有顺序的：左孩子，右孩子。 重点：满二叉树，完全二叉树 二叉树的存储方式 链式存储方式 顺序存储方式（列表） 父节点和左孩子节点的编号下标有什么关系？ 0-1 1-3 2-5 3-7 4-9规律：i = 2i+1 父节点和右孩子节点的编号下标有什么关系？ 0-2 1-4 2-6 3-8 4-10规律：i = 2i+2 比如，我们要找根节点左孩子的左孩子： 二叉树小结 二叉树是度不超过 2 的树 满二叉树与完全二叉树 （完全）二叉树可以用列表来存储，通过规律可以从父亲找到孩子或者孩子找到父亲","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://cvno.github.io/categories/数据结构/"}],"tags":[{"name":"树","slug":"树","permalink":"https://cvno.github.io/tags/树/"},{"name":"二叉树","slug":"二叉树","permalink":"https://cvno.github.io/tags/二叉树/"}]},{"title":"递归","slug":"递归","date":"2017-12-22T12:48:26.000Z","updated":"2017-12-25T07:19:29.000Z","comments":true,"path":"递归/","link":"","permalink":"https://cvno.github.io/递归/","excerpt":"","text":"在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。 特点： 调用自身 结束条件 1234567891011121314151617181920212223242526def func1(x): print(x) func1(x-1)# func1(3) # 死递归 没有结束条件def func2(x): if x &gt; 0: print(x) func2(x+1)# func2(3) # 3,4,5,6... 有结束条件，如果是正数还是会陷入死递归def func3(x): if x &gt; 0: print(x) func3(x-1)# func3(3) # 3,2,1 有结束条件def func4(x): if x &gt; 0: func4(x-1) print(x)# func4(3) # 1,2,3 有结束条件 递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出） 练习 123456789def func(depth): if depth == 0: print('我的小鲤鱼',end='') # 取消换行 else: print('抱着',end='') func(depth-1) print('的我',end='')func(3) # 抱着抱着抱着我的小鲤鱼的我的我的我 123456789101112131415161718192021# 利用递归函数计算阶乘# N! = 1 * 2 * 3 * ... * Ndef fact(n): if n == 1: return 1 return n * fact(n-1)print('fact(1) =', fact(1))print('fact(5) =', fact(5))print('fact(10) =', fact(10))# 利用递归函数移动汉诺塔:def move(n, a, b, c): if n == 1: print('move', a, '--&gt;', c) else: move(n-1, a, c, b) move(1, a, b, c) move(n-1, b, a, c)move(4, 'A', 'B', 'C')","categories":[{"name":"算法","slug":"算法","permalink":"https://cvno.github.io/categories/算法/"}],"tags":[]},{"title":"常用排序算法","slug":"列表排序","date":"2017-12-22T07:22:38.000Z","updated":"2017-12-27T04:04:30.000Z","comments":true,"path":"列表排序/","link":"","permalink":"https://cvno.github.io/列表排序/","excerpt":"","text":"重点: 有序区 无序区 冒泡排序（BUB） 列表每两个相邻的数, 如果前边的比后边的大, 那么交换这两个数 冒泡排序算法的流程如下： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 关键点: 趟, 无序区 code1234567891011121314# O(n²) 时间复杂度def bubble_sort(li): if len(li) &lt;= 1: return li for i in range(len(li)-1): # i 是趟 for j in range(len(li)-i - 1): # j 是指针 if li[j] &gt; li[j+1]: li[j], li[j+1] = li[j+1] , li[j] return lili = list(range(10000))import random as rdrd.shuffle(li) # 打乱顺序print(li)print(bubble_sort(li)) 优化版123456789101112def bubble_sort(li): if len(li) &lt;= 1: return li for i in range(len(li) - 1): # i 是趟 exchange = Flase for j in range(len(li) - i - 1): # j 是指针 if li[j] &gt; li[j + 1]: li[j], li[j + 1] = li[j + 1], li[j] exchange = True if not exchange: break return li 空间时间复杂度 O(1) 最坏时间复杂度 O(n²) 最优时间复杂度 O(n) 平均时间复杂度 O(n²) 选择排序（SEL）每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 123456789101112131415def select_sort(li): for i in range(len(li) - 1): # i 是趟 min_doc = i # 找i位置到最后位置范围内最小的数 for j in range(i, len(li)): # i可以换成i+1,省去和自己比 if li[j] &lt; li[min_doc]: min_doc = j # 和无序区第一个数作交换 # 可以加上 i==min_loc 的判断,省去和自己换 if min_doc != i: li[min_doc], li[i] = li[i], li[min_doc] ''' i, j, min_doc 都是下标 ''' return li 空间时间复杂度 O(1) 最坏时间复杂度 O(n²) 最优时间复杂度 O(n²) 平均时间复杂度 O(n²) 插入排序（INS）插入排序每次取出数组后半部分的第一个元素，在排好序的前半部分中，为其找到最合适的位置并进行插入(扑克牌) 列表被分为有序区和无序区两个部分。最初有序区只有一个元素。 每次从无序区选择一个元素，插入到有序区的位置，直到无序区变空。 插入排序算法的流程如下： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤 2~5 关键点： 摸到的牌 手里的牌 (有序) code1234567891011def insert_sort(li): if len(li) == 1: return li for i in range(1, len(li)): # i代表每次摸到的牌的下标 tmp = li[i] j = i - 1 # j代表手里最后一张牌的下标 while j &gt;= 0 and tmp &lt; li[j]: # 摸到的牌比手牌最后的牌小 li[j + 1] = li[j] # 把最大的手牌往后挪动 j -= 1 li[j + 1] = tmp # 摸到的牌比手牌最后的牌大 return li 空间时间复杂度 O(1) 最坏时间复杂度 O(n²) 最优时间复杂度 O(n²) 平均时间复杂度 O(n²) 快速排序（QUI）博主看动图不是很理解, 建议看 这里 快速排序算法的流程如下： 取一个元素p（第一个元素），使元素p归位； 列表被p分成两部分，左边都比p小，右边都比p大； 递归完成排序。 关键点： 整理(让元素归位) 递归 1234567891011121314151617181920212223242526272829def partition(data, left, right): ''' partition:归位函数 右手左手一个慢动作 右手左手慢动作重播 ''' tmp = data[left] # 取基准数 while left &lt; right: # 如果需要降序排序的话, 就把 data[right] &gt;= tmp 中的小于等于改为大于等于 while left &lt; right and data[right] &gt;= tmp: right -= 1 # 左移 if left &lt; right: # 如果上面的循环是因为找到了 right 小于 tmp 的数而跳出循环 data[left] = data[right] # 把小于 tmp 的这个元素放到 tmp 的位置上 # 如果需要降序排序的话, 就把 data[right] &gt;= tmp 中的大于等于改为小于等于 while left &lt; right and data[left] &lt;= tmp: left += 1 # 右移 data[right] = data[left] # 把大于 tmp 的这个元素放到 tmp 的位置上 data[left] = tmp # 那个 mid 回来 return left def _quick_sort(data, left, right): if left &lt; right: mid = partition(data, left, right) _quick_sort(data, left, mid - 1) _quick_sort(data, mid + 1, right)@cal_timedef quick_sort(data): return _quick_sort(data,0,len(data)-1) 优化版12345678910111213141516171819# 来自知乎 @风满楼def quick_sort(lists, left, right): if left &gt; right: return lists low, high = left, right key = lists[left] # key即是基准数 while left &lt; right: while left &lt; right and lists[right] &gt;= key: right -= 1 # 左移 lists[left] = lists[right] while left &lt; right and lists[left] &lt;= key: left += 1 # 右移 lists[right] = lists[left] lists[right] = key quick_sort(lists, low, left - 1) quick_sort(lists, right + 1, high) return listsquick(data,0,len(data)-1) 问题某些极端的情况下复杂度非常高, 如： 19 8 7 6 5 4 3 2 1 出现的概率不多, 属于极端情况, 解决方法: 选基准的时候随机选一个数与第一个数交换。 空间时间复杂度 根据实现的方式不同而不同 最坏时间复杂度 O(n²) 最优时间复杂度 O(nlogn) 平均时间复杂度 O(nlogn) PS: 看到一个最狠的快排 12# https://github.com/qiwsir/algorithm/blob/master/quick_sort.mdqs = lambda xs : ( (len(xs) &lt;= 1 and [xs]) or [ qs( [x for x in xs[1:] if x &lt; xs[0]] ) + [xs[0]] + qs( [x for x in xs[1:] if x &gt;= xs[0]] ) ] )[0] 参考资料 Ele - A面 http://bbs.ahalei.com/thread-4419-1-1.html http://blog.csdn.net/v_july_v/article/details/6116297 https://www.zhihu.com/question/26786398 https://hellolynn.hpd.io/2017/08/03/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-quick-sort/ https://github.com/qiwsir/algorithm/blob/master/quick_sort.md 堆排序（HEAP）堆排序用的是树的结构 堆 大根堆：一棵完全二叉树，满足任一节点都比其孩子节点大 小根堆：一棵完全二叉树，满足任一节点都比其孩子节点小 假设：节点的左右子树都是堆，但自身不是堆 当根节点的左右子树都是堆时，可以通过一次向下的调整来将其变换成一个堆。 堆排序过程: 建立堆 得到堆顶元素，为最大元素 去掉堆顶，将堆最后一个元素放到堆顶，此时可通过一次调整重新使堆有序。 堆顶元素为第二大元素。 重复步骤3，直到堆变空。 构建堆先从最小的子树开始看, 最后一步看整个的堆; 从最后一个非叶子节点为根的子树开始做调整 挨个出数 code12345678910111213141516171819202122232425262728293031323334def sift(data, low, high): \"\"\" 调整函数 data: 列表 low：待调整的子树的根位置 high：待调整的子树的最后一个节点的位置 \"\"\" i = low j = 2 * i + 1 tmp = data[i] # i指向空位置 while j&lt;=high: #领导已经撸到底了 if j != high and data[j] &lt; data[j+1]: j += 1 #j指向数值大的孩子 if tmp &lt; data[j]: #如果小领导比撸下来的大领导能力值大 data[i] = data[j] i = j j = 2*i+1 else: break #撸下来的领导比候选的领导能力值大 data[i] = tmpdef heap_sort(data): n = len(data) # 建堆 从最后一个非叶子节点所以是 -1(2) 列表倒序 # n//2-1 找最后一个非叶子节点 # -1(1) 顾前不顾后 for i in range(n//2-1, -1, -1): sift(data, i, n - 1) # 这里的 n-1 是把所有子树的 high 都设置成整个堆的 high # 挨个出数 for high in range(n - 1, -1, -1): data[0], data[high] = data[high], data[0] sift(data, 0, high - 1) 空间时间复杂度 O(n)，O(1) 最坏时间复杂度 O(nlogn) 最优时间复杂度 O(nlogn) 平均时间复杂度 O(nlogn) 引用 数据结构：树 https://www.cnblogs.com/chengxiao/p/6129630.html http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/ http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/ 归并排序（MER）归并排序思路: 分解：将列表越分越小，直至分成一个元素。 一个元素是有序的。 合并：将两个有序列表归并，列表越来越大。 递归地将数组划分为两部分 直到两个子数组元素都为1时，返回并将两个数组进行排序融合 逐步返回，并递归融合，最终使得数组有序 code1234567891011121314151617181920212223242526272829def merge(data, low, mid, high): '''一次归并''' i = low j = mid + 1 ltmp = [] # 临时列表 while i &lt;= mid and j &lt;= high: if data[i] &lt;= data[j]: ltmp.append((data[i])) i += 1 else: # data[i] &gt; data[j] ltmp.append(data[j]) j += 1 while i &lt;= mid: ltmp.append(data[i]) i += 1 while j &lt;= high: ltmp.append(data[j]) j += 1 data[low:high + 1] = ltmpdef mergesort(data, low, high): '''归并排序''' if low &lt; high: mid = (low + high) // 2 # 获取中间位置 mergesort(data, low, mid) # 分解左半部分 mergesort(data, mid + 1, high) # 分解右半部分 merge(data, low, mid, high) # 归并 return data 加深理解12345678def func(x): if x &gt; 1: y = x // 2 func(y) func(y) print(y)func(20)# 看最后的输出 画图 或者结合递归 空间时间复杂度 O(n) 最坏时间复杂度 O(nlogn) 最优时间复杂度 O(n) 平均时间复杂度 O(nlogn) 快速排序、堆排序、归并排序 - 小结 三种排序算法的时间复杂度都是O(nlogn) 运行时间: 快速排序 &lt; 归并排序 &lt; 堆排序 三种排序算法的缺点： 快速排序 极端情况下排序效率低 归并排序 需要额外的内存开销 堆排序 在快的排序算法中相对较慢 计数排序（COU） 题: 现在有一个列表，列表中的数范围都在 0 到 100 之间，列表长度大约为 100 万。设计算法在 O(n) 时间复杂度内将列表进行排序。 12345678910111213141516171819def count_sort(data, maxnum = 100): '''计数排序 O(n)''' count = [0 for i in range(maxnum+1)] result = [] for i in data: count[i] += 1 for num,count in enumerate(count): for i in range(count): result.append(num)# 或def count_sort(data, max_num): count = [0 for i in range(max_num + 1)] for num in data: count[num] += 1 i = 0 for num, m in enumerate(count): for j in range(m): data[i] = num i += 1 因为要开额外的内存空间，所以使用并不多。计数排序限定元素不会太大的时候，如：年龄可以使用计数排序 希尔排序（SHE）希尔排序是一种分组插入排序算法。O(1.3n) 以数组元素长度的一半做为初始步长gap，将数组划分为gap个子数组 循环切换遍历子数组，在子数组内分别进行插入排序 将gap更新为gap/2，重复上述步骤1，2，直到gap为1 希尔排序思路： 先取一个正整数 d1(d1 &lt; n)，把全部记录分成 d1 个组，所有距离为 d1 的倍数的记录看成一组，然后在各组内进行插入排序 然后取 d2(d2 &lt; d1) 重复上述分组和排序操作；直到取 di = 1(i &gt;= 1) 位置，即所有记录成为一个组，最后对这个组进行插入排序。一般选 d1 约为 n/2，d2 为 d1 /2， d3 为 d2/2 ，…， di = 1。 希尔排序每趟并不使某些元素有序，而是使整体数据越来越接近有序；最后一趟排序使得所有数据有序。 1234567891011121314151617# 修改插入排序def insert_sort_gap(data, gap): for i in range(gap, len(data)): tmp = data[i] j = i - gap while j &gt;= 0 and tmp &lt; data[j]: data[j + gap] = data[j] j = j - gap data[j + gap] = tmpdef shell_sort(data): '''希尔排序''' d = len(data) // 2 while d &gt; 0: insert_sort_gap(data,d) d = d // 2 return data 优化版12345678910111213def shell_sort(data): n = len(data) gap = len(data) // 2 while gap &gt; 0: for i in range(gap, n): tmp = data[i] j = i - gap while j &gt;= 0 and tmp &lt; data[j]: data[j + gap] = data[j] j -= gap data[j + gap] = tmp gap = gap // 2 return data 后记排序算法指标 排序的稳定性排序关键字相同的情况下，对象的相对位置不变 计时装饰器12345678def cal_time(func): def wrapper(*args, **kwargs): t1 = time.time() x = func(*args, **kwargs) t2 = time.time() print(\"%s running time %s secs.\" % (func.__name__, t2 - t1)) return x return wrapper 参考资料 博客部分图片截取自 https://visualgo.net/zh/sorting http://bubkoo.com http://chenyvehtung.github.io/2017/02/26/sort-algorithms.html 维基百科-排序算法","categories":[{"name":"算法","slug":"算法","permalink":"https://cvno.github.io/categories/算法/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://cvno.github.io/tags/Python/"}]},{"title":"hexo: ERROR Process failed: _posts/*","slug":"hexo-ERROR-Process-failed-posts","date":"2017-12-18T06:49:12.000Z","updated":"2017-12-20T13:18:41.000Z","comments":true,"path":"hexo-ERROR-Process-failed-posts/","link":"","permalink":"https://cvno.github.io/hexo-ERROR-Process-failed-posts/","excerpt":"文章的格式出现错误了","text":"文章的格式出现错误了 错误提示 1234$ hexo sERROR Process failed: _posts/*Error at ..... 原因 123title: Hexodate: 2017-12-13 12:21:33tags:Hexo #tags冒号后面应当有个空格,其他地方也应当注意 正确格式(加上那个空格就好了) 123title: Hexodate: 2017-12-13 12:21:33tags: Hexo 参考资料 http://shitaibin.github.io/2015/12/13/hexo-errors/","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://cvno.github.io/tags/hexo/"}]},{"title":"Python:消息队列Rabbitmq基本使用","slug":"消息队列Rabbitmq基本使用","date":"2017-12-18T06:24:45.000Z","updated":"2017-12-20T13:24:14.000Z","comments":true,"path":"消息队列Rabbitmq基本使用/","link":"","permalink":"https://cvno.github.io/消息队列Rabbitmq基本使用/","excerpt":"为什么用Rabbitmq instead of python queue ?","text":"为什么用Rabbitmq instead of python queue ? 是因为python queue 不能跨进程 队列的作用: 1. 存储消息、数据 2. 保证消息顺序 3. 保证数据的交付 12345678910111213141516171819# 斐波那契数列1 1 2 3 5 8 13 ...# 启动rabbitmq，并验证启动情况 rabbitmq-server --detached &amp;ps aux |grep rabbitmq# 以服务的方式启动service rabbitmq-server start# 启用维护插件rabbitmq-plugins enable rabbitmq_management # 重启service rabbitmq-server restart# erroepika.exceptions.ProbableAuthenticationError# 解决方法# 写入信息 并保存/关闭防火墙 'systemctl stop filewallf'vim /etc/rabbitmq/rabbitmq.config[&#123;rabbit, [&#123;loopback_users, []&#125;]&#125;].# 查看当前队列rabbitmqctl list_queues 基本使用实现发送端1234567891011121314151617181920212223import pika# 创建连接connection = pika.BlockingConnection(pika.ConnectionParameters('10.211.55.10'))channel = connection.channel()# 声明消息队列channel.queue_declare(queue='hello')# 发送消息到上面声明的hello队列，# 其中exchange表示交换器，能精确指定消息应该发送到哪个队列，# routing_key设置为队列的名称，# body就是发送的内容，channel.basic_publish(exchange='',routing_key='hello',body='Hello World!')print('[x] Sent \"Hello World!\"')# sh命令# 用 rabbitmqctl list_queues 查看队列'''Listing queueshello 1''' 接收端1234567891011121314151617181920212223import pika# 创建连接connection = pika.BlockingConnection(pika.ConnectionParameters('10.211.55.10'))channel = connection.channel()# 声明消息队列channel.queue_declare(queue='hello')# 接收消息 回调函数def callbcak(ch,method,properties,body): print(\"Received %r\"%(body))# 告诉rabbitmq使用callback来接收信息channel.basic_consume(callbcak,queue='hello',no_ack=True)#开始接收信息，并进入阻塞状态，队列里有信息才会调用callback进行处理。按ctrl+c退出。channel.start_consuming()# 终端会阻塞住'''Received b'Hello World!'''' 工作队列消息不丢失生产者12345for i in range(5): msg = ' '.join(sys.argv[1:])or 'Hello World! %s' % time.time() channel.basic_publish(exchange='', routing_key='hello', body=bytes(msg,encoding='utf8'),) 消费者 no_ack=False 消费者退出不消息不丢失 12345# 修改回调函数def callbcak(ch, method, properties, body): print(\"Received %r\" % (body)) time.sleep(5) print(\"[x] Done\") 消息持久化 消息持久化存储, 虽然消息反馈机制，但是如果rabbitmq自身挂掉的话，那么任务还是会丢失。所以需要将任务持久化存储起来。声明持久化存储： 12# 原队列channel.queue_declare(queue='hello', durable=True) 但是这个程序会执行错误，因为hello这个队列已经存在，并且是非持久化的，rabbitmq不允许使用不同的参数来重新定义存在的队列。重新定义一个队列 12# 重新定义一个队列channel.queue_declare(queue='task_queue', durable=True) 在发送任务的时候，用delivery_mode=2来标记任务为持久化存储： 123456channel.basic_publish(exchange='', routing_key=\"task_queue\", body=message, properties=pika.BasicProperties( delivery_mode = 2, # make message persistent )) 公平调度prefetch_count = 1 虽然每个工作者是依次分配到任务，但是每个任务不一定一样。可能有的任务比较重，执行时间比较久；有的任务比较轻，执行时间比较短。如果能公平调度就最好了，使用basic_qos设置prefetch_count=1，使得rabbitmq不会在同一时间给工作者分配多个任务，即只有工作者完成任务之后，才会再次接收到任务。 1channel.basic_qos(prefetch_count=1) new_task.py完整代码 发送者/生产者 123456789101112131415161718import pikaimport sysconnection = pika.BlockingConnection(pika.ConnectionParameters( host='10.211.55.10'))channel = connection.channel()channel.queue_declare(queue='task_queue', durable=True)message = ' '.join(sys.argv[1:]) or \"Hello World!\"channel.basic_publish(exchange='', routing_key='task_queue', body=message, properties=pika.BasicProperties( delivery_mode=2, # make message persistent ))print(\" [x] Sent %r\" % (message,))connection.close() worker.py完整代码 接受者/消费者 123456789101112131415161718192021import pikaimport timeconnection = pika.BlockingConnection(pika.ConnectionParameters(host='10.211.55.10'))channel = connection.channel()channel.queue_declare(queue='task_queue', durable=True)print(' [*] Waiting for messages. To exit press CTRL+C')def callback(ch, method, properties, body): print(\" [x] Received %r\" % (body,)) time.sleep(6) print(\" [x] Done\",ch.basic_ack(delivery_tag=method.delivery_tag))channel.basic_qos(prefetch_count=1)channel.basic_consume(callback, queue='task_queue')channel.start_consuming() 广播广播交换机的工作原理：消息发送端先将消息发送给交换机，交换机再将消息发送到绑定的消息队列，而后每个接收端都能从各自的消息队列里接收到信息。 消费者/接收端receive.py代码分析和最早的receive.py相比，主要是做了两个改动： 定义交换机 不使用hello队列了，随机生成一个临时队列，并绑定到交换机上 123456789101112131415161718192021222324import pikaconnection = pika.BlockingConnection(pika.ConnectionParameters( '10.211.55.10'))channel = connection.channel()# 定义交换机channel.exchange_declare(exchange='messages', type='fanout')# 随机生成队列，并绑定到交换机上# 参数'exclusive=True'表示当接收端退出时，销毁临时产生的队列，这样就不会占用资源。result = channel.queue_declare(exclusive=True)queue_name = result.method.queuechannel.queue_bind(exchange='messages', queue=queue_name)def callback(ch, method, properties, body): print(\" [x] Received %r\" % (body,))channel.basic_consume(callback, queue=queue_name, no_ack=True)print(' [*] Waiting for messages. To exit press CTRL+C')channel.start_consuming() 执行rabbitmqctl list_queues 1234task_queue 0hello 5# 定义了交换机amq.gen-K0M17k_3LVYO0b7m0s-K1g 0 生产者/发送端send.py代码分析和最早的send.py相比，也只做了两个改动： 定义交换机 不是将消息发送到hello队列，而是发送到交换机 12345678910111213141516import pikaconnection = pika.BlockingConnection(pika.ConnectionParameters( '10.211.55.10'))channel = connection.channel()# 定义交换机# type='fanout' 表示广播的意思channel.exchange_declare(exchange='messages', type='fanout')# 将消息发送到交换机# basic_publish方法的参数exchange被设定为相应交换机，# 因为是要广播出去，发送到所有队列，所以routing_key就不需要设定了。channel.basic_publish(exchange='messages', routing_key='', body='Hello World!')print(\" [x] Sent 'Hello World!'\")connection.close() exchange如果为空，表示是使用匿名的交换机，在上面交换机信息的图片中可以看到有amq.*这样的交换机，就是系统默认的交换机了。routing_key在使用匿名交换机的时候才需要指定，表示发送到哪个队列的意思。第一篇的例子演示了这个功能。 打开另外一个终端，执行send.py，可以观察到receive.py接收到了消息。如果有多个终端执行receive.py，那么每个receive.py都会接收到消息。 组播/路由生产者/send.py代码分析和广播相比，改动点主要在两个方面： 设定交换机的类型（type）为direct。上一篇是设置为fanout，表示广播的意思，会将消息发送到所有接收端，这里设置为direct表示要根据设定的路由键来发送消息。 发送信息时设置发送的路由键。 123456789101112131415161718192021import pikaconnection = pika.BlockingConnection(pika.ConnectionParameters( '10.211.55.10'))channel = connection.channel()# 定义交换机，设置类型为directchannel.exchange_declare(exchange='messages', type='direct')# 定义三个路由键routings = ['warning', 'error']# 将消息依次发送到交换机，并设置路由键for routing in routings: message = '%s message.' % routing channel.basic_publish(exchange='messages', routing_key=routing, body=message) print(message)connection.close() 消费者/receive.py代码分析和广播相比，改动点主要在三个方面： 设定交换机的类型（type）为direct。 增加命令行获取参数功能，参数即为路由键。 将队列绑定到交换机上时，设定路由键。 12345678910111213141516171819202122232425262728293031import pika, sysconnection = pika.BlockingConnection(pika.ConnectionParameters( '10.211.55.10'))channel = connection.channel()# 定义交换机，设置类型为directchannel.exchange_declare(exchange='messages', type='direct')# 从命令行获取路由键参数，如果没有，则设置为inforoutings = sys.argv[1:]if not routings: routings = ['info']# 生成临时队列，并绑定到交换机上，设置路由键result = channel.queue_declare(exclusive=True)queue_name = result.method.queuefor routing in routings: channel.queue_bind(exchange='messages', queue=queue_name, routing_key=routing)def callback(ch, method, properties, body): print(\" [x] Received %r\" % (body,))channel.basic_consume(callback, queue=queue_name, no_ack=True)print(' [*] Waiting for messages. To exit press CTRL+C')channel.start_consuming() 打开两个终端，一个运行代码python receive.py info warning，表示只接收info和warning的消息。另外一个终端运行send.py，可以观察到接收终端只接收到了info和warning的消息。如果打开多个终端运行receive.py，并传入不同的路由键参数，可以看到更明显的效果。 当接收端正在运行时，可以使用rabbitmqctl list_bindings来查看绑定情况。 按规则发送/正则上面路由键/组播的功能，通过设置路由键，可以将消息发送到相应的队列，这里的路由键是要完全匹配，比如info消息的只能发到路由键为info的消息队列。 路由键模糊匹配，就是可以使用正则表达式，和常用的正则表示式不同，这里的话“#”表示所有、全部的意思；“*”只匹配到一个词。看完示例就能明白了。 send.py代码分析因为要进行路由键模糊匹配，所以交换机的类型要设置为topic，设置为topic，就可以使用#，*的匹配符号了。 12345678910111213141516171819202122import pikaconnection = pika.BlockingConnection(pika.ConnectionParameters( '10.211.55.10'))channel = connection.channel()# 定义交换机，设置类型为topicchannel.exchange_declare(exchange='messages', type='topic')# 定义路由键# 四种类型的消息routings = ['happy.work', 'happy.life', 'sad.work', 'sad.life']# 将消息依次发送到交换机，并设定路由键for routing in routings: message = '%s message.' % routing channel.basic_publish(exchange='messages', routing_key=routing, body=message) print(message)connection.close() receive.py代码分析类型要设定为topic就可以了。从命令行接收参数的功能稍微调整了一下，没有参数时报错退出。 123456789101112131415161718192021222324252627282930313233import pika, sysconnection = pika.BlockingConnection(pika.ConnectionParameters( '10.211.55.10'))channel = connection.channel()# 定义交换机，设置类型为topicchannel.exchange_declare(exchange='messages', type='topic')# 从命令行获取路由参数，如果没有，则报错退出routings = sys.argv[1:]if not routings: # print(&gt;&gt; sys.stderr, \"Usage: %s [routing_key]...\" % (sys.argv[0],)) print(sys.stderr, \"Usage: %s [routing_key]...\" % (sys.argv[0],)) exit()# 生成临时队列，并绑定到交换机上，设置路由键result = channel.queue_declare(exclusive=True)queue_name = result.method.queuefor routing in routings: channel.queue_bind(exchange='messages', queue=queue_name, routing_key=routing)def callback(ch, method, properties, body): print(\" [x] Received %r\" % (body,))channel.basic_consume(callback, queue=queue_name, no_ack=True)print(' [*] Waiting for messages. To exit press CTRL+C')channel.start_consuming() 实验运行打开多个终端,分别传入不同的规则,观察结果如: 123python3 receive_topic.py \"#\"python3 receive_topic.py \"happy.*\"python3 receive_topic.py \"*.work\" 难点1、发送信息时，如果不设置路由键，那么路由键设置为”*”的接收端是否能接收到消息？ 发送信息时，如果不设置路由键，默认是表示广播出去，理论上所有接收端都可以收到消息，但是笔者试了下，路由键设置为”*”的接收端收不到任何消息。 只有发送消息时，设置路由键为一个词，路由键设置为”*”的接收端才能收到消息。在这里，每个词使用”.”符号分开的。 2、发送消息时，如果路由键设置为”..”，那么路由键设置为”#.*”的接收端是否能接收到消息？如果发送消息时，路由键设置为一个词呢？ 两种情况，笔者都测试过了，可以的。 3、”a.*.#” 和”a.#”的区别 “a.#”只要字符串开头的一个词是a就可以了，比如a、a.haha、a.haha.haha。而这样的词是不行的，如abs、abc、abc.haha。 “a..#”必须要满足a.的字符串才可以，比如a.、a.haha、a.haha.haha。而这样的词是不行的，如a。 远程结果返回RPCRemote Producre Call处理方法描述： 发送端在发送信息前，产生一个接收消息的临时队列，该队列用来接收返回的结果。其实在这里接收端、发送端的概念已经比较模糊了，因为发送端也同样要接收消息，接收端同样也要发送消息，所以这里笔者使用另外的示例来演示这一过程。 compute.py代码分析12345678910111213141516171819202122232425262728293031323334import pika# 连接rabbitmq服务器connection = pika.BlockingConnection(pika.ConnectionParameters( host='10.211.55.10'))channel = connection.channel()# 定义队列channel.queue_declare(queue='compute_queue')print(' [*] Waiting for n')# 将n值加1def increase(n): return n + 1# 定义接收到消息的处理方法def request(ch, method, properties, body): print(\" [.] increase(%s)\" % (body,)) response = increase(int(body)) # 将计算结果发送回控制中心 ch.basic_publish(exchange='', routing_key=properties.reply_to, body=str(response)) ch.basic_ack(delivery_tag=method.delivery_tag)channel.basic_qos(prefetch_count=1)channel.basic_consume(request, queue='compute_queue')channel.start_consuming() center.py代码分析123456789101112131415161718192021222324252627282930313233343536373839404142import pikaclass Center(object): def __init__(self): self.connection = pika.BlockingConnection(pika.ConnectionParameters( host='10.211.55.10')) self.channel = self.connection.channel() # 定义接收返回消息的队列 result = self.channel.queue_declare(exclusive=True) self.callback_queue = result.method.queue self.channel.basic_consume(self.on_response, no_ack=True, queue=self.callback_queue) # 定义接收到返回消息的处理方法 def on_response(self, ch, method, props, body): self.response = body def request(self, n): self.response = None # 发送计算请求，并声明返回队列 self.channel.basic_publish(exchange='', routing_key='compute_queue', properties=pika.BasicProperties( reply_to=self.callback_queue, ), body=str(n)) # 接收返回的数据 while self.response is None: self.connection.process_data_events() return int(self.response)center = Center()print(\" [x] Requesting increase(30)\")response = center.request(30)print(\" [.] Got %r\" % (response,)) 上面代码定义了接收返回数据的队列和处理方法，并且在发送请求的时候将该队列赋值给reply_to，在计算节点代码中就是通过这个参数来获取返回队列的。 相互关联编号correlation idcorrelation id运行原理： 控制中心发送计算请求时设置correlation id，而后计算节点将计算结果，连同接收到的correlation id一起返回，这样控制中心就能通过correlation id来标识请求。其实correlation id也可以理解为请求的唯一标识码。 示例内容： 控制中心开启多个线程，每个线程都发起一次计算请求，通过correlation id，每个线程都能准确收到相应的计算结果。 compute.py代码分析和上面相比，只需修改一个地方： 将计算结果发送回控制中心时，增加参数correlation_id的设定，该参数的值其实是从控制中心发送过来的，这里只是再次发送回去。代码如下： 123456789101112131415161718192021222324252627282930313233343536import pika# 连接rabbitmq服务器connection = pika.BlockingConnection(pika.ConnectionParameters( host='10.211.55.10'))channel = connection.channel()# 定义队列channel.queue_declare(queue='compute_queue')print(' [*] Waiting for n')# 将n值加1def increase(n): return n + 1# 定义接收到消息的处理方法def request(ch, method, props, body): print(\" [.] increase(%s)\" % (body,)) response = increase(int(body)) # 将计算结果发送回控制中心，增加correlation_id的设定 ch.basic_publish(exchange='', routing_key=props.reply_to, properties=pika.BasicProperties(correlation_id= \\ props.correlation_id), body=str(response)) ch.basic_ack(delivery_tag=method.delivery_tag)channel.basic_qos(prefetch_count=1)channel.basic_consume(request, queue='compute_queue')channel.start_consuming() center.py代码分析控制中心代码稍微复杂些，其中比较关键的有三个地方： 使用python的uuid来产生唯一的correlation_id。 发送计算请求时，设定参数correlation_id。 定义一个字典来保存返回的数据，并且键值为相应线程产生的correlation_id。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import pika, threading, uuid# 自定义线程类，继承threading.Threadclass MyThread(threading.Thread): def __init__(self, func, num): super(MyThread, self).__init__() self.func = func self.num = num def run(self): print(\" [x] Requesting increase(%d)\" % self.num) response = self.func(self.num) print(\" [.] increase(%d)=%d\" % (self.num, response))# 控制中心类class Center(object): def __init__(self): self.connection = pika.BlockingConnection(pika.ConnectionParameters( host='10.211.55.10')) self.channel = self.connection.channel() # 定义接收返回消息的队列 result = self.channel.queue_declare(exclusive=True) self.callback_queue = result.method.queue self.channel.basic_consume(self.on_response, no_ack=True, queue=self.callback_queue) # 返回的结果都会存储在该字典里 self.response = &#123;&#125; # 定义接收到返回消息的处理方法 def on_response(self, ch, method, props, body): self.response[props.correlation_id] = body def request(self, n): corr_id = str(uuid.uuid4()) # 产生 id self.response[corr_id] = None # 发送计算请求，并设定返回队列和correlation_id self.channel.basic_publish(exchange='', routing_key='compute_queue', properties=pika.BasicProperties( reply_to=self.callback_queue, correlation_id=corr_id, ), body=str(n)) # 接收返回的数据 while self.response[corr_id] is None: self.connection.process_data_events() return int(self.response[corr_id])center = Center()# 发起5次计算请求nums = [10, 20, 30, 40, 50]threads = []for num in nums: threads.append(MyThread(center.request, num))for thread in threads: thread.start()for thread in threads: thread.join() 参考资料http://blog.csdn.net/chenjiebin/article/details/8253433","categories":[],"tags":[{"name":"Rabbitmq","slug":"Rabbitmq","permalink":"https://cvno.github.io/tags/Rabbitmq/"}]},{"title":"密码学基础","slug":"密码学基础","date":"2017-11-01T12:10:33.000Z","updated":"2017-12-20T13:20:54.000Z","comments":true,"path":"密码学基础/","link":"","permalink":"https://cvno.github.io/密码学基础/","excerpt":"平常用的登录密码不叫密码，是登录口令","text":"平常用的登录密码不叫密码，是登录口令 密码有一个加密和解密的过程 video: https://youtu.be/loJ62rvH8aE 古典密码凯撒密码123ABCCDE// 往后移动3位或者多位 非常容易破解 维吉尼亚密码 不知道密钥是非常非常难破解的 RSA 公钥 私钥 12明文--&gt; 公钥 --&gt; 密文密文--&gt; 私钥 --&gt; 明文 基于大数难分解两个质数相乘 12345678910111213p1 = 53p2 = 59n = 3127 # 53 * 59 = 3127# 欧拉函数Φ(n)(p1-1)*(p2-1)= 3016 # fai 小写 φe = 3 # e 和欧拉函数互质 只要互质随便取# 公钥是 n，ed = (k*φ(n)+1)/e = 2011 # 私钥 (2**3016+1)/3 = 2011# 验证m = 89 # 加密信息 c = (m**e)%n = 1394 # 密文 (89**3)%3127 = 1394明文 = (x**d)%n = 89 # 明文 (1394**2011)%3127 = 89 扩展: 费马小定理来验证.","categories":[],"tags":[]},{"title":"列表查找","slug":"列表查找","date":"2017-09-21T04:09:36.000Z","updated":"2017-12-21T13:39:39.000Z","comments":true,"path":"列表查找/","link":"","permalink":"https://cvno.github.io/列表查找/","excerpt":"","text":"顺序查找 从列表第一个元素开始，顺序进行搜索，直到找到为止。 12345678910li = [1,2,3]index(1) # 顺序查找# 顺序查找 ipython O(n) 复杂度import randomn = 10000li = list(range(n))random.shuffle(li)%timeit li.index(3200)#221 µs ± 11.1 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each) 二分查找 只能用于有序列表 从有序列表的候选区data[0:n]开始，通过对待查找的值与候选区中间值的比较，可以使候选区减少一半。O(logn) 复杂度 12345678910111213141516171819202122232425262728293031323334353637# 二分查找# 循环版本# def bin_search(li,low,high):def bin_search(li, val): '''循环二分 时间复杂度 O(logn)''' low = 0 high = len(li) - 1 while low &lt;= high: mid = (low + high) // 2 if li[mid] == val: return mid elif li[mid] &lt; val: low = mid + 1 else: # &gt; high = mid - 1 return None# 5.6 µs ± 441 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)# 递归版本 递归需要切换进出栈def bin_search_rec(data_set,value,low,high): ''' 尾递归 和 非递归的效率基本一样 ''' if low &lt;= high: mid = (low+high) // 2 if data_set[mid] == value: return mid elif data_set[mid] &gt; value: # 尾递归不用切换出栈 return bin_search_rec(data_set,value,low,mid-1) else: return bin_search_rec(data_set,value,mid+1,high) else: return# %timeit l1.index(3200)# l1.sort() # 排序# %timeit bin_search(l1,3200)print(bin_search(l1,4000)) 刷题：Letcode34. Search for a Range (二分查找升级版)1. Two Sum 习题1 34. Search for a Range (二分查找升级版) 12345678910111213141516171819def bin_search(li, val): '''循环二分 时间复杂度 O(logn)''' low = 0 high = len(li) - 1 while low &lt;= high: mid = (low + high) // 2 if li[mid] == val: a = mid b = mid while li[a] = value and a &gt;= 1: a -= 1 while li[b] = value and b &lt; len(li): # b &lt;= len(li) - 1 b += 1 return (a+1,b-1) elif li[mid] &lt; val: low = mid + 1 else: # &gt; high = mid - 1 return None 2 . 1. Two Sum 12345678910def two_sum(nums, target): l = len(nums) for i in range(l): for j in range(i+1,l): print(nums[i],nums[j]) if nums[i] + nums[j] == target: return (i,j) return None print(two_sum([2, 7, 11, 15],9)) 或者 1234567891011121314151617181920212223242526272829303132333435def bin_search(data_set, value): low = 0 high = len(data_set) - 1 while low &lt;= high: mid = (low + high) // 2 if data_set[mid] == value: return mid elif data_set[mid] &gt; value: high = mid - 1 else: low = mid + 1def two_sum_2(li, target): li.sort() for i in range(len(li)): b = target - li[i] j = bin_search(li, b) if j != None and i != j: return i, jprint(two_sum_2([2, 7, 11], 14))def two_sum_3(li, target): li.sort() # nlogn i = 0 j = len(li) - 1 while i&lt;j: sum = li[i]+li[j] if sum &gt; target: j-=1 elif sum &lt; target: i+=1 else: #sum==target return (i,j) return None 扩展1. Two Sum 如果是 3 个数 就把第一个数固定, 后面的列表用 two_sum_3 来计算 如果这样时间复杂度nlogn + n²最终的时间复杂度是 n² 如果用二分查找, 就需要先排序, 定住两个数, 排序(nlogn) + 定住两个数(n²) 二分(n²logn) 最终的复杂度是 n²logn","categories":[{"name":"算法","slug":"算法","permalink":"https://cvno.github.io/categories/算法/"}],"tags":[]},{"title":"时间复杂度与空间复杂度","slug":"时间复杂度与空间复杂度","date":"2017-09-20T04:11:51.000Z","updated":"2017-12-21T13:39:49.000Z","comments":true,"path":"时间复杂度与空间复杂度/","link":"","permalink":"https://cvno.github.io/时间复杂度与空间复杂度/","excerpt":"算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。用来评估算法运行效率的单位。","text":"算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。用来评估算法运行效率的单位。 时间复杂度 时间复杂度是用来估计算法运行时间的一个式子（单位） T(n) = O(n^2) 按数量级递增排列，常见的时间复杂度有：常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n2)，立方阶O(n3),…， k次方阶O(nk),指数阶O(2n)。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。 一般来说,时间复杂度高的算法比复杂度底的算法慢. 12345678910111213print('Hello World') # O(1)for i in range(n): # O(n) print('Hello World')for i in range(n): # O(n²) for i in range(n): print('Hello World')for i in range(n): # O(n³) for j in rnage(n): for k in range(n): print('Hello World') 如何一眼判断时间复杂度 循环减半的过程 –&gt;O(logn) 几次循环就是n的几次方的复杂度 时间复杂度排序 常见的时间复杂度 1O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n²)&lt;O(n²logn)&lt;O(n³) 不常见的时间复杂度 1O(n!) O(2n) O(nn) … 几秒钟/O(1) 几分钟/O(n) 几小时/O(n²) // 2 平方 高级： 函数 见进阶 判断时间复杂度123456789101112131415# 1 O(1) 时间复杂度print('Hello World')print('Hello Python')print('Hello Algorithm')# 2 O(n²) 时间复杂度for i in range(n): print('Hello World') for i in range(n): print('Hello World')# 3 O(n²) 时间复杂度for i in range(n): for j in range(i): print('Hello World') 1234567# 以2为底64的对数n = 64while n &gt; 1: print(n) n = n // 2# 时间复杂度 O(log2n) / O(logn)# 每次少一半 空间复杂度 用来评估算法内存占用大小的式子 S(n) = O(n^2) 表示内存占用时间复杂度比空间复杂度更重要 空间换时间 一个列表就是 O(n)二维列表复杂度就是 O(n²)…","categories":[{"name":"算法","slug":"算法","permalink":"https://cvno.github.io/categories/算法/"}],"tags":[]},{"title":"Charles: Response 出现乱码","slug":"Charles-Response-乱码","date":"2017-09-18T13:19:42.000Z","updated":"2017-12-20T13:18:41.000Z","comments":true,"path":"Charles-Response-乱码/","link":"","permalink":"https://cvno.github.io/Charles-Response-乱码/","excerpt":"使用 Charles 抓 https 包的时候, Reponse 出现乱码","text":"使用 Charles 抓 https 包的时候, Reponse 出现乱码 系统环境: MAC软件版本: 4.2.1浏览器: Google Chrome 原因没有信任 Charles 的证书,信任 Charles 的证书就好了 解决方法安装 Charles 证书Help &gt; SSL Proxying &gt; Install Charles Root Certificate 信任 Charles 证书安装完成后会自动弹出钥匙串,找到 Charles 的证书信任即可 Charles 设置Proxy &gt; SSL Proxying Settings ok后记发布这篇文章的时候问题已经被解决,但是没有问题截图,有时间的话再补上.","categories":[],"tags":[{"name":"Charles","slug":"Charles","permalink":"https://cvno.github.io/tags/Charles/"}]}]}